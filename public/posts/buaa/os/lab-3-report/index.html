<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>[BUAA-OS] Lab 3 实验报告 | oNya's Blog</title>
<meta name=keywords content><meta name=description content="一、思考题
Thinking 3.1

请结合MOS中的页目录自映射应用解释代码中 e->env_pgdir[PDX(UVPT)] = PADDR(e->env_pgdir) | PTE_V 的含义。

UVPT是用户页表的起始虚拟地址，所以e->env_pgdir[PDX(UVPT)]是当前进程的虚拟内存中，UVPT地址所在的页目录项。而e->env_pgdir是当前进程页目录的虚拟地址，PADDR(e->env_pgdir)则是其物理地址，| PTE_V是附上权限位。"><meta name=author content="oNya"><link rel=canonical href=%7b%7b%20.Permalink%20%7d%7d><link crossorigin=anonymous href=/assets/css/stylesheet.79e07885fe54214be03f273758b2bda9bbf1210d3eba9e9b5be2955ca8fdb800.css integrity="sha256-eeB4hf5UIUvgPyc3WLK9qbvxIQ0+up6bW+KVXKj9uAA=" rel="preload stylesheet" as=style><link rel=icon href=https://oNya685.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://oNya685.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://oNya685.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://oNya685.github.io/apple-touch-icon.png><link rel=mask-icon href=https://oNya685.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://oNya685.github.io/posts/buaa/os/lab-3-report/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=Ubuntu+Mono:ital,wght@0,400;0,700;1,400;1,700&family=Ubuntu:ital,wght@0,300;0,400;0,500;0,700;1,300;1,400;1,500;1,700&display=swap" rel=stylesheet><link rel=preconnect href=https://static.zeoseven.com crossorigin><link rel=stylesheet href=https://static.zeoseven.com/zsft/372/main/result.css onerror='this.href="https://static-host.zeoseven.com/zsft/372/main/result.css"'><link rel=stylesheet href=https://static.zeoseven.com/zsft/25/main/result.css onerror='this.href="https://static-host.zeoseven.com/zsft/25/main/result.css"'><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.css integrity=sha384-MlJdn/WNKDGXveldHDdyRP1R4CTHr3FeuDNfhsLPYrq2t0UBkUdK2jyTnXPEK1NQ crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.js integrity=sha384-VQ8d8WVFw0yHhCk5E8I86oOhv48xLpnDZx5T9GogA/Y84DcCKWXDmSDfn13bzFZY crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/contrib/auto-render.min.js integrity=sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR crossorigin=anonymous onload=renderMathInElement(document.body)></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}]})})</script><meta property="og:url" content="https://oNya685.github.io/posts/buaa/os/lab-3-report/"><meta property="og:site_name" content="oNya's Blog"><meta property="og:title" content="[BUAA-OS] Lab 3 实验报告"><meta property="og:description" content="一、思考题 Thinking 3.1 请结合MOS中的页目录自映射应用解释代码中 e->env_pgdir[PDX(UVPT)] = PADDR(e->env_pgdir) | PTE_V 的含义。
UVPT是用户页表的起始虚拟地址，所以e->env_pgdir[PDX(UVPT)]是当前进程的虚拟内存中，UVPT地址所在的页目录项。而e->env_pgdir是当前进程页目录的虚拟地址，PADDR(e->env_pgdir)则是其物理地址，| PTE_V是附上权限位。"><meta property="og:locale" content="zh-cn"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-04-21T09:26:00+08:00"><meta property="article:modified_time" content="2025-04-21T09:26:00+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="[BUAA-OS] Lab 3 实验报告"><meta name=twitter:description content="一、思考题
Thinking 3.1

请结合MOS中的页目录自映射应用解释代码中 e->env_pgdir[PDX(UVPT)] = PADDR(e->env_pgdir) | PTE_V 的含义。

UVPT是用户页表的起始虚拟地址，所以e->env_pgdir[PDX(UVPT)]是当前进程的虚拟内存中，UVPT地址所在的页目录项。而e->env_pgdir是当前进程页目录的虚拟地址，PADDR(e->env_pgdir)则是其物理地址，| PTE_V是附上权限位。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://oNya685.github.io/posts/"},{"@type":"ListItem","position":2,"name":"北京航空航天大学","item":"https://oNya685.github.io/posts/buaa/"},{"@type":"ListItem","position":3,"name":"操作系统","item":"https://oNya685.github.io/posts/buaa/os/"},{"@type":"ListItem","position":4,"name":"[BUAA-OS] Lab 3 实验报告","item":"https://oNya685.github.io/posts/buaa/os/lab-3-report/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"[BUAA-OS] Lab 3 实验报告","name":"[BUAA-OS] Lab 3 实验报告","description":"一、思考题 Thinking 3.1 请结合MOS中的页目录自映射应用解释代码中 e-\u0026gt;env_pgdir[PDX(UVPT)] = PADDR(e-\u0026gt;env_pgdir) | PTE_V 的含义。\nUVPT是用户页表的起始虚拟地址，所以e-\u0026gt;env_pgdir[PDX(UVPT)]是当前进程的虚拟内存中，UVPT地址所在的页目录项。而e-\u0026gt;env_pgdir是当前进程页目录的虚拟地址，PADDR(e-\u0026gt;env_pgdir)则是其物理地址，| PTE_V是附上权限位。\n","keywords":[],"articleBody":"一、思考题 Thinking 3.1 请结合MOS中的页目录自映射应用解释代码中 e-\u003eenv_pgdir[PDX(UVPT)] = PADDR(e-\u003eenv_pgdir) | PTE_V 的含义。\nUVPT是用户页表的起始虚拟地址，所以e-\u003eenv_pgdir[PDX(UVPT)]是当前进程的虚拟内存中，UVPT地址所在的页目录项。而e-\u003eenv_pgdir是当前进程页目录的虚拟地址，PADDR(e-\u003eenv_pgdir)则是其物理地址，| PTE_V是附上权限位。\n这句赋值语句的含义是，将访问UVPT时解析的页目录项映射到的页框号设置为页目录的物理地址所在页的页框号，并附上权限位。\nThinking 3.2 elf_load_seg 以函数指针的形式，接受外部自定义的回调函数 map_page。请你找到与之相关的data这一参数在此处的来源，并思考它的作用。没有这个参数可不可以？为什么？\ndata 是传入load_icode函数的参数中的指向一个进程控制块的指针(struct Env *)。\n不能没有这个参数。它的作用是传入load_icode_mapper类型转换为进程控制块指针，获取其env_pgdir并对其进程空间执行page_insert。缺少该参数则无法正常运行load_icode_mapper。\nThinking 3.3 结合 elf_load_seg 的参数和实现，考虑该函数需要处理哪些页面加载的情况。\nint elf_load_seg(Elf32_Phdr *ph, const void *bin, elf_mapper_t map_page, void *data) { u_long va = ph-\u003ep_vaddr; size_t bin_size = ph-\u003ep_filesz; size_t sgsize = ph-\u003ep_memsz; u_int perm = PTE_V; if (ph-\u003ep_flags \u0026 PF_W) { perm |= PTE_D; } int r; size_t i; u_long offset = va - ROUNDDOWN(va, PAGE_SIZE); // 1.非页对齐的段起始地址 // 当段的虚拟地址va不是页对齐的（offset != 0），函数会先映射一个不完整的页，加载文件中对应的部分数据到该页的偏移位置。 if (offset != 0) { if ((r = map_page(data, va, offset, perm, bin, MIN(bin_size, PAGE_SIZE - offset))) != 0) { return r; } } // 2.逐页加载文件数据 // 对于段中包含文件数据的部分（bin_size范围内），函数分页处理，每页调用map_page，将文件数据加载到对应虚拟地址。 /* Step 1: load all content of bin into memory. */ for (i = offset ? MIN(bin_size, PAGE_SIZE - offset) : 0; i \u003c bin_size; i += PAGE_SIZE) { if ((r = map_page(data, va + i, 0, perm, bin + i, MIN(bin_size - i, PAGE_SIZE))) != 0) { return r; } } // 3.内存扩展分配与零初始化 // 当段的内存大小sgsize大于文件大小bin_size时，函数继续分配页并初始化为零，确保段在内存中完整分配。 /* Step 2: alloc pages to reach `sgsize` when `bin_size` \u003c `sgsize`. */ while (i \u003c sgsize) { if ((r = map_page(data, va + i, 0, perm, NULL, MIN(sgsize - i, PAGE_SIZE))) != 0) { return r; } i += PAGE_SIZE; } return 0; } Thinking 3.4 思考上面这一段话，并根据自己在Lab2中的理解，回答：\n你认为这里的env_tf.cp0_epc存储的是物理地址还是虚拟地址? epc存储的是虚拟地址。\nThinking 3.5 试找出0、1、2、3号异常处理函数的具体实现位置。8号异常（系统调用）涉及的do_syscall()函数将在Lab4中实现。\n0、1、2、3号异常处理函数的具体实现在genex.S中。\nThinking 3.6 阅读entry.S、genex.S和env_asm.S这几个文件，并尝试说出时钟中断在哪些时候开启，在哪些时候关闭。\n在entry.S中关闭时钟中断； 在env_asm.S中重置时钟； 在genex.S中开启时钟中断。\nThinking 3.7 阅读相关代码，思考操作系统是怎么根据时钟中断切换进程的。\n在进程运行时触发时钟中断，跳转exc_gen_entry，进入hande_int，从而通过schedule进行调度切换进程。\n二、难点分析与实验体会 1. 进程的内存空间分布 进程的内存空间由页目录和页表进行管理，页目录项自映射使得页目录本身的物理地址能够被映射到虚拟地址空间（如UVPT）。这为内核提供了直接访问进程页目录的能力，方便进行页表操作和内存空间的管理。 进程的用户态页面（如代码段、数据段、堆栈等）通过页目录和页表进行映射，系统调用elf_load_seg等函数时，会根据 ELF 文件的程序头部信息，将文件中的代码和数据段加载到相应的虚拟地址，并设置正确的页权限。 2. 中断的处理流程 中断处理从硬件触发开始，CPU在检测到中断信号后，会暂停当前进程的执行，保存当前的执行上下文（如cp0_epc寄存器保存中断发生时的指令指针），并将控制权转移到中断处理程序。 时钟中断通过genex.S中的异常处理入口exc_gen_entry进行处理。内核会根据中断类型调用相应的处理函数，如时钟中断主要用于进程调度，通过调用schedule函数实现进程的切换。 中断处理需要考虑中断源的多样性，包括时钟中断、外部设备中断、软件异常等，并执行相应的处理逻辑。 三、原创说明 无参考资料。\n","wordCount":"1726","inLanguage":"en","datePublished":"2025-04-21T09:26:00+08:00","dateModified":"2025-04-21T09:26:00+08:00","author":{"@type":"Person","name":"oNya"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://oNya685.github.io/posts/buaa/os/lab-3-report/"},"publisher":{"@type":"Organization","name":"oNya's Blog","logo":{"@type":"ImageObject","url":"https://oNya685.github.io/favicon.ico"}}}</script><script src=https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js></script><link rel=stylesheet href=https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css><script src=https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js></script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://oNya685.github.io/ accesskey=h title="主页 | oNya's Blog (Alt + H)"><img src=https://oNya685.github.io/ alt aria-label=logo height=30>主页 | oNya's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://oNya685.github.io/archives/ title=归档><span>归档</span></a></li><li><a href=https://oNya685.github.io/categories/ title=分类><span>分类</span></a></li><li><a href=https://oNya685.github.io/tags/ title=标签><span>标签</span></a></li><li><a href=https://oNya685.github.io/links/ title=链接><span>链接</span></a></li><li><a href=https://oNya685.github.io/search/ title=搜索><span>搜索</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://oNya685.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://oNya685.github.io/posts/>Posts</a>&nbsp;»&nbsp;<a href=https://oNya685.github.io/posts/buaa/>北京航空航天大学</a>&nbsp;»&nbsp;<a href=https://oNya685.github.io/posts/buaa/os/>操作系统</a></div><h1 class="post-title entry-hint-parent">[BUAA-OS] Lab 3 实验报告</h1><div class=post-meta><span title='2025-04-21 09:26:00 +0800 CST'>2025年4月21日</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;1726 words&nbsp;·&nbsp;oNya</div></header><aside id=toc-container class="toc-container wide"><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%e4%b8%80%e6%80%9d%e8%80%83%e9%a2%98 aria-label=一、思考题>一、思考题</a><ul><li><a href=#thinking-31 aria-label="Thinking 3.1">Thinking 3.1</a></li><li><a href=#thinking-32 aria-label="Thinking 3.2">Thinking 3.2</a></li><li><a href=#thinking-33 aria-label="Thinking 3.3">Thinking 3.3</a></li><li><a href=#thinking-34 aria-label="Thinking 3.4">Thinking 3.4</a></li><li><a href=#thinking-35 aria-label="Thinking 3.5">Thinking 3.5</a></li><li><a href=#thinking-36 aria-label="Thinking 3.6">Thinking 3.6</a></li><li><a href=#thinking-37 aria-label="Thinking 3.7">Thinking 3.7</a></li></ul></li><li><a href=#%e4%ba%8c%e9%9a%be%e7%82%b9%e5%88%86%e6%9e%90%e4%b8%8e%e5%ae%9e%e9%aa%8c%e4%bd%93%e4%bc%9a aria-label=二、难点分析与实验体会>二、难点分析与实验体会</a><ul><li><a href=#1-%e8%bf%9b%e7%a8%8b%e7%9a%84%e5%86%85%e5%ad%98%e7%a9%ba%e9%97%b4%e5%88%86%e5%b8%83 aria-label="1. 进程的内存空间分布">1. 进程的内存空间分布</a></li><li><a href=#2-%e4%b8%ad%e6%96%ad%e7%9a%84%e5%a4%84%e7%90%86%e6%b5%81%e7%a8%8b aria-label="2. 中断的处理流程">2. 中断的处理流程</a></li></ul></li><li><a href=#%e4%b8%89%e5%8e%9f%e5%88%9b%e8%af%b4%e6%98%8e aria-label=三、原创说明>三、原创说明</a></li></ul></div></details></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),activeElement=elements[0];const t=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{activeElement=Array.from(elements).find(e=>{if(getOffsetTop(e)-window.pageYOffset>0&&getOffsetTop(e)-window.pageYOffset<window.innerHeight/2)return e})||activeElement,elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase();e===activeElement?document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active"):document.querySelector(`.inner ul li a[href="#${t}"]`).classList.remove("active")})},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><h1 id=一思考题>一、思考题<a hidden class=anchor aria-hidden=true href=#一思考题>#</a></h1><h2 id=thinking-31>Thinking 3.1<a hidden class=anchor aria-hidden=true href=#thinking-31>#</a></h2><blockquote><p>请结合MOS中的页目录自映射应用解释代码中 <code>e->env_pgdir[PDX(UVPT)] = PADDR(e->env_pgdir) | PTE_V</code> 的含义。</p></blockquote><hr><p><code>UVPT</code>是用户页表的起始虚拟地址，所以<code>e->env_pgdir[PDX(UVPT)]</code>是当前进程的虚拟内存中，<code>UVPT</code>地址所在的页目录项。而<code>e->env_pgdir</code>是当前进程页目录的虚拟地址，<code>PADDR(e->env_pgdir)</code>则是其物理地址，<code>| PTE_V</code>是附上权限位。</p><p>这句赋值语句的含义是，将访问<code>UVPT</code>时解析的页目录项映射到的页框号设置为页目录的物理地址所在页的页框号，并附上权限位。</p><h2 id=thinking-32>Thinking 3.2<a hidden class=anchor aria-hidden=true href=#thinking-32>#</a></h2><blockquote><p>elf_load_seg 以函数指针的形式，接受外部自定义的回调函数 map_page。请你找到与之相关的data这一参数在此处的来源，并思考它的作用。没有这个参数可不可以？为什么？</p></blockquote><hr><p>data 是传入<code>load_icode</code>函数的参数中的指向一个进程控制块的指针(<code>struct Env *</code>)。</p><p>不能没有这个参数。它的作用是传入<code>load_icode_mapper</code>类型转换为进程控制块指针，获取其<code>env_pgdir</code>并对其进程空间执行<code>page_insert</code>。缺少该参数则无法正常运行<code>load_icode_mapper</code>。</p><h2 id=thinking-33>Thinking 3.3<a hidden class=anchor aria-hidden=true href=#thinking-33>#</a></h2><blockquote><p>结合 elf_load_seg 的参数和实现，考虑该函数需要处理哪些页面加载的情况。</p></blockquote><hr><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>elf_load_seg</span>(Elf32_Phdr <span style=color:#f92672>*</span>ph, <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>bin, <span style=color:#66d9ef>elf_mapper_t</span> map_page, <span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>data) {
</span></span><span style=display:flex><span>	u_long va <span style=color:#f92672>=</span> ph<span style=color:#f92672>-&gt;</span>p_vaddr;
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>size_t</span> bin_size <span style=color:#f92672>=</span> ph<span style=color:#f92672>-&gt;</span>p_filesz;
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>size_t</span> sgsize <span style=color:#f92672>=</span> ph<span style=color:#f92672>-&gt;</span>p_memsz;
</span></span><span style=display:flex><span>	u_int perm <span style=color:#f92672>=</span> PTE_V;
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> (ph<span style=color:#f92672>-&gt;</span>p_flags <span style=color:#f92672>&amp;</span> PF_W) {
</span></span><span style=display:flex><span>		perm <span style=color:#f92672>|=</span> PTE_D;
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>int</span> r;
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>size_t</span> i;
</span></span><span style=display:flex><span>	u_long offset <span style=color:#f92672>=</span> va <span style=color:#f92672>-</span> <span style=color:#a6e22e>ROUNDDOWN</span>(va, PAGE_SIZE);
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 1.非页对齐的段起始地址  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// 当段的虚拟地址va不是页对齐的（offset != 0），函数会先映射一个不完整的页，加载文件中对应的部分数据到该页的偏移位置。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#66d9ef>if</span> (offset <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> ((r <span style=color:#f92672>=</span> <span style=color:#a6e22e>map_page</span>(data, va, offset, perm, bin,
</span></span><span style=display:flex><span>				  <span style=color:#a6e22e>MIN</span>(bin_size, PAGE_SIZE <span style=color:#f92672>-</span> offset))) <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>return</span> r;
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 2.逐页加载文件数据
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// 对于段中包含文件数据的部分（bin_size范围内），函数分页处理，每页调用map_page，将文件数据加载到对应虚拟地址。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>/* Step 1: load all content of bin into memory. */</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> (i <span style=color:#f92672>=</span> offset <span style=color:#f92672>?</span> <span style=color:#a6e22e>MIN</span>(bin_size, PAGE_SIZE <span style=color:#f92672>-</span> offset) <span style=color:#f92672>:</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> bin_size; i <span style=color:#f92672>+=</span> PAGE_SIZE) {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> ((r <span style=color:#f92672>=</span> <span style=color:#a6e22e>map_page</span>(data, va <span style=color:#f92672>+</span> i, <span style=color:#ae81ff>0</span>, perm, bin <span style=color:#f92672>+</span> i, <span style=color:#a6e22e>MIN</span>(bin_size <span style=color:#f92672>-</span> i, PAGE_SIZE))) <span style=color:#f92672>!=</span>
</span></span><span style=display:flex><span>		    <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>return</span> r;
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 3.内存扩展分配与零初始化
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// 当段的内存大小sgsize大于文件大小bin_size时，函数继续分配页并初始化为零，确保段在内存中完整分配。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>/* Step 2: alloc pages to reach `sgsize` when `bin_size` &lt; `sgsize`. */</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>while</span> (i <span style=color:#f92672>&lt;</span> sgsize) {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> ((r <span style=color:#f92672>=</span> <span style=color:#a6e22e>map_page</span>(data, va <span style=color:#f92672>+</span> i, <span style=color:#ae81ff>0</span>, perm, NULL, <span style=color:#a6e22e>MIN</span>(sgsize <span style=color:#f92672>-</span> i, PAGE_SIZE))) <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>return</span> r;
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		i <span style=color:#f92672>+=</span> PAGE_SIZE;
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=thinking-34>Thinking 3.4<a hidden class=anchor aria-hidden=true href=#thinking-34>#</a></h2><blockquote><p>思考上面这一段话，并根据自己在Lab2中的理解，回答：</p><ul><li>你认为这里的env_tf.cp0_epc存储的是物理地址还是虚拟地址?</li></ul></blockquote><hr><p><code>epc</code>存储的是<strong>虚拟地址</strong>。</p><h2 id=thinking-35>Thinking 3.5<a hidden class=anchor aria-hidden=true href=#thinking-35>#</a></h2><blockquote><p>试找出0、1、2、3号异常处理函数的具体实现位置。8号异常（系统调用）涉及的do_syscall()函数将在Lab4中实现。</p></blockquote><hr><p>0、1、2、3号异常处理函数的具体实现在<code>genex.S</code>中。</p><h2 id=thinking-36>Thinking 3.6<a hidden class=anchor aria-hidden=true href=#thinking-36>#</a></h2><blockquote><p>阅读entry.S、genex.S和env_asm.S这几个文件，并尝试说出时钟中断在哪些时候开启，在哪些时候关闭。</p></blockquote><hr><p>在<code>entry.S</code>中关闭时钟中断；
在<code>env_asm.S</code>中重置时钟；
在<code>genex.S</code>中开启时钟中断。</p><h2 id=thinking-37>Thinking 3.7<a hidden class=anchor aria-hidden=true href=#thinking-37>#</a></h2><blockquote><p>阅读相关代码，思考操作系统是怎么根据时钟中断切换进程的。</p></blockquote><hr><p>在进程运行时触发时钟中断，跳转<code>exc_gen_entry</code>，进入<code>hande_int</code>，从而通过<code>schedule</code>进行调度切换进程。</p><h1 id=二难点分析与实验体会>二、难点分析与实验体会<a hidden class=anchor aria-hidden=true href=#二难点分析与实验体会>#</a></h1><h2 id=1-进程的内存空间分布>1. 进程的内存空间分布<a hidden class=anchor aria-hidden=true href=#1-进程的内存空间分布>#</a></h2><ul><li>进程的内存空间由页目录和页表进行管理，页目录项自映射使得页目录本身的物理地址能够被映射到虚拟地址空间（如<code>UVPT</code>）。这为内核提供了直接访问进程页目录的能力，方便进行页表操作和内存空间的管理。</li><li>进程的用户态页面（如代码段、数据段、堆栈等）通过页目录和页表进行映射，系统调用<code>elf_load_seg</code>等函数时，会根据 ELF 文件的程序头部信息，将文件中的代码和数据段加载到相应的虚拟地址，并设置正确的页权限。</li></ul><h2 id=2-中断的处理流程>2. 中断的处理流程<a hidden class=anchor aria-hidden=true href=#2-中断的处理流程>#</a></h2><ul><li>中断处理从硬件触发开始，CPU在检测到中断信号后，会暂停当前进程的执行，保存当前的执行上下文（如<code>cp0_epc</code>寄存器保存中断发生时的指令指针），并将控制权转移到中断处理程序。</li><li>时钟中断通过<code>genex.S</code>中的异常处理入口<code>exc_gen_entry</code>进行处理。内核会根据中断类型调用相应的处理函数，如时钟中断主要用于进程调度，通过调用<code>schedule</code>函数实现进程的切换。</li><li>中断处理需要考虑中断源的多样性，包括时钟中断、外部设备中断、软件异常等，并执行相应的处理逻辑。</li></ul><h1 id=三原创说明>三、原创说明<a hidden class=anchor aria-hidden=true href=#三原创说明>#</a></h1><p>无参考资料。</p></div><footer class=post-footer><ul class=post-tags></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://oNya685.github.io/>oNya's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script><script>(function(e,t){var s=document,o="script",n=s.createElement(o),i=s.getElementsByTagName(o)[0];n.src=e,t&&n.addEventListener("load",function(e){t(e)}),i.parentNode.insertBefore(n,i)})("//cdn.jsdelivr.net/npm/pangu@4.0.7/dist/browser/pangu.min.js",function(){pangu.spacingPage()})</script></body></html>