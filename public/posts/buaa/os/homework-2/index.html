<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>[BUAA-OS] 理论作业 2 | oNya's Blog</title>
<meta name=keywords content><meta name=description content="点此查看作业源文件

1. 动态内存分配需要对内存分区进行管理，一般使用位图和空闲链表两种方法。128MB的内存以n字节为单元分配，对于链表，假设内存中数据段和空闲区交替排列，长度均为64KB。并假设链表中的每个节点需要记录32位的内存地址信息、16位长度信息和16位下一节点域信息。这两种方法分别需要多少字节的存储空间？哪种方法更好？

若使用位图方法：

$$单元数 = \frac{128MB}{nB} = \frac{2^{27}}{n}块$$$$所需存储空间 = \frac{2^{27}}{n}b = \frac{16}{n}MB$$
若使用空闲链表方法：

$$段数=\frac{128MB}{64KB+64KB} = 2^{10}段$$$$所需存储空间 = 2^{10} \times (32 + 16 + 16)b = 8KB$$
哪种方法更好：

当n<2048时，空闲链表所需存储空间更小，空闲链表方法更好；
当n>2048时，位图所需存储空间更小，位图方法更好。



2. 在一个交换系统中，按内存地址排列的空闲区大小是: 10KB、4KB、20KB、18KB、7KB、9KB、12KB和15KB。对于连续的段请求：12KB、10KB、9KB。使用FirstFit、BestFit、WorstFit和NextFit将找出哪些空闲区？

  
      
          段请求
          FirstFit
          BestFit
          WorstFit
          NextFit
      
  
  
      
          12KB
          20KB
          12KB
          20KB
          20KB
      
      
          10KB
          10KB
          10KB
          18KB
          18KB
      
      
          9KB
          18KB
          9KB
          15KB
          9KB
      
  

3. 解释逻辑地址、物理地址、地址映射，并举例说明。


逻辑地址（Logical Address）：
逻辑地址是程序运行时由 CPU 生成的地址，也称为虚拟地址。用户进程只能访问逻辑地址，不能直接访问物理内存。
例如某程序访问地址 0x1234，但该地址只是进程的逻辑地址空间中的一部分。"><meta name=author content="oNya"><link rel=canonical href=%7b%7b%20.Permalink%20%7d%7d><link crossorigin=anonymous href=/assets/css/stylesheet.79e07885fe54214be03f273758b2bda9bbf1210d3eba9e9b5be2955ca8fdb800.css integrity="sha256-eeB4hf5UIUvgPyc3WLK9qbvxIQ0+up6bW+KVXKj9uAA=" rel="preload stylesheet" as=style><link rel=icon href=https://oNya685.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://oNya685.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://oNya685.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://oNya685.github.io/apple-touch-icon.png><link rel=mask-icon href=https://oNya685.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://oNya685.github.io/posts/buaa/os/homework-2/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=Ubuntu+Mono:ital,wght@0,400;0,700;1,400;1,700&family=Ubuntu:ital,wght@0,300;0,400;0,500;0,700;1,300;1,400;1,500;1,700&display=swap" rel=stylesheet><link rel=preconnect href=https://static.zeoseven.com crossorigin><link rel=stylesheet href=https://static.zeoseven.com/zsft/372/main/result.css onerror='this.href="https://static-host.zeoseven.com/zsft/372/main/result.css"'><link rel=stylesheet href=https://static.zeoseven.com/zsft/25/main/result.css onerror='this.href="https://static-host.zeoseven.com/zsft/25/main/result.css"'><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.css integrity=sha384-MlJdn/WNKDGXveldHDdyRP1R4CTHr3FeuDNfhsLPYrq2t0UBkUdK2jyTnXPEK1NQ crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.js integrity=sha384-VQ8d8WVFw0yHhCk5E8I86oOhv48xLpnDZx5T9GogA/Y84DcCKWXDmSDfn13bzFZY crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/contrib/auto-render.min.js integrity=sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR crossorigin=anonymous onload=renderMathInElement(document.body)></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}]})})</script><meta property="og:url" content="https://oNya685.github.io/posts/buaa/os/homework-2/"><meta property="og:site_name" content="oNya's Blog"><meta property="og:title" content="[BUAA-OS] 理论作业 2"><meta property="og:description" content="点此查看作业源文件 1. 动态内存分配需要对内存分区进行管理，一般使用位图和空闲链表两种方法。128MB的内存以n字节为单元分配，对于链表，假设内存中数据段和空闲区交替排列，长度均为64KB。并假设链表中的每个节点需要记录32位的内存地址信息、16位长度信息和16位下一节点域信息。这两种方法分别需要多少字节的存储空间？哪种方法更好？ 若使用位图方法： $$单元数 = \frac{128MB}{nB} = \frac{2^{27}}{n}块$$$$所需存储空间 = \frac{2^{27}}{n}b = \frac{16}{n}MB$$ 若使用空闲链表方法： $$段数=\frac{128MB}{64KB+64KB} = 2^{10}段$$$$所需存储空间 = 2^{10} \times (32 + 16 + 16)b = 8KB$$ 哪种方法更好： 当n<2048时，空闲链表所需存储空间更小，空闲链表方法更好； 当n>2048时，位图所需存储空间更小，位图方法更好。 2. 在一个交换系统中，按内存地址排列的空闲区大小是: 10KB、4KB、20KB、18KB、7KB、9KB、12KB和15KB。对于连续的段请求：12KB、10KB、9KB。使用FirstFit、BestFit、WorstFit和NextFit将找出哪些空闲区？ 段请求 FirstFit BestFit WorstFit NextFit 12KB 20KB 12KB 20KB 20KB 10KB 10KB 10KB 18KB 18KB 9KB 18KB 9KB 15KB 9KB 3. 解释逻辑地址、物理地址、地址映射，并举例说明。 逻辑地址（Logical Address）： 逻辑地址是程序运行时由 CPU 生成的地址，也称为虚拟地址。用户进程只能访问逻辑地址，不能直接访问物理内存。
例如某程序访问地址 0x1234，但该地址只是进程的逻辑地址空间中的一部分。"><meta property="og:locale" content="zh-cn"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-03-28T19:00:00+08:00"><meta property="article:modified_time" content="2025-03-28T19:00:00+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="[BUAA-OS] 理论作业 2"><meta name=twitter:description content="点此查看作业源文件

1. 动态内存分配需要对内存分区进行管理，一般使用位图和空闲链表两种方法。128MB的内存以n字节为单元分配，对于链表，假设内存中数据段和空闲区交替排列，长度均为64KB。并假设链表中的每个节点需要记录32位的内存地址信息、16位长度信息和16位下一节点域信息。这两种方法分别需要多少字节的存储空间？哪种方法更好？

若使用位图方法：

$$单元数 = \frac{128MB}{nB} = \frac{2^{27}}{n}块$$$$所需存储空间 = \frac{2^{27}}{n}b = \frac{16}{n}MB$$
若使用空闲链表方法：

$$段数=\frac{128MB}{64KB+64KB} = 2^{10}段$$$$所需存储空间 = 2^{10} \times (32 + 16 + 16)b = 8KB$$
哪种方法更好：

当n<2048时，空闲链表所需存储空间更小，空闲链表方法更好；
当n>2048时，位图所需存储空间更小，位图方法更好。



2. 在一个交换系统中，按内存地址排列的空闲区大小是: 10KB、4KB、20KB、18KB、7KB、9KB、12KB和15KB。对于连续的段请求：12KB、10KB、9KB。使用FirstFit、BestFit、WorstFit和NextFit将找出哪些空闲区？

  
      
          段请求
          FirstFit
          BestFit
          WorstFit
          NextFit
      
  
  
      
          12KB
          20KB
          12KB
          20KB
          20KB
      
      
          10KB
          10KB
          10KB
          18KB
          18KB
      
      
          9KB
          18KB
          9KB
          15KB
          9KB
      
  

3. 解释逻辑地址、物理地址、地址映射，并举例说明。


逻辑地址（Logical Address）：
逻辑地址是程序运行时由 CPU 生成的地址，也称为虚拟地址。用户进程只能访问逻辑地址，不能直接访问物理内存。
例如某程序访问地址 0x1234，但该地址只是进程的逻辑地址空间中的一部分。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://oNya685.github.io/posts/"},{"@type":"ListItem","position":2,"name":"北京航空航天大学","item":"https://oNya685.github.io/posts/buaa/"},{"@type":"ListItem","position":3,"name":"操作系统","item":"https://oNya685.github.io/posts/buaa/os/"},{"@type":"ListItem","position":4,"name":"[BUAA-OS] 理论作业 2","item":"https://oNya685.github.io/posts/buaa/os/homework-2/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"[BUAA-OS] 理论作业 2","name":"[BUAA-OS] 理论作业 2","description":"点此查看作业源文件 1. 动态内存分配需要对内存分区进行管理，一般使用位图和空闲链表两种方法。128MB的内存以n字节为单元分配，对于链表，假设内存中数据段和空闲区交替排列，长度均为64KB。并假设链表中的每个节点需要记录32位的内存地址信息、16位长度信息和16位下一节点域信息。这两种方法分别需要多少字节的存储空间？哪种方法更好？ 若使用位图方法： $$单元数 = \\frac{128MB}{nB} = \\frac{2^{27}}{n}块$$$$所需存储空间 = \\frac{2^{27}}{n}b = \\frac{16}{n}MB$$ 若使用空闲链表方法： $$段数=\\frac{128MB}{64KB+64KB} = 2^{10}段$$$$所需存储空间 = 2^{10} \\times (32 + 16 + 16)b = 8KB$$ 哪种方法更好： 当n\u0026lt;2048时，空闲链表所需存储空间更小，空闲链表方法更好； 当n\u0026gt;2048时，位图所需存储空间更小，位图方法更好。 2. 在一个交换系统中，按内存地址排列的空闲区大小是: 10KB、4KB、20KB、18KB、7KB、9KB、12KB和15KB。对于连续的段请求：12KB、10KB、9KB。使用FirstFit、BestFit、WorstFit和NextFit将找出哪些空闲区？ 段请求 FirstFit BestFit WorstFit NextFit 12KB 20KB 12KB 20KB 20KB 10KB 10KB 10KB 18KB 18KB 9KB 18KB 9KB 15KB 9KB 3. 解释逻辑地址、物理地址、地址映射，并举例说明。 逻辑地址（Logical Address）： 逻辑地址是程序运行时由 CPU 生成的地址，也称为虚拟地址。用户进程只能访问逻辑地址，不能直接访问物理内存。\n例如某程序访问地址 0x1234，但该地址只是进程的逻辑地址空间中的一部分。\n","keywords":[],"articleBody":"点此查看作业源文件 1. 动态内存分配需要对内存分区进行管理，一般使用位图和空闲链表两种方法。128MB的内存以n字节为单元分配，对于链表，假设内存中数据段和空闲区交替排列，长度均为64KB。并假设链表中的每个节点需要记录32位的内存地址信息、16位长度信息和16位下一节点域信息。这两种方法分别需要多少字节的存储空间？哪种方法更好？ 若使用位图方法： $$单元数 = \\frac{128MB}{nB} = \\frac{2^{27}}{n}块$$$$所需存储空间 = \\frac{2^{27}}{n}b = \\frac{16}{n}MB$$ 若使用空闲链表方法： $$段数=\\frac{128MB}{64KB+64KB} = 2^{10}段$$$$所需存储空间 = 2^{10} \\times (32 + 16 + 16)b = 8KB$$ 哪种方法更好： 当n\u003c2048时，空闲链表所需存储空间更小，空闲链表方法更好； 当n\u003e2048时，位图所需存储空间更小，位图方法更好。 2. 在一个交换系统中，按内存地址排列的空闲区大小是: 10KB、4KB、20KB、18KB、7KB、9KB、12KB和15KB。对于连续的段请求：12KB、10KB、9KB。使用FirstFit、BestFit、WorstFit和NextFit将找出哪些空闲区？ 段请求 FirstFit BestFit WorstFit NextFit 12KB 20KB 12KB 20KB 20KB 10KB 10KB 10KB 18KB 18KB 9KB 18KB 9KB 15KB 9KB 3. 解释逻辑地址、物理地址、地址映射，并举例说明。 逻辑地址（Logical Address）： 逻辑地址是程序运行时由 CPU 生成的地址，也称为虚拟地址。用户进程只能访问逻辑地址，不能直接访问物理内存。\n例如某程序访问地址 0x1234，但该地址只是进程的逻辑地址空间中的一部分。\n物理地址（Physical Address）：\n物理地址是实际存在于内存（RAM）中的地址，由操作系统和硬件管理。\n例子： 逻辑地址 0x1234 可能被映射到物理内存的 0xABCD1234。\n地址映射（Address Mapping）：\n地址映射是逻辑地址到物理地址的转换过程，通常由MMU通过分页、分段、段页结合等方式完成。 例子： 在分页系统中，逻辑地址 0x1234 可能属于页号2，页内偏移 0x034，MMU 通过页表找到物理页框5，映射后的物理地址为 0x5034。\n4. 解释页式（段式）存储管理中为什么要设置页（段）表和快表，简述页式（段式）地址转换过程。 为什么要设置页（段）表和快表\n页表（段表）：用于记录逻辑地址到物理地址的映射关系，存储完整的映射信息，保证进程可以正确访问物理内存。 快表：是一种高速缓存，用于存储最近访问的页（段）表项，加速地址转换，提高地址转换效率，减少访问内存的开销。 页式存储管理的地址转换过程\nCPU 生成逻辑地址，包含页号和页内偏移。 查询 TLB，如果页号在 TLB 中，则直接获取对应的物理页框号，得到物理地址。 若TLB 未命中（缺页表项），需要访问页表，通过页号查找对应的物理页框号。 组合物理页框号和页内偏移，形成物理地址，访问数据。 更新 TLB（如果 TLB 未命中，则将新查找的页表项加入 TLB）。 段式存储管理的地址转换过程\nCPU 生成逻辑地址，包含段号和段内偏移。 查询 TLB，如果段号在 TLB 中，则直接获取段的基址，计算物理地址。 若TLB 未命中，访问段表，查找段号对应的段基址和段界限。 检查越界，如果段内偏移\u003e段界限，发生段越界异常，否则继续计算。 物理地址 = 段基址 + 段内偏移，然后访问数据。 更新 TLB（如果 TLB 未命中，则将新的段表项加入 TLB）。 5. 叙述缺页中断的处理流程。 缺页中断发生在进程访问的页面不在内存时，系统需要从外存加载该页面到内存。处理流程如下：\n产生缺页中断\n进程访问某个逻辑地址，CPU 通过页表查找对应的物理页框。 如果该页表项无效（页不在内存），则触发缺页中断。 保存进程状态\nCPU 保存当前进程的上下文，包括程序计数器（PC）和寄存器等，确保中断后能恢复执行。 操作系统处理缺页\n查找页表：操作系统检查该页是否有效。 有效但不在内存 → 继续处理。 非法访问 → 触发异常（如段错误），终止进程。 选择物理页框： 若有空闲页框，直接使用。 若内存已满，使用页面置换算法（如 FIFO、LRU）淘汰一个旧页面。 读取页面到内存\n从外存（如磁盘）读取所需页面，拷贝到选定的物理页框。 更新页表和 TLB\n修改页表项，标记该页已在内存，并更新页框号。 若该页表项在 TLB（快表）中，需更新或清除 TLB 旧项，保证地址转换正确。 恢复进程执行\n恢复进程上下文，重新执行触发缺页的指令。 由于该页已加载到内存，不会再次触发缺页中断。 6. 假设一个机器有38位的虚拟地址和32位的物理地址。 (1) 与一级页表相比，多级页表的主要优点是什么？ 空间利用率高。多级页表只在需要时分配低层页表，从而避免为整个虚拟地址空间都预留大量连续的页表空间，节省内存空间。 (2) 如果使用二级页表，页面大小为16KB，每个页表项有4个字节。应该为虚拟地址中的第一级和第二级页表域各分配多少位？ 页面大小为 16KB，即\n$$16\\,\\text{KB} = 16 \\times 1024 = 2^{14}\\,\\text{字节}$$因此页内偏移需要 14 位，虚拟地址结构如下：\n$$\\underbrace{\\text{第一级页表域}}_{x\\,\\text{位}}\\,\\,\\underbrace{\\text{第二级页表域}}_{y\\,\\text{位}}\\,\\,\\underbrace{\\text{页内偏移}}_{14\\,\\text{位}}$$虚拟地址为38位，因此$x + y + 14 = 38位$，所以$x + y = 24,\\text{位}$。\n每个页表项为4B，页表页的大小与页面大小相同，即16KB。一个页表页能容纳的页表项个数为\n$$\\frac{16\\,\\text{KB}}{4\\,\\text{B}} = 4096 = 2^{12}\\,\\text{项}$$因此第二级页表的索引域需要12位，即$y=12$。\n由$x+y=24$可得$x=12$。即：\n$$\\underbrace{\\text{第一级页表域}}_{12\\,\\text{位}}\\,\\,\\underbrace{\\text{第二级页表域}}_{12\\,\\text{位}}\\,\\,\\underbrace{\\text{页内偏移}}_{14\\,\\text{位}}$$7. 假设页面的访问存在一定的周期性循环，但周期之间会随机出现一些页面的访问。例如：0,1,2…,511,431,0,1,2…511,332,0,1,2,…,511等。请思考： (1) LRU、FIFO和Clock算法的效果如何？ 如果物理页框数不足512个，三种算法会发生相同的几乎全部缺页问题。\n(2) 如果有500个页框，能否设计一个优于LRU、FIFO和Clock的算法？ 其中499个页框对应存储0-498页，第500个页框用于置换。\n8. 一个交换系统通过紧缩技术来清理碎片。如果内存碎片和数据区域是随机分配的。而且假设读写32位内存字需要10nsec. 那么如果紧缩128MB的内存需要多久？简单起见，假设第0个字是碎片的一部分而最高位的字包含了有效的数据。 $$128MB=\\frac{128\\times 2^{23}b}{32b/word} = 2^{25}words$$$$T=2^{25}words \\times (10ns/word + 10ns/word) = 6.711\\times 10^8ns = 0.6711s$$需要约$0.6711s$。\n","wordCount":"2740","inLanguage":"en","datePublished":"2025-03-28T19:00:00+08:00","dateModified":"2025-03-28T19:00:00+08:00","author":{"@type":"Person","name":"oNya"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://oNya685.github.io/posts/buaa/os/homework-2/"},"publisher":{"@type":"Organization","name":"oNya's Blog","logo":{"@type":"ImageObject","url":"https://oNya685.github.io/favicon.ico"}}}</script><script src=https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js></script><link rel=stylesheet href=https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css><script src=https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js></script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://oNya685.github.io/ accesskey=h title="主页 | oNya's Blog (Alt + H)"><img src=https://oNya685.github.io/ alt aria-label=logo height=30>主页 | oNya's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://oNya685.github.io/archives/ title=归档><span>归档</span></a></li><li><a href=https://oNya685.github.io/categories/ title=分类><span>分类</span></a></li><li><a href=https://oNya685.github.io/tags/ title=标签><span>标签</span></a></li><li><a href=https://oNya685.github.io/links/ title=链接><span>链接</span></a></li><li><a href=https://oNya685.github.io/search/ title=搜索><span>搜索</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://oNya685.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://oNya685.github.io/posts/>Posts</a>&nbsp;»&nbsp;<a href=https://oNya685.github.io/posts/buaa/>北京航空航天大学</a>&nbsp;»&nbsp;<a href=https://oNya685.github.io/posts/buaa/os/>操作系统</a></div><h1 class="post-title entry-hint-parent">[BUAA-OS] 理论作业 2</h1><div class=post-meta><span title='2025-03-28 19:00:00 +0800 CST'>2025年3月28日</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;2740 words&nbsp;·&nbsp;oNya</div></header><aside id=toc-container class="toc-container wide"><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#1-%e5%8a%a8%e6%80%81%e5%86%85%e5%ad%98%e5%88%86%e9%85%8d%e9%9c%80%e8%a6%81%e5%af%b9%e5%86%85%e5%ad%98%e5%88%86%e5%8c%ba%e8%bf%9b%e8%a1%8c%e7%ae%a1%e7%90%86%e4%b8%80%e8%88%ac%e4%bd%bf%e7%94%a8%e4%bd%8d%e5%9b%be%e5%92%8c%e7%a9%ba%e9%97%b2%e9%93%be%e8%a1%a8%e4%b8%a4%e7%a7%8d%e6%96%b9%e6%b3%95128mb%e7%9a%84%e5%86%85%e5%ad%98%e4%bb%a5n%e5%ad%97%e8%8a%82%e4%b8%ba%e5%8d%95%e5%85%83%e5%88%86%e9%85%8d%e5%af%b9%e4%ba%8e%e9%93%be%e8%a1%a8%e5%81%87%e8%ae%be%e5%86%85%e5%ad%98%e4%b8%ad%e6%95%b0%e6%8d%ae%e6%ae%b5%e5%92%8c%e7%a9%ba%e9%97%b2%e5%8c%ba%e4%ba%a4%e6%9b%bf%e6%8e%92%e5%88%97%e9%95%bf%e5%ba%a6%e5%9d%87%e4%b8%ba64kb%e5%b9%b6%e5%81%87%e8%ae%be%e9%93%be%e8%a1%a8%e4%b8%ad%e7%9a%84%e6%af%8f%e4%b8%aa%e8%8a%82%e7%82%b9%e9%9c%80%e8%a6%81%e8%ae%b0%e5%bd%9532%e4%bd%8d%e7%9a%84%e5%86%85%e5%ad%98%e5%9c%b0%e5%9d%80%e4%bf%a1%e6%81%af16%e4%bd%8d%e9%95%bf%e5%ba%a6%e4%bf%a1%e6%81%af%e5%92%8c16%e4%bd%8d%e4%b8%8b%e4%b8%80%e8%8a%82%e7%82%b9%e5%9f%9f%e4%bf%a1%e6%81%af%e8%bf%99%e4%b8%a4%e7%a7%8d%e6%96%b9%e6%b3%95%e5%88%86%e5%88%ab%e9%9c%80%e8%a6%81%e5%a4%9a%e5%b0%91%e5%ad%97%e8%8a%82%e7%9a%84%e5%ad%98%e5%82%a8%e7%a9%ba%e9%97%b4%e5%93%aa%e7%a7%8d%e6%96%b9%e6%b3%95%e6%9b%b4%e5%a5%bd aria-label="1. 动态内存分配需要对内存分区进行管理，一般使用位图和空闲链表两种方法。128MB的内存以n字节为单元分配，对于链表，假设内存中数据段和空闲区交替排列，长度均为64KB。并假设链表中的每个节点需要记录32位的内存地址信息、16位长度信息和16位下一节点域信息。这两种方法分别需要多少字节的存储空间？哪种方法更好？">1. 动态内存分配需要对内存分区进行管理，一般使用位图和空闲链表两种方法。128MB的内存以n字节为单元分配，对于链表，假设内存中数据段和空闲区交替排列，长度均为64KB。并假设链表中的每个节点需要记录32位的内存地址信息、16位长度信息和16位下一节点域信息。这两种方法分别需要多少字节的存储空间？哪种方法更好？</a></li><li><a href=#2-%e5%9c%a8%e4%b8%80%e4%b8%aa%e4%ba%a4%e6%8d%a2%e7%b3%bb%e7%bb%9f%e4%b8%ad%e6%8c%89%e5%86%85%e5%ad%98%e5%9c%b0%e5%9d%80%e6%8e%92%e5%88%97%e7%9a%84%e7%a9%ba%e9%97%b2%e5%8c%ba%e5%a4%a7%e5%b0%8f%e6%98%af-10kb4kb20kb18kb7kb9kb12kb%e5%92%8c15kb%e5%af%b9%e4%ba%8e%e8%bf%9e%e7%bb%ad%e7%9a%84%e6%ae%b5%e8%af%b7%e6%b1%8212kb10kb9kb%e4%bd%bf%e7%94%a8firstfitbestfitworstfit%e5%92%8cnextfit%e5%b0%86%e6%89%be%e5%87%ba%e5%93%aa%e4%ba%9b%e7%a9%ba%e9%97%b2%e5%8c%ba aria-label="2. 在一个交换系统中，按内存地址排列的空闲区大小是: 10KB、4KB、20KB、18KB、7KB、9KB、12KB和15KB。对于连续的段请求：12KB、10KB、9KB。使用FirstFit、BestFit、WorstFit和NextFit将找出哪些空闲区？">2. 在一个交换系统中，按内存地址排列的空闲区大小是: 10KB、4KB、20KB、18KB、7KB、9KB、12KB和15KB。对于连续的段请求：12KB、10KB、9KB。使用FirstFit、BestFit、WorstFit和NextFit将找出哪些空闲区？</a></li><li><a href=#3-%e8%a7%a3%e9%87%8a%e9%80%bb%e8%be%91%e5%9c%b0%e5%9d%80%e7%89%a9%e7%90%86%e5%9c%b0%e5%9d%80%e5%9c%b0%e5%9d%80%e6%98%a0%e5%b0%84%e5%b9%b6%e4%b8%be%e4%be%8b%e8%af%b4%e6%98%8e aria-label="3. 解释逻辑地址、物理地址、地址映射，并举例说明。">3. 解释逻辑地址、物理地址、地址映射，并举例说明。</a></li><li><a href=#4-%e8%a7%a3%e9%87%8a%e9%a1%b5%e5%bc%8f%e6%ae%b5%e5%bc%8f%e5%ad%98%e5%82%a8%e7%ae%a1%e7%90%86%e4%b8%ad%e4%b8%ba%e4%bb%80%e4%b9%88%e8%a6%81%e8%ae%be%e7%bd%ae%e9%a1%b5%e6%ae%b5%e8%a1%a8%e5%92%8c%e5%bf%ab%e8%a1%a8%e7%ae%80%e8%bf%b0%e9%a1%b5%e5%bc%8f%e6%ae%b5%e5%bc%8f%e5%9c%b0%e5%9d%80%e8%bd%ac%e6%8d%a2%e8%bf%87%e7%a8%8b aria-label="4. 解释页式（段式）存储管理中为什么要设置页（段）表和快表，简述页式（段式）地址转换过程。">4. 解释页式（段式）存储管理中为什么要设置页（段）表和快表，简述页式（段式）地址转换过程。</a></li><li><a href=#5-%e5%8f%99%e8%bf%b0%e7%bc%ba%e9%a1%b5%e4%b8%ad%e6%96%ad%e7%9a%84%e5%a4%84%e7%90%86%e6%b5%81%e7%a8%8b aria-label="5. 叙述缺页中断的处理流程。">5. 叙述缺页中断的处理流程。</a></li><li><a href=#6-%e5%81%87%e8%ae%be%e4%b8%80%e4%b8%aa%e6%9c%ba%e5%99%a8%e6%9c%8938%e4%bd%8d%e7%9a%84%e8%99%9a%e6%8b%9f%e5%9c%b0%e5%9d%80%e5%92%8c32%e4%bd%8d%e7%9a%84%e7%89%a9%e7%90%86%e5%9c%b0%e5%9d%80 aria-label="6. 假设一个机器有38位的虚拟地址和32位的物理地址。">6. 假设一个机器有38位的虚拟地址和32位的物理地址。</a><ul><li><a href=#1-%e4%b8%8e%e4%b8%80%e7%ba%a7%e9%a1%b5%e8%a1%a8%e7%9b%b8%e6%af%94%e5%a4%9a%e7%ba%a7%e9%a1%b5%e8%a1%a8%e7%9a%84%e4%b8%bb%e8%a6%81%e4%bc%98%e7%82%b9%e6%98%af%e4%bb%80%e4%b9%88 aria-label="(1) 与一级页表相比，多级页表的主要优点是什么？">(1) 与一级页表相比，多级页表的主要优点是什么？</a></li><li><a href=#2%e5%a6%82%e6%9e%9c%e4%bd%bf%e7%94%a8%e4%ba%8c%e7%ba%a7%e9%a1%b5%e8%a1%a8%e9%a1%b5%e9%9d%a2%e5%a4%a7%e5%b0%8f%e4%b8%ba16kb%e6%af%8f%e4%b8%aa%e9%a1%b5%e8%a1%a8%e9%a1%b9%e6%9c%894%e4%b8%aa%e5%ad%97%e8%8a%82%e5%ba%94%e8%af%a5%e4%b8%ba%e8%99%9a%e6%8b%9f%e5%9c%b0%e5%9d%80%e4%b8%ad%e7%9a%84%e7%ac%ac%e4%b8%80%e7%ba%a7%e5%92%8c%e7%ac%ac%e4%ba%8c%e7%ba%a7%e9%a1%b5%e8%a1%a8%e5%9f%9f%e5%90%84%e5%88%86%e9%85%8d%e5%a4%9a%e5%b0%91%e4%bd%8d aria-label=(2) 如果使用二级页表，页面大小为16KB，每个页表项有4个字节。应该为虚拟地址中的第一级和第二级页表域各分配多少位？>(2) 如果使用二级页表，页面大小为16KB，每个页表项有4个字节。应该为虚拟地址中的第一级和第二级页表域各分配多少位？</a></li></ul></li><li><a href=#7-%e5%81%87%e8%ae%be%e9%a1%b5%e9%9d%a2%e7%9a%84%e8%ae%bf%e9%97%ae%e5%ad%98%e5%9c%a8%e4%b8%80%e5%ae%9a%e7%9a%84%e5%91%a8%e6%9c%9f%e6%80%a7%e5%be%aa%e7%8e%af%e4%bd%86%e5%91%a8%e6%9c%9f%e4%b9%8b%e9%97%b4%e4%bc%9a%e9%9a%8f%e6%9c%ba%e5%87%ba%e7%8e%b0%e4%b8%80%e4%ba%9b%e9%a1%b5%e9%9d%a2%e7%9a%84%e8%ae%bf%e9%97%ae%e4%be%8b%e5%a6%82012511431012511332012511%e7%ad%89%e8%af%b7%e6%80%9d%e8%80%83 aria-label="7. 假设页面的访问存在一定的周期性循环，但周期之间会随机出现一些页面的访问。例如：0,1,2…,511,431,0,1,2…511,332,0,1,2,…,511等。请思考：">7. 假设页面的访问存在一定的周期性循环，但周期之间会随机出现一些页面的访问。例如：0,1,2…,511,431,0,1,2…511,332,0,1,2,…,511等。请思考：</a><ul><li><a href=#1lrufifo%e5%92%8cclock%e7%ae%97%e6%b3%95%e7%9a%84%e6%95%88%e6%9e%9c%e5%a6%82%e4%bd%95 aria-label=(1) LRU、FIFO和Clock算法的效果如何？>(1) LRU、FIFO和Clock算法的效果如何？</a></li><li><a href=#2%e5%a6%82%e6%9e%9c%e6%9c%89500%e4%b8%aa%e9%a1%b5%e6%a1%86%e8%83%bd%e5%90%a6%e8%ae%be%e8%ae%a1%e4%b8%80%e4%b8%aa%e4%bc%98%e4%ba%8elrufifo%e5%92%8cclock%e7%9a%84%e7%ae%97%e6%b3%95 aria-label=(2) 如果有500个页框，能否设计一个优于LRU、FIFO和Clock的算法？>(2) 如果有500个页框，能否设计一个优于LRU、FIFO和Clock的算法？</a></li></ul></li><li><a href=#8-%e4%b8%80%e4%b8%aa%e4%ba%a4%e6%8d%a2%e7%b3%bb%e7%bb%9f%e9%80%9a%e8%bf%87%e7%b4%a7%e7%bc%a9%e6%8a%80%e6%9c%af%e6%9d%a5%e6%b8%85%e7%90%86%e7%a2%8e%e7%89%87%e5%a6%82%e6%9e%9c%e5%86%85%e5%ad%98%e7%a2%8e%e7%89%87%e5%92%8c%e6%95%b0%e6%8d%ae%e5%8c%ba%e5%9f%9f%e6%98%af%e9%9a%8f%e6%9c%ba%e5%88%86%e9%85%8d%e7%9a%84%e8%80%8c%e4%b8%94%e5%81%87%e8%ae%be%e8%af%bb%e5%86%9932%e4%bd%8d%e5%86%85%e5%ad%98%e5%ad%97%e9%9c%80%e8%a6%8110nsec-%e9%82%a3%e4%b9%88%e5%a6%82%e6%9e%9c%e7%b4%a7%e7%bc%a9128mb%e7%9a%84%e5%86%85%e5%ad%98%e9%9c%80%e8%a6%81%e5%a4%9a%e4%b9%85%e7%ae%80%e5%8d%95%e8%b5%b7%e8%a7%81%e5%81%87%e8%ae%be%e7%ac%ac0%e4%b8%aa%e5%ad%97%e6%98%af%e7%a2%8e%e7%89%87%e7%9a%84%e4%b8%80%e9%83%a8%e5%88%86%e8%80%8c%e6%9c%80%e9%ab%98%e4%bd%8d%e7%9a%84%e5%ad%97%e5%8c%85%e5%90%ab%e4%ba%86%e6%9c%89%e6%95%88%e7%9a%84%e6%95%b0%e6%8d%ae aria-label="8. 一个交换系统通过紧缩技术来清理碎片。如果内存碎片和数据区域是随机分配的。而且假设读写32位内存字需要10nsec. 那么如果紧缩128MB的内存需要多久？简单起见，假设第0个字是碎片的一部分而最高位的字包含了有效的数据。">8. 一个交换系统通过紧缩技术来清理碎片。如果内存碎片和数据区域是随机分配的。而且假设读写32位内存字需要10nsec. 那么如果紧缩128MB的内存需要多久？简单起见，假设第0个字是碎片的一部分而最高位的字包含了有效的数据。</a></li></ul></div></details></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),activeElement=elements[0];const t=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{activeElement=Array.from(elements).find(e=>{if(getOffsetTop(e)-window.pageYOffset>0&&getOffsetTop(e)-window.pageYOffset<window.innerHeight/2)return e})||activeElement,elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase();e===activeElement?document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active"):document.querySelector(`.inner ul li a[href="#${t}"]`).classList.remove("active")})},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><p><strong><a href=%e4%bd%9c%e4%b8%9a2.pdf target=_blank>点此查看作业源文件</a></strong></p><h1 id=1-动态内存分配需要对内存分区进行管理一般使用位图和空闲链表两种方法128mb的内存以n字节为单元分配对于链表假设内存中数据段和空闲区交替排列长度均为64kb并假设链表中的每个节点需要记录32位的内存地址信息16位长度信息和16位下一节点域信息这两种方法分别需要多少字节的存储空间哪种方法更好>1. 动态内存分配需要对内存分区进行管理，一般使用位图和空闲链表两种方法。128MB的内存以n字节为单元分配，对于链表，假设内存中数据段和空闲区交替排列，长度均为64KB。并假设链表中的每个节点需要记录32位的内存地址信息、16位长度信息和16位下一节点域信息。这两种方法分别需要多少字节的存储空间？哪种方法更好？<a hidden class=anchor aria-hidden=true href=#1-动态内存分配需要对内存分区进行管理一般使用位图和空闲链表两种方法128mb的内存以n字节为单元分配对于链表假设内存中数据段和空闲区交替排列长度均为64kb并假设链表中的每个节点需要记录32位的内存地址信息16位长度信息和16位下一节点域信息这两种方法分别需要多少字节的存储空间哪种方法更好>#</a></h1><ul><li>若使用位图方法：</li></ul>$$单元数 = \frac{128MB}{nB} = \frac{2^{27}}{n}块$$$$所需存储空间 = \frac{2^{27}}{n}b = \frac{16}{n}MB$$<ul><li>若使用空闲链表方法：</li></ul>$$段数=\frac{128MB}{64KB+64KB} = 2^{10}段$$$$所需存储空间 = 2^{10} \times (32 + 16 + 16)b = 8KB$$<ul><li>哪种方法更好：<ul><li>当n&lt;2048时，空闲链表所需存储空间更小，空闲链表方法更好；</li><li>当n>2048时，位图所需存储空间更小，位图方法更好。</li></ul></li></ul><h1 id=2-在一个交换系统中按内存地址排列的空闲区大小是-10kb4kb20kb18kb7kb9kb12kb和15kb对于连续的段请求12kb10kb9kb使用firstfitbestfitworstfit和nextfit将找出哪些空闲区>2. 在一个交换系统中，按内存地址排列的空闲区大小是: 10KB、4KB、20KB、18KB、7KB、9KB、12KB和15KB。对于连续的段请求：12KB、10KB、9KB。使用FirstFit、BestFit、WorstFit和NextFit将找出哪些空闲区？<a hidden class=anchor aria-hidden=true href=#2-在一个交换系统中按内存地址排列的空闲区大小是-10kb4kb20kb18kb7kb9kb12kb和15kb对于连续的段请求12kb10kb9kb使用firstfitbestfitworstfit和nextfit将找出哪些空闲区>#</a></h1><table><thead><tr><th>段请求</th><th>FirstFit</th><th>BestFit</th><th>WorstFit</th><th>NextFit</th></tr></thead><tbody><tr><td><strong>12KB</strong></td><td>20KB</td><td>12KB</td><td>20KB</td><td>20KB</td></tr><tr><td><strong>10KB</strong></td><td>10KB</td><td>10KB</td><td>18KB</td><td>18KB</td></tr><tr><td><strong>9KB</strong></td><td>18KB</td><td>9KB</td><td>15KB</td><td>9KB</td></tr></tbody></table><h1 id=3-解释逻辑地址物理地址地址映射并举例说明>3. 解释逻辑地址、物理地址、地址映射，并举例说明。<a hidden class=anchor aria-hidden=true href=#3-解释逻辑地址物理地址地址映射并举例说明>#</a></h1><ol><li><p>逻辑地址（Logical Address）：
逻辑地址是程序运行时由 CPU 生成的地址，也称为虚拟地址。用户进程只能访问逻辑地址，不能直接访问物理内存。<br>例如某程序访问地址 <code>0x1234</code>，但该地址只是进程的逻辑地址空间中的一部分。</p></li><li><p>物理地址（Physical Address）：<br>物理地址是实际存在于内存（RAM）中的地址，由操作系统和硬件管理。<br>例子： 逻辑地址 <code>0x1234</code> 可能被映射到物理内存的 <code>0xABCD1234</code>。</p></li><li><p>地址映射（Address Mapping）：<br>地址映射是逻辑地址到物理地址的转换过程，通常由MMU通过分页、分段、段页结合等方式完成。
例子： 在分页系统中，逻辑地址 <code>0x1234</code> 可能属于页号2，页内偏移 <code>0x034</code>，MMU 通过页表找到物理页框5，映射后的物理地址为 <code>0x5034</code>。</p></li></ol><h1 id=4-解释页式段式存储管理中为什么要设置页段表和快表简述页式段式地址转换过程>4. 解释页式（段式）存储管理中为什么要设置页（段）表和快表，简述页式（段式）地址转换过程。<a hidden class=anchor aria-hidden=true href=#4-解释页式段式存储管理中为什么要设置页段表和快表简述页式段式地址转换过程>#</a></h1><ol><li><p>为什么要设置页（段）表和快表</p><ul><li>页表（段表）：用于记录逻辑地址到物理地址的映射关系，存储完整的映射信息，保证进程可以正确访问物理内存。</li><li>快表：是一种高速缓存，用于存储最近访问的页（段）表项，加速地址转换，提高地址转换效率，减少访问内存的开销。</li></ul></li><li><p>页式存储管理的地址转换过程</p><ol><li>CPU 生成逻辑地址，包含页号和页内偏移。</li><li>查询 TLB，如果页号在 TLB 中，则直接获取对应的物理页框号，得到物理地址。</li><li>若TLB 未命中（缺页表项），需要访问页表，通过页号查找对应的物理页框号。</li><li>组合物理页框号和页内偏移，形成物理地址，访问数据。</li><li>更新 TLB（如果 TLB 未命中，则将新查找的页表项加入 TLB）。</li></ol></li><li><p>段式存储管理的地址转换过程</p><ol><li>CPU 生成逻辑地址，包含段号和段内偏移。</li><li>查询 TLB，如果段号在 TLB 中，则直接获取段的基址，计算物理地址。</li><li>若TLB 未命中，访问段表，查找段号对应的段基址和段界限。</li><li>检查越界，如果段内偏移>段界限，发生段越界异常，否则继续计算。</li><li>物理地址 = 段基址 + 段内偏移，然后访问数据。</li><li>更新 TLB（如果 TLB 未命中，则将新的段表项加入 TLB）。</li></ol></li></ol><h1 id=5-叙述缺页中断的处理流程>5. 叙述缺页中断的处理流程。<a hidden class=anchor aria-hidden=true href=#5-叙述缺页中断的处理流程>#</a></h1><p>缺页中断发生在进程访问的页面不在内存时，系统需要从外存加载该页面到内存。处理流程如下：</p><ol><li><p>产生缺页中断</p><ul><li>进程访问某个逻辑地址，CPU 通过页表查找对应的物理页框。</li><li>如果该页表项无效（页不在内存），则触发缺页中断。</li></ul></li><li><p>保存进程状态</p><ul><li>CPU 保存当前进程的上下文，包括程序计数器（PC）和寄存器等，确保中断后能恢复执行。</li></ul></li><li><p>操作系统处理缺页</p><ul><li>查找页表：操作系统检查该页是否有效。<ul><li>有效但不在内存 → 继续处理。</li><li>非法访问 → 触发异常（如段错误），终止进程。</li></ul></li><li>选择物理页框：<ul><li>若有空闲页框，直接使用。</li><li>若内存已满，使用页面置换算法（如 FIFO、LRU）淘汰一个旧页面。</li></ul></li></ul></li><li><p>读取页面到内存</p><ul><li>从外存（如磁盘）读取所需页面，拷贝到选定的物理页框。</li></ul></li><li><p>更新页表和 TLB</p><ul><li>修改页表项，标记该页已在内存，并更新页框号。</li><li>若该页表项在 TLB（快表）中，需更新或清除 TLB 旧项，保证地址转换正确。</li></ul></li><li><p>恢复进程执行</p><ul><li>恢复进程上下文，重新执行触发缺页的指令。</li><li>由于该页已加载到内存，不会再次触发缺页中断。</li></ul></li></ol><h1 id=6-假设一个机器有38位的虚拟地址和32位的物理地址>6. 假设一个机器有38位的虚拟地址和32位的物理地址。<a hidden class=anchor aria-hidden=true href=#6-假设一个机器有38位的虚拟地址和32位的物理地址>#</a></h1><h2 id=1-与一级页表相比多级页表的主要优点是什么>(1) 与一级页表相比，多级页表的主要优点是什么？<a hidden class=anchor aria-hidden=true href=#1-与一级页表相比多级页表的主要优点是什么>#</a></h2><ul><li>空间利用率高。多级页表只在需要时分配低层页表，从而避免为整个虚拟地址空间都预留大量连续的页表空间，节省内存空间。</li></ul><h2 id=2如果使用二级页表页面大小为16kb每个页表项有4个字节应该为虚拟地址中的第一级和第二级页表域各分配多少位>(2) 如果使用二级页表，页面大小为16KB，每个页表项有4个字节。应该为虚拟地址中的第一级和第二级页表域各分配多少位？<a hidden class=anchor aria-hidden=true href=#2如果使用二级页表页面大小为16kb每个页表项有4个字节应该为虚拟地址中的第一级和第二级页表域各分配多少位>#</a></h2><p>页面大小为 16KB，即</p>$$16\,\text{KB} = 16 \times 1024 = 2^{14}\,\text{字节}$$<p>因此页内偏移需要 14 位，虚拟地址结构如下：</p>$$\underbrace{\text{第一级页表域}}_{x\,\text{位}}\,\,\underbrace{\text{第二级页表域}}_{y\,\text{位}}\,\,\underbrace{\text{页内偏移}}_{14\,\text{位}}$$<p>虚拟地址为38位，因此$x + y + 14 = 38位$，所以$x + y = 24,\text{位}$。</p><p>每个页表项为4B，页表页的大小与页面大小相同，即16KB。一个页表页能容纳的页表项个数为</p>$$\frac{16\,\text{KB}}{4\,\text{B}} = 4096 = 2^{12}\,\text{项}$$<p>因此第二级页表的索引域需要12位，即$y=12$。</p><p>由$x+y=24$可得$x=12$。即：</p>$$\underbrace{\text{第一级页表域}}_{12\,\text{位}}\,\,\underbrace{\text{第二级页表域}}_{12\,\text{位}}\,\,\underbrace{\text{页内偏移}}_{14\,\text{位}}$$<h1 id=7-假设页面的访问存在一定的周期性循环但周期之间会随机出现一些页面的访问例如012511431012511332012511等请思考>7. 假设页面的访问存在一定的周期性循环，但周期之间会随机出现一些页面的访问。例如：0,1,2…,511,431,0,1,2…511,332,0,1,2,…,511等。请思考：<a hidden class=anchor aria-hidden=true href=#7-假设页面的访问存在一定的周期性循环但周期之间会随机出现一些页面的访问例如012511431012511332012511等请思考>#</a></h1><h2 id=1lrufifo和clock算法的效果如何>(1) LRU、FIFO和Clock算法的效果如何？<a hidden class=anchor aria-hidden=true href=#1lrufifo和clock算法的效果如何>#</a></h2><p>如果物理页框数不足512个，三种算法会发生相同的几乎全部缺页问题。</p><h2 id=2如果有500个页框能否设计一个优于lrufifo和clock的算法>(2) 如果有500个页框，能否设计一个优于LRU、FIFO和Clock的算法？<a hidden class=anchor aria-hidden=true href=#2如果有500个页框能否设计一个优于lrufifo和clock的算法>#</a></h2><p>其中499个页框对应存储0-498页，第500个页框用于置换。</p><h1 id=8-一个交换系统通过紧缩技术来清理碎片如果内存碎片和数据区域是随机分配的而且假设读写32位内存字需要10nsec-那么如果紧缩128mb的内存需要多久简单起见假设第0个字是碎片的一部分而最高位的字包含了有效的数据>8. 一个交换系统通过紧缩技术来清理碎片。如果内存碎片和数据区域是随机分配的。而且假设读写32位内存字需要10nsec. 那么如果紧缩128MB的内存需要多久？简单起见，假设第0个字是碎片的一部分而最高位的字包含了有效的数据。<a hidden class=anchor aria-hidden=true href=#8-一个交换系统通过紧缩技术来清理碎片如果内存碎片和数据区域是随机分配的而且假设读写32位内存字需要10nsec-那么如果紧缩128mb的内存需要多久简单起见假设第0个字是碎片的一部分而最高位的字包含了有效的数据>#</a></h1>$$128MB=\frac{128\times 2^{23}b}{32b/word} = 2^{25}words$$$$T=2^{25}words \times (10ns/word + 10ns/word) = 6.711\times 10^8ns = 0.6711s$$<p>需要约$0.6711s$。</p></div><footer class=post-footer><ul class=post-tags></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://oNya685.github.io/>oNya's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script><script>(function(e,t){var s=document,o="script",n=s.createElement(o),i=s.getElementsByTagName(o)[0];n.src=e,t&&n.addEventListener("load",function(e){t(e)}),i.parentNode.insertBefore(n,i)})("//cdn.jsdelivr.net/npm/pangu@4.0.7/dist/browser/pangu.min.js",function(){pangu.spacingPage()})</script></body></html>