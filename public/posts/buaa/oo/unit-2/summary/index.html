<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>[BUAA-OO] Unit 2 总结 | oNya's Blog</title>
<meta name=keywords content><meta name=description content="第二单元博客作业"><meta name=author content="oNya"><link rel=canonical href=%7b%7b%20.Permalink%20%7d%7d><link crossorigin=anonymous href=/assets/css/stylesheet.79e07885fe54214be03f273758b2bda9bbf1210d3eba9e9b5be2955ca8fdb800.css integrity="sha256-eeB4hf5UIUvgPyc3WLK9qbvxIQ0+up6bW+KVXKj9uAA=" rel="preload stylesheet" as=style><link rel=icon href=https://oNya685.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://oNya685.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://oNya685.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://oNya685.github.io/apple-touch-icon.png><link rel=mask-icon href=https://oNya685.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://oNya685.github.io/posts/buaa/oo/unit-2/summary/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=Ubuntu+Mono:ital,wght@0,400;0,700;1,400;1,700&family=Ubuntu:ital,wght@0,300;0,400;0,500;0,700;1,300;1,400;1,500;1,700&display=swap" rel=stylesheet><link rel=preconnect href=https://static.zeoseven.com crossorigin><link rel=stylesheet href=https://static.zeoseven.com/zsft/372/main/result.css onerror='this.href="https://static-host.zeoseven.com/zsft/372/main/result.css"'><link rel=stylesheet href=https://static.zeoseven.com/zsft/25/main/result.css onerror='this.href="https://static-host.zeoseven.com/zsft/25/main/result.css"'><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.css integrity=sha384-MlJdn/WNKDGXveldHDdyRP1R4CTHr3FeuDNfhsLPYrq2t0UBkUdK2jyTnXPEK1NQ crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.js integrity=sha384-VQ8d8WVFw0yHhCk5E8I86oOhv48xLpnDZx5T9GogA/Y84DcCKWXDmSDfn13bzFZY crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/contrib/auto-render.min.js integrity=sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR crossorigin=anonymous onload=renderMathInElement(document.body)></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}]})})</script><meta property="og:url" content="https://oNya685.github.io/posts/buaa/oo/unit-2/summary/"><meta property="og:site_name" content="oNya's Blog"><meta property="og:title" content="[BUAA-OO] Unit 2 总结"><meta property="og:description" content="第二单元博客作业"><meta property="og:locale" content="zh-cn"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-04-18T10:43:00+00:00"><meta property="article:modified_time" content="2025-04-18T10:43:00+00:00"><meta property="og:image" content="https://oNya685.github.io/cover.jpg"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://oNya685.github.io/cover.jpg"><meta name=twitter:title content="[BUAA-OO] Unit 2 总结"><meta name=twitter:description content="第二单元博客作业"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://oNya685.github.io/posts/"},{"@type":"ListItem","position":2,"name":"北京航空航天大学","item":"https://oNya685.github.io/posts/buaa/"},{"@type":"ListItem","position":3,"name":"[BUAA-OO] Unit 2 总结","item":"https://oNya685.github.io/posts/buaa/oo/unit-2/summary/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"[BUAA-OO] Unit 2 总结","name":"[BUAA-OO] Unit 2 总结","description":"第二单元博客作业","keywords":[],"articleBody":" 几千字的流水账真的会有人从头看到尾吗（？\n不按作业的要求顺序来了，有意思的放最前，重要的放其次，其余的往后排。\n我们真的需要一台电梯么？ 首先，回顾一下作业要求：我们要模拟六台电梯的运行、调度，和其开关门、移动、对乘客的接、送行为，其中大部分行为需要等待一定的现实时间。而评测要求我们在每一状态转移完成时输出一条信息，以供测评评测机中模拟的电梯状态机是否在符合正确性规范的前提下完成功能，并评测性能。\n为什么是状态机 Everything is a state machine.\n经常上OS的同学都知道，状态机是一种表示可数个（我想表达的意思是，可以依据规律枚举、列举出，即使有无限种）状态以及在这些状态之间的转移和动作等行为的数学模型。\n我们看该单元的电梯系统的架构设计：绝大部分同学（不如说难道还有用其他架构的吗）采取的是这样一种“三段式架构”：\n$$输入线程 \\rightarrow 请求队列 \\rightarrow 分配器线程 \\rightarrow 等待队列 \\rightarrow 电梯线程$$当然，根据大家设计的不同，可能还有其他的共享对象或者其他的箭头关系（主要取决于应对电梯踢人OUT-F和接受临时调度、Update等奇葩请求的设计）。\n而电梯是如何决策其状态转移的呢？电梯有如下状态等：当前楼层，是否开门，等待（下称pending）队列，电梯内乘客队列（下称current）。在第一次作业我们就实现了这样一个状态机：采用ALS, LOOK, 或者其他的什么算法。我采用的是出于优先级考虑的，在高覆盖率的同时降低加权平均等待时间的改进的LOOK算法。\nexecutions的引入 那么，这一状态机的输入是什么？\n回顾我们的架构设计，理所当然的，我们会说：输入当然是分配器分配给该电梯的等待队列，吗？\n事实上，其决策并不依赖输入，换言之，并不是只有有新的请求时电梯才会动的。即使没有请求，电梯也会把自己唤醒，逐步更新自己的状态，直到回归pending和current都变为空的状态。\n也就是说，在任一时刻，若假定该状态机不再会有新的输入（不再分配新的请求），那我们就能推演出该状态机的后续所有行为。 所以，在后文中，我们暂且规定，称“状态机”为这种没有输入的，自动决策状态转移的状态机。 有没有很像上学期计组做的那个CPU，把机器码记录在文件中加载出来，就能自动执行状态转移？如果把CPU和记录机器码的存储设备框在一起，而不认为机器码是一种输入。把机器码比作pending和current中的数据，和这一单元的电梯是不是很像？\n那我们还该如何定义“分配新请求”这种行为呢？很简单，每次分配了新请求，或者告诉电梯要进行SCHE或UPDATE时，我们可以重新计算一遍该电梯从当前状态作所有决策，直到回归空闲状态这一区间中，所有的状态转移，并将其更新给电梯线程，电梯线程依次执行即可。\n这里，我们引入一个队列 LinkedList executions。用以存储当前电梯所有的状态转移行为，依次执行完就可以抵达名为空闲的终点。\nInterface Executeable，要求实现方法execute(Elevator elevator); 执行时实现状态转移，更新电梯的当前状态\n解构一台电梯 我们实现了对电梯这一对象的逐步解构：现在你还可以坚持称电梯线程在模拟一台电梯，实际上它在做的事情只有：计算executions，execute执行，或者当时间条件不满足时await()。\n下述是对该电梯完全解构的最后一步：把计算executions的工作交给分配器\n为什么要这么做？这么做有什么好处？我们考虑分配器的如下分配策略：\n分配器现在需要分配某乘客请求给六台电梯中的任一台，如果可以的话，它希望知道分配给具体哪一台电梯能获得最优性能。（当然，不可以的话，随机挑一台塞进去也不是不能跑） 既然对分配器想要分配的这一时刻来说，每一台电梯的接下来的所有行为都是已知的，那么每一台电梯接下来的行为可以用以计算其成本。 那么，分配器想知道分配给哪一台电梯能让总成本最低，就会依次尝试把乘客请求分配给其中某一台电梯的情况，并希望知道其总成本：这样，选出总成本最低的一种情况，不就是局部的、已知的最优策略了么。相当于在若干条时间线，选了最完美的一条。 但是，怎么知道每一台电梯接下来的行为，甚至是，每一台电梯在接受了当前乘客请求的这一IF线下，接下来的行为呢？我们刚才已经讨论过了，既然是状态机，那么必然是可以计算的。 把电梯线程叫醒帮自己计算看上去不太现实（事实上也不太现实），那就自己计算吧，把六个状态机的状态拷贝一份，再创造六个接受了当前乘客分配的IF线状态机，选出最好的一条IF线，并拿这个IF线状态机替换掉真正的状态机，狸猫换太子，就实现了最优分配策略。 那，算都算完了，电梯线程偷个懒不算了，拿着分配器算好的executions，到时间就执行并且输出就好了。 影子电梯：但是只有影子电梯 至此，这一臃肿的、模拟真实电梯运行的线程的工作，只剩下：维护一个状态已知、接下来所有状态转移已知的状态机，到了时间就给状态机执行一步状态转移并输出，没到时间就回去等着。\n那么，电梯还存在吗？或许游离于分配器的心中，或许藏匿于状态机的状态里，又或许闪烁在评测机的眼中，反正不可能说它存在于电梯线程的模拟中了，这么说电梯线程也不能答应的，它只是拿着一串executions，到时间就输出出来而已，连execute都是封装好的。所以我称这样的“电梯线程”为Class Printer extends Thread，它就是一台到时间就自动打印的打印机而已。\n按道理来说，贴代码是没人有心思看的，自己的代码自己迭代时都懒得读，但是这是这个线程所剩下的全部内容了，还是读一下吧？ 为可读性优化和简化了部分，所以算伪代码。\npublic void run() { long lastTime = System.currentTimeMillis(); lock.lock(); // 为方便读，这里省掉了await的try-catch包装块。 while (true) { ExecuteAble execution = null; // 瞬间的行为，循环依次完成。 while (!executions.isEmpty()) { execution = executions.getFirst(); if (needTimeToExecute(execution)) { break; } lastTime = executeAndUpdate(execution, lastTime); } // 空闲状态，尝试结束或等待新任务的分配。 if (executions.isEmpty()) { if (end) { break; } MainProcess.signalDispatcher(); printable.await(); continue; } // 非瞬间行为，判断是否满足执行条件，失败则等待。 long timeToWait = lastTime + needTimeMap.get(execution) - System.currentTimeMillis(); if (timeToWait \u003c= 0) { lastTime = executeAndUpdate(execution, lastTime); } else { printable.await(timeToWait, TimeUnit.MILLISECONDS); } } lock.unlock(); } 于是，我们实现了所谓影子电梯，证明了影子电梯的可行性，但是全部都是影子电梯。与其说分配器是通过影子电梯计算出分配给具体哪一台真正的电梯，不如说分配器是拿一台更新后的影子电梯换掉了原来的影子电梯。\n既然影子电梯可行，如何适应性能指标？ 现在谈谈该调度策略是如何权衡总时间、加权平均时间和电量的：\n首先，我们要尽量降低总时间$T_{run}$：这一性能指标显然比另外两个重要的多，如果为追求低功耗而$T_{run}$过大，我们甚至会被判断为效率太低而超时，而平均分配、随机分配等方法，也都是在放弃对于加权平均时间和功耗的考量下，追求$T_{run}$的解法。 但是，$T_{run}$有两个特性：\n一是对于所有电梯来说，只有最大的$T_{run}$是有意义的，当其中一台电梯的总时间很长，而给其他某台电梯分配了请求后总时间依然不比最长的总时间长，那么$T_{run}$是没有变化的，此时追求降低$T_{run}$是一种没太大意义的行为。 二是对于当前$T_{run}$最大的电梯来说，捎带请求是一种以牺牲少量$T_{run}$换取极大加权平均时间和功耗上收益的决策。代价是你需要花额外0.4s的$T_{run}$在这一层停下并开关门，性能上却相当划算。 因此，在六台电梯分别接受分配请求的时间线中，我选出所有接受分配请求后，$\\Delta T_{run} \\leq 1s$的时间线并纳入考虑，如果没有符合条件的，则选出$T_{run}$增加值最小的一种情况直接作为分配结果。\n接下来我们就可以不考虑$T_{run}$对性能的影响了，即使还有影响，也不到1s，可以大致忽略。我们要考虑，经过筛选后的若干种情况里，加权平均时间$wT$和功耗$W$综合最优的一种情况。但由于性能分是与同学们排名后计算的，我并不知道怎样取得综合最优，理论上我们需要满足：\n$$\\begin{align*} \\Delta \\text{cost} \u0026= a \\Delta wT + b \\Delta W, \\quad a + b = 1 \\\\ \\begin{pmatrix} a \u0026 b \\end{pmatrix} \u0026= \\arg\\min \\Delta \\text{cost} \\end{align*}$$我取$\\begin{pmatrix} a \u0026 b \\end{pmatrix} = \\begin{pmatrix} \\frac{10}{10+1} \u0026 \\frac{1}{10+1} \\end{pmatrix}$，最后效果尚可。\n双轿厢：线程协作是否应该影响对象行为？ 我们已经论述过了，时间是线程（具体来讲，是Printer这一打印机线程）要考虑的，线程是动态的、连续的，共享对象只有状态，是静态的、瞬间的。\n所以双轿厢电梯的行为，是共享对象所考虑的，同步开始改造和避免相撞却是线程所需保证的。\n具体来讲，我们采取的策略是到达临界楼层后，通过锁等方式让协作线程若有需求先等待自己完成任务，自己完成后尽快退出临界楼层（当然该行为也是共享对象所存储的，而非线程唤起的），放还锁让协作线程继续动态行为。\n而在同步改造方面：\n当两电梯的下一execution均为UPDATE-BEGIN时，由分配器输出UPDATE-BEGIN并唤醒两打印机线程进入计时。两线程共享一把锁。 其中一台电梯UPDATE-BEGIN时锁上共享锁，UPDATE-END时先输出UPDATE-END，然后放还共享锁。 另一台电梯不输出，UPDATE-BEGIN时无行为，但UPDATE-END时先尝试拿到共享锁，拿到后立即放还，然后才执行自己的后续操作。 这样，我们就实现了两协作线程的同步。 在这一过程中，线程间的交互不对对象状态产生影响，只对状态转移的时间，即线程行为有所限制。故而，线程协作不影响对象行为。\n接下来补充比较重要的内容。\n架构设计 很明显能看出三段的设计：$线程-共享对象-线程-共享对象-线程$。\n前文已介绍过该架构的工作流程，在第一次作业中，我采用与大家相同的架构，而在第二次作业的重构中，我将电梯线程的功能解构提取，变成了如上的只保留简单功能的PrinterThread。第三次作业中，无新增类。\n值得介绍的是Scheduler类，其包装了该状态机的决策行为，也即其所有的状态转移计算过程。通过封装Scheduler，我们实现了电梯决策器的可拓展性：当我们需要更换、优化电梯算法，只需要换一个Scheduler或者继承原Scheduler即可。\n这里给出一种性能优化思路，配备多种Scheduler，考虑每种电梯装载不同Scheduler，采取不同算法的时间线，并综合总的性能考量，返回给各状态机最优的executions。但该方法的计算量预估提升了一个数量级，为避免CTLE，应谨慎考虑。\n线程协作 上图已明了介绍线程中的协作关系，此处详细解释最后的线程结束的判定：\n首先，输入线程的结束条件很清晰：读取到值为null的请求时。 但对于Request Queue来说，输入线程与六个电梯线程同时作为生产者，分配器作为消费者；同时，对于每个电梯状态机，分配器是生产者，电梯线程是消费者。 这就形成了一个圈：分配器与电梯互为消费者和生产者，而生产者没有结束时，消费者自然不可以结束。 因此，我们重新定义电梯线程作为生产者的结束：当其executions为空，即空闲状态下，它自然不可能再放归新的请求，我们可以认为其处于临时的结束状态。 而对于此时的调度器，倘若没有需要分配的请求，其会尝试结束： 输入线程已结束 各电梯线程处于空闲状态 也即对于RequestQueue，不会有新的生产，也因此没有消费行为和消费行为导致的新的生产。 此时调度器可以认为达到结束条件，结束自身线程并对后续所有线程设置结束。 有趣的和重要的均已结束，现在补充作业要求的其他内容。\n易变的内容 稳定的内容已于上文完成分析，而易变的内容，我们需着眼分析两个“例外”：SCHE和UPDATE。\n对于SCHE，我选择将ScheBegin和ScheEnd纳入Executeable范畴，将其视为状态机的正常状态转移行为，从而使其回归稳定的内容的体系； 对于UPDATE大体相同，但UPDATE-BEGIN实在太特殊，为了两电梯之间的同步，我将其设置为电梯的一种新的状态并因此补充了大量特判，这也是引发我bug的直接原因：补丁没打全。 Bug分析与Debug方法 第一二次作业无bug，对第三次作业的UPDATE-BEGIN处理引发了第三次作业的bug，并直接导致了强测爆炸：\n对于UPDATE-ACCEPT前分配给电梯的请求，经过改造后并不一定能接受，因为其所在楼层不一定属于自己所能移动的范围内。而为了避免UPDATE和SCHE之间无法RECEIVE请求导致分配器轮询，我为每个电梯配置RECEIVE请求缓存区，囤积在END后再输出，因此错过了UPDATE-BEGIN时清空当前已RECEIVE请求的机会，从而可能RECEIVE改造后无法处理的请求。\n改正方法为：UPDATE开始时清除RECEIVE缓存区中自己改造后无法处理的请求。\nDebug方法为输出。当debug模式启用时，输出各关键行为前后的线程状态、状态机状态。\n// MainProcess.java public static boolean debug() { return false; } 虽然本次作业没有要求课程建议，但是实在很想建议：\n能不能给一个TimableOutput.debug(String string)然后输出内容不计入评测，只供debug时便于人类查看，间接解决掉评测出的bug在本地无法复现的问题？这样只要写好关键步骤的日志，就能快速定位到bug，即使本地无法复现也可以正常修复？\n线程安全与层次化设计 锁的合理使用 在本次作业中，线程安全是至关重要的。尤其是在处理多线程的电梯调度和状态更新时，锁的使用非常关键。例如，在电梯线程和分配器线程之间共享的状态机状态（如电梯的当前楼层、电梯内乘客队列等）必须通过锁来保证线程安全。 我们使用了ReentrantLock来确保在更新状态时不会出现竞态条件。例如，在电梯线程执行状态转移时，需要对executions队列进行操作，此时必须加锁，防止分配器线程同时修改该队列。同时，锁的使用也需要谨慎，避免死锁的发生。在电梯线程和分配器线程之间，我们通过合理的锁顺序和锁的释放时机来避免死锁。 使用ReentrantLock有什么好处？条件管理更灵活，而且锁可以脱离对象或代码块而存在，请看使用了ReentrantLock的影子电梯的名场面六把锁： elevators.forEach(Elevator::lock); // 计算与分配 elevators.forEach(Elevator::unlock); 线程间通信的同步机制 线程间通信的安全性也是线程安全的重要方面。在本次作业中，电梯线程和分配器线程之间通过executions队列进行通信，而这个队列的更新和读取必须是线程安全的。 我们使用了Condition来实现线程间的同步。例如，当电梯线程处于空闲状态时，它会调用await()等待分配器线程的信号。分配器线程在计算出新的executions后，会调用signal()唤醒电梯线程。这种同步机制确保了线程间通信的正确性和及时性。 同时，在处理双轿厢电梯的同步（改造期间）与互斥（临界楼层）时，我们通过共享一把ReentrantLock来实现两台电梯线程之间的同步。这种同步机制不仅保证了线程安全，还避免了电梯之间的冲突。 架构设计的层次化 层次化设计使得代码更加清晰和易于维护。在本次作业中，我们将整个电梯系统划分为多个功能模块，每个模块负责特定的功能。 例如，输入线程负责读取请求并将其放入请求队列；分配器线程负责从请求队列中取出请求并分配给电梯；电梯线程负责执行电梯的状态转移。这种模块划分使得每个线程的功能单一，便于理解和维护。 同时，我们还引入了Scheduler类来封装电梯的状态转移计算逻辑。这样，当需要更换或优化电梯算法时，只需要修改Scheduler类，而不需要修改电梯线程的代码。这种层次化设计提高了代码的可扩展性和可维护性。 ","wordCount":"6223","inLanguage":"en","image":"https://oNya685.github.io/cover.jpg","datePublished":"2025-04-18T10:43:00Z","dateModified":"2025-04-18T10:43:00Z","author":{"@type":"Person","name":"oNya"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://oNya685.github.io/posts/buaa/oo/unit-2/summary/"},"publisher":{"@type":"Organization","name":"oNya's Blog","logo":{"@type":"ImageObject","url":"https://oNya685.github.io/favicon.ico"}}}</script><script src=https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js></script><link rel=stylesheet href=https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css><script src=https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js></script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://oNya685.github.io/ accesskey=h title="主页 | oNya's Blog (Alt + H)"><img src=https://oNya685.github.io/ alt aria-label=logo height=30>主页 | oNya's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://oNya685.github.io/archives/ title=归档><span>归档</span></a></li><li><a href=https://oNya685.github.io/categories/ title=分类><span>分类</span></a></li><li><a href=https://oNya685.github.io/tags/ title=标签><span>标签</span></a></li><li><a href=https://oNya685.github.io/links/ title=链接><span>链接</span></a></li><li><a href=https://oNya685.github.io/search/ title=搜索><span>搜索</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://oNya685.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://oNya685.github.io/posts/>Posts</a>&nbsp;»&nbsp;<a href=https://oNya685.github.io/posts/buaa/>北京航空航天大学</a></div><h1 class="post-title entry-hint-parent">[BUAA-OO] Unit 2 总结</h1><div class=post-description>第二单元博客作业</div><div class=post-meta><span title='2025-04-18 10:43:00 +0000 UTC'>2025年4月18日</span>&nbsp;·&nbsp;13 min&nbsp;·&nbsp;6223 words&nbsp;·&nbsp;oNya</div></header><figure class=entry-cover><img loading=eager srcset='https://oNya685.github.io/posts/buaa/oo/unit-2/summary/cover.jpg 332w' src=https://oNya685.github.io/posts/buaa/oo/unit-2/summary/cover.jpg sizes="(min-width: 768px) 720px, 100vw" width=332 height=184 alt></figure><aside id=toc-container class="toc-container wide"><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%e6%88%91%e4%bb%ac%e7%9c%9f%e7%9a%84%e9%9c%80%e8%a6%81%e4%b8%80%e5%8f%b0%e7%94%b5%e6%a2%af%e4%b9%88 aria-label=我们真的需要一台电梯么？>我们真的需要一台电梯么？</a><ul><li><a href=#%e4%b8%ba%e4%bb%80%e4%b9%88%e6%98%af%e7%8a%b6%e6%80%81%e6%9c%ba aria-label=为什么是状态机>为什么是状态机</a></li><li><a href=#executions%e7%9a%84%e5%bc%95%e5%85%a5 aria-label=executions的引入>executions的引入</a></li><li><a href=#%e8%a7%a3%e6%9e%84%e4%b8%80%e5%8f%b0%e7%94%b5%e6%a2%af aria-label=解构一台电梯>解构一台电梯</a></li><li><a href=#%e5%bd%b1%e5%ad%90%e7%94%b5%e6%a2%af%e4%bd%86%e6%98%af%e5%8f%aa%e6%9c%89%e5%bd%b1%e5%ad%90%e7%94%b5%e6%a2%af aria-label=影子电梯：但是只有影子电梯>影子电梯：但是只有影子电梯</a></li></ul></li><li><a href=#%e6%97%a2%e7%84%b6%e5%bd%b1%e5%ad%90%e7%94%b5%e6%a2%af%e5%8f%af%e8%a1%8c%e5%a6%82%e4%bd%95%e9%80%82%e5%ba%94%e6%80%a7%e8%83%bd%e6%8c%87%e6%a0%87 aria-label=既然影子电梯可行，如何适应性能指标？>既然影子电梯可行，如何适应性能指标？</a></li><li><a href=#%e5%8f%8c%e8%bd%bf%e5%8e%a2%e7%ba%bf%e7%a8%8b%e5%8d%8f%e4%bd%9c%e6%98%af%e5%90%a6%e5%ba%94%e8%af%a5%e5%bd%b1%e5%93%8d%e5%af%b9%e8%b1%a1%e8%a1%8c%e4%b8%ba aria-label=双轿厢：线程协作是否应该影响对象行为？>双轿厢：线程协作是否应该影响对象行为？</a></li><li><a href=#%e6%9e%b6%e6%9e%84%e8%ae%be%e8%ae%a1 aria-label=架构设计>架构设计</a></li><li><a href=#%e7%ba%bf%e7%a8%8b%e5%8d%8f%e4%bd%9c aria-label=线程协作>线程协作</a></li><li><a href=#%e6%98%93%e5%8f%98%e7%9a%84%e5%86%85%e5%ae%b9 aria-label=易变的内容>易变的内容</a></li><li><a href=#bug%e5%88%86%e6%9e%90%e4%b8%8edebug%e6%96%b9%e6%b3%95 aria-label=Bug分析与Debug方法>Bug分析与Debug方法</a></li><li><a href=#%e7%ba%bf%e7%a8%8b%e5%ae%89%e5%85%a8%e4%b8%8e%e5%b1%82%e6%ac%a1%e5%8c%96%e8%ae%be%e8%ae%a1 aria-label=线程安全与层次化设计>线程安全与层次化设计</a></li></ul></div></details></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),activeElement=elements[0];const t=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{activeElement=Array.from(elements).find(e=>{if(getOffsetTop(e)-window.pageYOffset>0&&getOffsetTop(e)-window.pageYOffset<window.innerHeight/2)return e})||activeElement,elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase();e===activeElement?document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active"):document.querySelector(`.inner ul li a[href="#${t}"]`).classList.remove("active")})},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><blockquote><p>几千字的流水账真的会有人从头看到尾吗（？</p><p>不按作业的要求顺序来了，有意思的放最前，重要的放其次，其余的往后排。</p></blockquote><h1 id=我们真的需要一台电梯么>我们真的需要一台电梯么？<a hidden class=anchor aria-hidden=true href=#我们真的需要一台电梯么>#</a></h1><p>首先，回顾一下作业要求：我们要<strong>模拟</strong>六台电梯的运行、调度，和其开关门、移动、对乘客的接、送行为，其中大部分行为需要等待一定的<strong>现实时间</strong>。而评测要求我们在每一<strong>状态转移完成</strong>时输出一条信息，以供测评<strong>评测机中模拟的电梯状态机</strong>是否在<strong>符合正确性规范</strong>的前提下<strong>完成功能</strong>，并<strong>评测性能</strong>。</p><h2 id=为什么是状态机>为什么是状态机<a hidden class=anchor aria-hidden=true href=#为什么是状态机>#</a></h2><blockquote><p><strong>Everything is a state machine.</strong></p></blockquote><p>经常上OS的同学都知道，状态机是一种表示可数个（我想表达的意思是，可以依据规律枚举、列举出，即使有无限种）状态以及在这些状态之间的转移和动作等行为的数学模型。</p><p>我们看该单元的电梯系统的架构设计：绝大部分同学（不如说难道还有用其他架构的吗）采取的是这样一种“<strong>三段式架构</strong>”：</p>$$输入线程 \rightarrow 请求队列 \rightarrow 分配器线程 \rightarrow 等待队列 \rightarrow 电梯线程$$<p>当然，根据大家设计的不同，可能还有其他的共享对象或者其他的箭头关系（主要取决于应对电梯踢人<code>OUT-F</code>和接受临时调度、Update等奇葩请求的设计）。</p><p>而电梯是如何决策其状态转移的呢？电梯有如下状态等：当前楼层，是否开门，等待（下称pending）队列，电梯内乘客队列（下称current）。在第一次作业我们就实现了这样一个状态机：采用ALS, LOOK, 或者其他的什么算法。我采用的是出于优先级考虑的，在<strong>高覆盖率</strong>的同时<strong>降低加权平均等待时间</strong>的改进的LOOK算法。</p><h2 id=executions的引入><code>executions</code>的引入<a hidden class=anchor aria-hidden=true href=#executions的引入>#</a></h2><p>那么，这一状态机的<strong>输入</strong>是什么？</p><p>回顾我们的架构设计，理所当然的，我们会说：输入当然是分配器分配给该电梯的等待队列，吗？</p><p>事实上，其决策并<strong>不依赖输入</strong>，换言之，并不是只有有新的请求时电梯才会动的。即使没有请求，电梯也会把自己唤醒，逐步更新自己的状态，直到回归pending和current都变为空的状态。</p><p>也就是说，<strong>在任一时刻，若假定该状态机不再会有新的输入（不再分配新的请求），那我们就能推演出该状态机的后续所有行为。</strong>
所以，在后文中，我们暂且规定，称“状态机”为这种没有输入的，自动决策状态转移的状态机。
有没有很像上学期计组做的那个CPU，把机器码记录在文件中加载出来，就能自动执行状态转移？如果把CPU和记录机器码的存储设备框在一起，而不认为机器码是一种输入。把机器码比作pending和current中的数据，和这一单元的电梯是不是很像？</p><p>那我们还该如何定义“分配新请求”这种行为呢？很简单，每次分配了新请求，或者告诉电梯要进行SCHE或UPDATE时，我们可以重新计算一遍该电梯从当前状态作所有决策，直到回归空闲状态这一区间中，<strong>所有的状态转移</strong>，并将其更新给电梯线程，电梯线程依次执行即可。</p><p>这里，我们引入一个队列 <code>LinkedList&lt;Executeable> executions</code>。用以存储当前电梯所有的状态转移行为，依次执行完就可以抵达名为空闲的终点。</p><blockquote><p>Interface Executeable，要求实现方法execute(Elevator elevator); 执行时实现状态转移，更新电梯的当前状态</p></blockquote><h2 id=解构一台电梯>解构一台电梯<a hidden class=anchor aria-hidden=true href=#解构一台电梯>#</a></h2><p>我们实现了对电梯这一对象的逐步<strong>解构</strong>：现在你还可以坚持称电梯线程在<strong>模拟一台电梯</strong>，实际上它在做的事情只有：<strong>计算executions，execute执行，或者当时间条件不满足时await()</strong>。</p><p>下述是对该电梯完全解构的最后一步：把计算executions的工作交给分配器</p><p>为什么要这么做？这么做有什么好处？我们考虑分配器的如下分配策略：</p><ul><li>分配器现在需要<strong>分配某乘客请求</strong>给六台电梯中的任一台，如果可以的话，它希望知道<strong>分配给具体哪一台电梯</strong>能获得最优性能。（当然，不可以的话，随机挑一台塞进去也不是不能跑）</li><li>既然对分配器想要分配的这一时刻来说，每一台电梯的接下来的所有行为都是已知的，那么每一台电梯接下来的行为可以用以计算其成本。</li><li>那么，分配器想知道分配给哪一台电梯能让总成本最低，就会<strong>依次尝试把乘客请求分配给其中某一台电梯</strong>的情况，并希望知道其总成本：这样，<strong>选出总成本最低的一种情况</strong>，不就是局部的、已知的最优策略了么。相当于在若干条时间线，选了最完美的一条。</li><li>但是，怎么知道每一台电梯接下来的行为，甚至是，每一台电梯在接受了当前乘客请求的这一IF线下，接下来的行为呢？我们刚才已经讨论过了，<strong>既然是状态机，那么必然是可以计算的</strong>。</li><li>把电梯线程叫醒帮自己计算看上去不太现实（事实上也不太现实），那就自己计算吧，把六个状态机的状态拷贝一份，再创造六个接受了当前乘客分配的IF线状态机，选出最好的一条IF线，并拿这个IF线状态机替换掉真正的状态机，狸猫换太子，就实现了最优分配策略。</li><li>那，算都算完了，电梯线程偷个懒不算了，拿着分配器算好的executions，<strong>到时间就执行并且输出</strong>就好了。</li></ul><h2 id=影子电梯但是只有影子电梯>影子电梯：但是只有影子电梯<a hidden class=anchor aria-hidden=true href=#影子电梯但是只有影子电梯>#</a></h2><p>至此，这一臃肿的、模拟真实电梯运行的线程的工作，只剩下：维护一个状态已知、接下来所有状态转移已知的状态机，到了时间就给状态机<strong>执行一步状态转移并输出</strong>，没到时间就回去等着。</p><blockquote><p>那么，电梯还存在吗？或许游离于分配器的心中，或许藏匿于状态机的状态里，又或许<strong>闪烁在评测机的眼中</strong>，反正不可能说它存在于电梯线程的模拟中了，这么说电梯线程也不能答应的，它只是拿着一串executions，到时间就输出出来而已，连execute都是封装好的。所以我称这样的“电梯线程”为<code>Class Printer extends Thread</code>，它就是一台到时间就自动打印的打印机而已。</p></blockquote><blockquote><p>按道理来说，贴代码是没人有心思看的，自己的代码自己迭代时都懒得读，但是这是这个线程所剩下的全部内容了，还是读一下吧？
为可读性优化和简化了部分，所以算伪代码。</p></blockquote><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>run</span>() {  
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>long</span> lastTime <span style=color:#f92672>=</span> System.<span style=color:#a6e22e>currentTimeMillis</span>();  
</span></span><span style=display:flex><span>    lock.<span style=color:#a6e22e>lock</span>();
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 为方便读，这里省掉了await的try-catch包装块。</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>while</span> (<span style=color:#66d9ef>true</span>) {  
</span></span><span style=display:flex><span>		ExecuteAble execution <span style=color:#f92672>=</span> <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>		<span style=color:#75715e>// 瞬间的行为，循环依次完成。</span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>while</span> (<span style=color:#f92672>!</span>executions.<span style=color:#a6e22e>isEmpty</span>()) {  
</span></span><span style=display:flex><span>			execution <span style=color:#f92672>=</span> executions.<span style=color:#a6e22e>getFirst</span>();  
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>if</span> (needTimeToExecute(execution)) {
</span></span><span style=display:flex><span>				<span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>			}
</span></span><span style=display:flex><span>			lastTime <span style=color:#f92672>=</span> executeAndUpdate(execution, lastTime);  
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		<span style=color:#75715e>// 空闲状态，尝试结束或等待新任务的分配。</span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> (executions.<span style=color:#a6e22e>isEmpty</span>()) {  
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>if</span> (end) { <span style=color:#66d9ef>break</span>; }  
</span></span><span style=display:flex><span>			MainProcess.<span style=color:#a6e22e>signalDispatcher</span>();  
</span></span><span style=display:flex><span>			printable.<span style=color:#a6e22e>await</span>();  
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		<span style=color:#75715e>// 非瞬间行为，判断是否满足执行条件，失败则等待。</span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>long</span> timeToWait <span style=color:#f92672>=</span> lastTime  
</span></span><span style=display:flex><span>			<span style=color:#f92672>+</span> needTimeMap.<span style=color:#a6e22e>get</span>(execution)  
</span></span><span style=display:flex><span>			<span style=color:#f92672>-</span> System.<span style=color:#a6e22e>currentTimeMillis</span>();  
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> (timeToWait <span style=color:#f92672>&lt;=</span> 0) {
</span></span><span style=display:flex><span>			lastTime <span style=color:#f92672>=</span> executeAndUpdate(execution, lastTime);  
</span></span><span style=display:flex><span>		} <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>			printable.<span style=color:#a6e22e>await</span>(timeToWait, TimeUnit.<span style=color:#a6e22e>MILLISECONDS</span>);  
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>    lock.<span style=color:#a6e22e>unlock</span>();
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>于是，我们实现了所谓<strong>影子电梯</strong>，证明了影子电梯的可行性，但是全部都是影子电梯。与其说分配器是通过影子电梯计算出分配给具体哪一台真正的电梯，不如说分配器是<strong>拿一台更新后的影子电梯换掉了原来的影子电梯</strong>。</p><h1 id=既然影子电梯可行如何适应性能指标>既然影子电梯可行，如何适应性能指标？<a hidden class=anchor aria-hidden=true href=#既然影子电梯可行如何适应性能指标>#</a></h1><p>现在谈谈该调度策略是如何权衡总时间、加权平均时间和电量的：</p><ol><li>首先，我们要尽量降低<strong>总时间$T_{run}$</strong>：这一性能指标显然比另外两个重要的多，如果为追求低功耗而$T_{run}$过大，我们甚至会被判断为效率太低而<strong>超时</strong>，而平均分配、随机分配等方法，也都是在<strong>放弃对于加权平均时间和功耗的考量</strong>下，追求$T_{run}$的解法。</li></ol><p>但是，$T_{run}$有两个特性：</p><ul><li>一是对于所有电梯来说，<strong>只有最大的$T_{run}$是有意义的</strong>，当其中一台电梯的总时间很长，而给其他某台电梯分配了请求后总时间依然不比最长的总时间长，那么$T_{run}$是没有变化的，此时追求降低$T_{run}$是一种没太大意义的行为。</li><li>二是对于当前$T_{run}$最大的电梯来说，<strong>捎带请求是一种以牺牲少量$T_{run}$换取极大加权平均时间和功耗上收益的决策</strong>。代价是你需要花额外0.4s的$T_{run}$在这一层停下并开关门，性能上却相当划算。</li></ul><p>因此，在六台电梯分别接受分配请求的时间线中，我选出所有接受分配请求后，$\Delta T_{run} \leq 1s$的时间线并纳入考虑，如果没有符合条件的，则选出$T_{run}$增加值最小的一种情况直接作为分配结果。</p><p>接下来我们就可以不考虑$T_{run}$对性能的影响了，即使还有影响，也不到1s，可以大致忽略。我们要考虑，经过筛选后的若干种情况里，加权平均时间$wT$和功耗$W$综合最优的一种情况。但由于性能分是与同学们排名后计算的，我并不知道怎样取得综合最优，理论上我们需要满足：</p>$$\begin{align*}
\Delta \text{cost} &= a \Delta wT + b \Delta W, \quad a + b = 1 \\
\begin{pmatrix} a & b \end{pmatrix} &= \arg\min \Delta \text{cost}
\end{align*}$$<p>我取$\begin{pmatrix} a & b \end{pmatrix} = \begin{pmatrix} \frac{10}{10+1} & \frac{1}{10+1} \end{pmatrix}$，最后效果尚可。</p><h1 id=双轿厢线程协作是否应该影响对象行为>双轿厢：线程协作是否应该影响对象行为？<a hidden class=anchor aria-hidden=true href=#双轿厢线程协作是否应该影响对象行为>#</a></h1><p>我们已经论述过了，时间是线程（具体来讲，是<code>Printer</code>这一打印机线程）要考虑的，线程是<strong>动态的、连续的</strong>，共享对象只有状态，是<strong>静态的、瞬间的</strong>。</p><p>所以双轿厢电梯的行为，是共享对象所考虑的，同步开始改造和避免相撞却是线程所需保证的。</p><p>具体来讲，我们采取的策略是到达临界楼层后，通过锁等方式让协作线程若有需求先等待自己完成任务，自己完成后尽快退出临界楼层（当然该行为也是共享对象所存储的，而非线程唤起的），放还锁让协作线程继续动态行为。</p><p>而在同步改造方面：</p><ul><li>当两电梯的下一execution均为<code>UPDATE-BEGIN</code>时，由分配器输出<code>UPDATE-BEGIN</code>并唤醒两打印机线程进入计时。两线程共享一把锁。</li><li>其中一台电梯<code>UPDATE-BEGIN</code>时锁上共享锁，<code>UPDATE-END</code>时先输出<code>UPDATE-END</code>，然后放还共享锁。</li><li>另一台电梯不输出，<code>UPDATE-BEGIN</code>时无行为，但<code>UPDATE-END</code>时先尝试拿到共享锁，拿到后立即放还，然后才执行自己的后续操作。</li><li>这样，我们就实现了两协作线程的同步。</li></ul><p>在这一过程中，线程间的交互不对对象状态产生影响，只对状态转移的时间，即线程行为有所限制。故而，<strong>线程协作不影响对象行为</strong>。</p><blockquote><p>接下来补充比较重要的内容。</p></blockquote><h1 id=架构设计>架构设计<a hidden class=anchor aria-hidden=true href=#架构设计>#</a></h1><p><div class=post-img-view><a data-fancybox=gallery href=UML.png><img alt=UML loading=lazy src=/posts/buaa/oo/unit-2/summary/UML_hu_acfc11404447a7e.webp></a></div></p><p>很明显能看出三段的设计：$线程-共享对象-线程-共享对象-线程$。</p><p>前文已介绍过该架构的工作流程，在第一次作业中，我采用与大家相同的架构，而在第二次作业的重构中，我将电梯线程的功能解构提取，变成了如上的只保留简单功能的<code>PrinterThread</code>。第三次作业中，无新增类。</p><p>值得介绍的是Scheduler类，其包装了该状态机的决策行为，也即其所有的状态转移计算过程。通过封装Scheduler，我们实现了电梯决策器的可拓展性：当我们需要更换、优化电梯算法，只需要换一个Scheduler或者继承原Scheduler即可。</p><blockquote><p>这里给出一种性能优化思路，配备多种Scheduler，考虑每种电梯装载不同Scheduler，采取不同算法的时间线，并综合总的性能考量，返回给各状态机最优的executions。但该方法的计算量预估提升了一个数量级，为避免CTLE，应谨慎考虑。</p></blockquote><h1 id=线程协作>线程协作<a hidden class=anchor aria-hidden=true href=#线程协作>#</a></h1><p><div class=post-img-view><a data-fancybox=gallery href=sequence-diagram.png><img alt="Sequence Diagram" loading=lazy src=/posts/buaa/oo/unit-2/summary/sequence-diagram_hu_5e2a5a58756fb817.webp></a></div>上图已明了介绍线程中的协作关系，此处详细解释最后的线程结束的判定：</p><ul><li>首先，输入线程的结束条件很清晰：读取到值为<code>null</code>的请求时。</li><li>但对于Request Queue来说，输入线程与六个电梯线程同时作为生产者，分配器作为消费者；同时，对于每个电梯状态机，分配器是生产者，电梯线程是消费者。</li><li>这就形成了一个圈：分配器与电梯互为消费者和生产者，而生产者没有结束时，消费者自然不可以结束。</li><li>因此，我们重新定义电梯线程作为生产者的结束：当其executions为空，即空闲状态下，它自然不可能再放归新的请求，我们可以认为其处于临时的结束状态。</li><li>而对于此时的调度器，倘若没有需要分配的请求，其会尝试结束：<ul><li>输入线程已结束</li><li>各电梯线程处于空闲状态</li><li>也即对于RequestQueue，不会有新的生产，也因此没有消费行为和消费行为导致的新的生产。</li></ul></li><li>此时调度器可以认为达到结束条件，结束自身线程并对后续所有线程设置结束。</li></ul><blockquote><p>有趣的和重要的均已结束，现在补充作业要求的其他内容。</p></blockquote><h1 id=易变的内容>易变的内容<a hidden class=anchor aria-hidden=true href=#易变的内容>#</a></h1><p>稳定的内容已于上文完成分析，而易变的内容，我们需着眼分析两个“例外”：<code>SCHE</code>和<code>UPDATE</code>。</p><ul><li>对于<code>SCHE</code>，我选择将<code>ScheBegin</code>和<code>ScheEnd</code>纳入<code>Executeable</code>范畴，将其视为状态机的正常状态转移行为，从而使其回归稳定的内容的体系；</li><li>对于<code>UPDATE</code>大体相同，但<code>UPDATE-BEGIN</code>实在太特殊，为了两电梯之间的同步，我将其设置为电梯的一种新的状态并因此补充了大量特判，这也是引发我bug的直接原因：补丁没打全。</li></ul><h1 id=bug分析与debug方法>Bug分析与Debug方法<a hidden class=anchor aria-hidden=true href=#bug分析与debug方法>#</a></h1><p>第一二次作业无bug，对第三次作业的<code>UPDATE-BEGIN</code>处理引发了第三次作业的bug，并直接导致了强测爆炸：</p><p>对于<code>UPDATE-ACCEPT</code>前分配给电梯的请求，经过改造后并不一定能接受，因为其所在楼层不一定属于自己所能移动的范围内。而为了避免<code>UPDATE</code>和<code>SCHE</code>之间无法<code>RECEIVE</code>请求导致分配器轮询，我为每个电梯配置<code>RECEIVE</code>请求缓存区，囤积在<code>END</code>后再输出，因此错过了<code>UPDATE-BEGIN</code>时清空当前已<code>RECEIVE</code>请求的机会，从而可能<code>RECEIVE</code>改造后无法处理的请求。</p><p>改正方法为：<code>UPDATE</code>开始时清除<code>RECEIVE</code>缓存区中自己改造后无法处理的请求。</p><p>Debug方法为输出。当debug模式启用时，输出各关键行为前后的线程状态、状态机状态。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// MainProcess.java</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>boolean</span> <span style=color:#a6e22e>debug</span>() { <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>; }
</span></span></code></pre></div><blockquote><p>虽然本次作业没有要求课程建议，但是实在很想建议：</p><p>能不能给一个<code>TimableOutput.debug(String string)</code>然后输出内容不计入评测，只供debug时便于人类查看，间接解决掉评测出的bug在本地无法复现的问题？这样只要写好关键步骤的日志，就能快速定位到bug，即使本地无法复现也可以正常修复？</p></blockquote><h1 id=线程安全与层次化设计>线程安全与层次化设计<a hidden class=anchor aria-hidden=true href=#线程安全与层次化设计>#</a></h1><ol><li><strong>锁的合理使用</strong><ul><li>在本次作业中，线程安全是至关重要的。尤其是在处理多线程的电梯调度和状态更新时，锁的使用非常关键。例如，在电梯线程和分配器线程之间共享的状态机状态（如电梯的当前楼层、电梯内乘客队列等）必须通过锁来保证线程安全。</li><li>我们使用了<code>ReentrantLock</code>来确保在更新状态时不会出现竞态条件。例如，在电梯线程执行状态转移时，需要对<code>executions</code>队列进行操作，此时必须加锁，防止分配器线程同时修改该队列。同时，锁的使用也需要谨慎，避免死锁的发生。在电梯线程和分配器线程之间，我们通过合理的锁顺序和锁的释放时机来避免死锁。</li><li>使用<code>ReentrantLock</code>有什么好处？条件管理更灵活，而且锁可以脱离对象或代码块而存在，请看使用了<code>ReentrantLock</code>的影子电梯的名场面<strong>六把锁</strong>：</li></ul></li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>   elevators.<span style=color:#a6e22e>forEach</span>(Elevator::lock);
</span></span><span style=display:flex><span>   <span style=color:#75715e>// 计算与分配</span>
</span></span><span style=display:flex><span>   elevators.<span style=color:#a6e22e>forEach</span>(Elevator::unlock);
</span></span></code></pre></div><ol start=2><li><strong>线程间通信的同步机制</strong><ul><li>线程间通信的安全性也是线程安全的重要方面。在本次作业中，电梯线程和分配器线程之间通过<code>executions</code>队列进行通信，而这个队列的更新和读取必须是线程安全的。</li><li>我们使用了<code>Condition</code>来实现线程间的同步。例如，当电梯线程处于空闲状态时，它会调用<code>await()</code>等待分配器线程的信号。分配器线程在计算出新的<code>executions</code>后，会调用<code>signal()</code>唤醒电梯线程。这种同步机制确保了线程间通信的正确性和及时性。</li><li>同时，在处理双轿厢电梯的<strong>同步</strong>（改造期间）与<strong>互斥</strong>（临界楼层）时，我们通过共享一把<code>ReentrantLock</code>来实现两台电梯线程之间的同步。这种同步机制不仅保证了线程安全，还避免了电梯之间的冲突。</li></ul></li><li><strong>架构设计的层次化</strong><ul><li>层次化设计使得代码更加清晰和易于维护。在本次作业中，我们将整个电梯系统划分为多个功能模块，每个模块负责特定的功能。</li><li>例如，输入线程负责读取请求并将其放入请求队列；分配器线程负责从请求队列中取出请求并分配给电梯；电梯线程负责执行电梯的状态转移。这种模块划分使得每个线程的功能单一，便于理解和维护。</li><li>同时，我们还引入了<code>Scheduler</code>类来封装电梯的状态转移计算逻辑。这样，当需要更换或优化电梯算法时，只需要修改<code>Scheduler</code>类，而不需要修改电梯线程的代码。这种层次化设计提高了代码的可扩展性和可维护性。</li></ul></li></ol></div><footer class=post-footer><ul class=post-tags></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://oNya685.github.io/>oNya's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script><script>(function(e,t){var s=document,o="script",n=s.createElement(o),i=s.getElementsByTagName(o)[0];n.src=e,t&&n.addEventListener("load",function(e){t(e)}),i.parentNode.insertBefore(n,i)})("//cdn.jsdelivr.net/npm/pangu@4.0.7/dist/browser/pangu.min.js",function(){pangu.spacingPage()})</script></body></html>