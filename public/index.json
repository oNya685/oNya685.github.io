[{"content":"一、思考题 Thinking 0.1 思考下列有关Git的问题：\n在前述已初始化的~/learnGit 目录下，创建一个名为README.txt的文件。执 行命令git status \u0026gt; Untracked.txt（其中的 \u0026gt; 为输出重定向，我们将在0.6.3中详细介绍）。 在README.txt 文件中添加任意文件内容，然后使用add命令，再执行命令git status \u0026gt; Stage.txt。 提交README.txt，并在提交说明里写入自己的学号。 执行命令cat Untracked.txt 和cat Stage.txt，对比两次运行的结果，体会README.txt两次所处位置的不同。 修改README.txt 文件，再执行命令git status \u0026gt; Modified.txt。 执行命令cat Modified.txt，观察其结果和第一次执行add命令之前的status是否一样，并思考原因。 1. Untracked.txt $ cat Untracked.txt 位于分支 master 未跟踪的文件: （使用 \u0026#34;git add \u0026lt;文件\u0026gt;...\u0026#34; 以包含要提交的内容） README.txt Untracked.txt 提交为空，但是存在尚未跟踪的文件（使用 \u0026#34;git add\u0026#34; 建立跟踪） 新建了README.txt文件，处于Untracked状态。\n2. Staged.txt $ cat Staged.txt 位于分支 master 要提交的变更： （使用 \u0026#34;git restore --staged \u0026lt;文件\u0026gt;...\u0026#34; 以取消暂存） 新文件： README.txt 未跟踪的文件: （使用 \u0026#34;git add \u0026lt;文件\u0026gt;...\u0026#34; 以包含要提交的内容） Staged.txt Untracked.txt 修改了README.txt的文件内容，并跟踪和暂存该文件，处于Staged状态。\n3. Modified.txt $ cat Modified.txt 位于分支 master 尚未暂存以备提交的变更： （使用 \u0026#34;git add \u0026lt;文件\u0026gt;...\u0026#34; 更新要提交的内容） （使用 \u0026#34;git restore \u0026lt;文件\u0026gt;...\u0026#34; 丢弃工作区的改动） 修改： README.txt 未跟踪的文件: （使用 \u0026#34;git add \u0026lt;文件\u0026gt;...\u0026#34; 以包含要提交的内容） Modified.txt Staged.txt Untracked.txt 修改尚未加入提交（使用 \u0026#34;git add\u0026#34; 和/或 \u0026#34;git commit -a\u0026#34;） README.txt经暂存和提交后处于Unmodified状态，修改文件内容使其进入Modified状态等待暂存。\nThinking 0.2 仔细看看0.10 ，思考一下箭头中的add the file、stage the file和commit分别对应的是Git里的哪些命令呢？\n1. add the file add the file 对应的是git add。\n2. stage the file stage the file 对应的是git add。\n3. commit commit 对应的是git commit。\nThinking 0.3 思考下列问题：\n代码文件print.c被错误删除时，应当使用什么命令将其恢复？ 代码文件print.c被错误删除后，执行了git rm print.c命令，此时应当使用什么命令将其恢复？ 无关文件hello.txt已经被添加到暂存区时，如何在不删除此文件的前提下将其移出暂存区？ 1. 代码文件 print.c 被错误删除时，应当使用什么命令将其恢复？ git restore print.c print.c 尚未执行git add，故可以从暂存区将print.c恢复到工作区中。\n2. 代码文件 print.c 被错误删除后，执行了 git rm print.c 命令，此时应当使用什么命令将其恢复？ git reset HEAD print.c git restore print.c 首先撤销暂存区的修改（删除了print.c），然后将print.c从暂存区恢复到工作区。\n3. 无关文件 hello.txt 已经被添加到暂存区时，如何在不删除此文件的前提下将其移出暂存区？ git reset HEAD hello.txt 撤销暂存区的修改，把暂存区恢复到执行git add之前的状态。\nThinking 0.4 思考下列有关 Git 的问题：\n找到在 /home/22xxxxxx/learnGit 下刚刚创建的 README.txt 文件，若不存在则新建该文件。 在文件里加入 Testing 1，git add，git commit，提交说明记为 1。 模仿上述做法，把 1 分别改为 2 和 3，再提交两次。 使用 git log 命令查看提交日志，看是否已经有三次提交，记下提交说明为 3 的哈希值1。 进行版本回退。执行命令 git reset \u0026ndash;hard HEAD^ 后，再执行 git log，观察其变化。 找到提交说明为 1 的哈希值，执行命令 git reset \u0026ndash;hard \u0026lt;hash\u0026gt; 后，再执行 git log，观察其变化。 现在已经回到了旧版本，为了再次回到新版本，执行 git reset \u0026ndash;hard \u0026lt;hash\u0026gt;，再执行 git log，观察其变化。 $ git log commit a6ebe244272dd6bcb1f57ba9af3c957f3e7235b3 (HEAD -\u0026gt; master) Author: 姜宇墨 \u0026lt;YumoJiang@buaa.edu.cn\u0026gt; Date: Tue Mar 11 19:08:41 2025 +0800 3 commit 1d11df1461528ce8e2b67151384d4b24bdfec571 Author: 姜宇墨 \u0026lt;YumoJiang@buaa.edu.cn\u0026gt; Date: Tue Mar 11 19:08:33 2025 +0800 2 commit 3f8eb4043efae29bbb9eb626444f955a825f3535 Author: 姜宇墨 \u0026lt;YumoJiang@buaa.edu.cn\u0026gt; Date: Tue Mar 11 19:08:12 2025 +0800 1 提交说明为3的哈希值为a6ebe244272dd6bcb1f57ba9af3c957f3e7235b3。\n$ git reset --hard HEAD^ HEAD 现在位于 1d11df1 2 $ git log commit 1d11df1461528ce8e2b67151384d4b24bdfec571 (HEAD -\u0026gt; master) Author: 姜宇墨 \u0026lt;YumoJiang@buaa.edu.cn\u0026gt; Date: Tue Mar 11 19:08:33 2025 +0800 2 commit 3f8eb4043efae29bbb9eb626444f955a825f3535 Author: 姜宇墨 \u0026lt;YumoJiang@buaa.edu.cn\u0026gt; Date: Tue Mar 11 19:08:12 2025 +0800 1 变化：当前Git仓库的状态回到了2。\n$ git reset --hard 3f8eb4043efae29bbb9eb626444f955a825f3535 HEAD 现在位于 3f8eb40 1 $ git log commit 3f8eb4043efae29bbb9eb626444f955a825f3535 (HEAD -\u0026gt; master) Author: 姜宇墨 \u0026lt;YumoJiang@buaa.edu.cn\u0026gt; Date: Tue Mar 11 19:08:12 2025 +0800 1 变化：当前Git仓库的状态回到了1。\n$ git reset --hard a6ebe244272dd6bcb1f57ba9af3c957f3e7235b3 HEAD 现在位于 a6ebe24 3 $ git log commit a6ebe244272dd6bcb1f57ba9af3c957f3e7235b3 (HEAD -\u0026gt; master) Author: 姜宇墨 \u0026lt;YumoJiang@buaa.edu.cn\u0026gt; Date: Tue Mar 11 19:08:41 2025 +0800 3 commit 1d11df1461528ce8e2b67151384d4b24bdfec571 Author: 姜宇墨 \u0026lt;YumoJiang@buaa.edu.cn\u0026gt; Date: Tue Mar 11 19:08:33 2025 +0800 2 commit 3f8eb4043efae29bbb9eb626444f955a825f3535 Author: 姜宇墨 \u0026lt;YumoJiang@buaa.edu.cn\u0026gt; Date: Tue Mar 11 19:08:12 2025 +0800 1 变化：当前Git仓库的状态回到了3。\nThinking 0.5 执行如下命令, 并查看结果\necho first echo second \u0026gt; output.txt echo third \u0026gt; output.txt echo forth \u0026raquo; output.txt $ echo first first $ echo second \u0026gt; output.txt \u0026amp;\u0026amp; cat output.txt second $ echo third \u0026gt; output.txt \u0026amp;\u0026amp; cat output.txt third $ echo forth \u0026gt;\u0026gt; output.txt \u0026amp;\u0026amp; cat output.txt third forth Thinking 0.6 使用你知道的方法（包括重定向）创建下图内容的文件（文件命名为 test），将创建该文件的命令序列保存在command文件中，并将test文件作为批处理文件运行，将运行结果输出至result文件中。给出command文件和result文件的内容，并对最后的结果进行解释说明（可以从test文件的内容入手）。具体实现的过程中思考下列问题: echo echo Shell Start 与 echo `echo Shell Start` 效果是否有区别; echo echo $c\u0026gt;file1 与 echo `echo $c\u0026gt;file1` 效果是否有区别.\n# command echo \u0026#39;echo Shell Start...\u0026#39; \u0026gt; test echo \u0026#39;echo set a = 1\u0026#39; \u0026gt;\u0026gt; test echo \u0026#39;a=1\u0026#39; \u0026gt;\u0026gt; test echo \u0026#39;echo set b = 2\u0026#39; \u0026gt;\u0026gt; test echo \u0026#39;b=2\u0026#39; \u0026gt;\u0026gt; test echo \u0026#39;echo set c = a+b\u0026#39; \u0026gt;\u0026gt; test echo \u0026#39;c=$[$a+$b]\u0026#39; \u0026gt;\u0026gt; test echo \u0026#39;echo c = $c\u0026#39; \u0026gt;\u0026gt; test echo \u0026#39;echo save c to ./file1\u0026#39; \u0026gt;\u0026gt; test echo \u0026#39;echo $c\u0026gt;file1\u0026#39; \u0026gt;\u0026gt; test echo \u0026#39;echo save b to ./file2\u0026#39; \u0026gt;\u0026gt; test echo \u0026#39;echo $b\u0026gt;file2\u0026#39; \u0026gt;\u0026gt; test echo \u0026#39;echo save a to ./file3\u0026#39; \u0026gt;\u0026gt; test echo \u0026#39;echo $a\u0026gt;file3\u0026#39; \u0026gt;\u0026gt; test # 注意此处逻辑错误，应为echo $a\u0026gt;file3 echo \u0026#39;echo save file1 file2 file3 to file4\u0026#39; \u0026gt;\u0026gt; test echo \u0026#39;cat file1\u0026gt;file4\u0026#39; \u0026gt;\u0026gt; test echo \u0026#39;cat file2\u0026gt;\u0026gt;file4\u0026#39; \u0026gt;\u0026gt; test echo \u0026#39;cat file3\u0026gt;\u0026gt;file4\u0026#39; \u0026gt;\u0026gt; test echo \u0026#39;echo save file4 to ./result\u0026#39; \u0026gt;\u0026gt; test echo \u0026#39;cat file4\u0026gt;\u0026gt;result\u0026#39; \u0026gt;\u0026gt; test # test echo Shell Start... # 输出初始化提示 echo set a = 1 a=1 # 设置变量a=1 echo set b = 2 b=2 # 设置变量b=2 echo set c = a+b c=$[$a+$b] # 执行算术运算c=a+b=1+2=3 echo c = $c # 输出计算结果 echo save c to ./file1 echo $c\u0026gt;file1 # 将c的值写入file1 echo save b to ./file2 echo $b\u0026gt;file2 # 将b的值写入file2 echo save a to ./file3 echo $a\u0026gt;file3 # 将a的值写入file3 echo save file1 file2 file3 to file4 cat file1\u0026gt;file4 # 创建file4并写入file1内容 cat file2\u0026gt;\u0026gt;file4 # 追加file2内容 cat file3\u0026gt;\u0026gt;file4 # 追加file3内容 echo save file4 to ./result cat file4\u0026gt;\u0026gt;result # 最终结果是c,b,a的值 $ ./test Shell Start... set a = 1 set b = 2 set c = a+b c = 3 save c to ./file1 save b to ./file2 save a to ./file3 save file1 file2 file3 to file4 save file4 to ./result $ cat result 3 2 1 反引号会先执行命令替换，改变重定向行为。\necho echo Shell Start echo `echo Shell Start` 输出字符串echo Shell Start 先执行命令echo Shell Start再输出该命令的执行结果Shell Start echo echo $c\u0026gt;file1 echo `echo $c\u0026gt;file1` 将字符串echo 3写入file1 先将3写入file1，再输出写入的执行结果（为空），即终端无输出 二、难点分析与实验体会 本次实验的主要难点在于工具链的命令行参数和shell编程掌握不够熟练。\n难点1：sed的用法 为实现在 hello_os.sh 所处的目录新建一个名为BBB的文件，其内容为 AAA文件的第8、32、128、512、1024行的内容提取，构造sed命令\nsed -n \u0026#39;8p;32p;128p;512p;1024p\u0026#39; \u0026#34;$1\u0026#34; \u0026gt; \u0026#34;$2\u0026#34; 难点2：awk行号提取 grep -n \u0026#34;$2\u0026#34; ./\u0026#34;$1\u0026#34; | awk -F \u0026#39;:\u0026#39; \u0026#39;{print $1}\u0026#39; \u0026gt; ./\u0026#34;$3\u0026#34; 难点3：GCC与Make的特殊用法 # 多目录编译示例 gcc -I ../include -c fibo.c -o fibo.o # 调用子目录make命令示例 make -C code fibo.o 三、原创说明 在本次实验中，对工具链的使用参考了官方manual和--help参数。\n在Neovim和LazyVim的安装与配置中，参考了如何在Ubuntu上安装最新版本的Neovim并快速配置_ubuntu安装neovim-CSDN博客 使用 git log 命令时，在 commit 标识符后的一长串数字和字母组成的字符串\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","permalink":"https://oNya685.github.io/posts/buaa/os/lab-0-report/","summary":"\u003ch1 id=\"一思考题\"\u003e一、思考题\u003c/h1\u003e\n\u003ch2 id=\"thinking-01\"\u003eThinking 0.1\u003c/h2\u003e\n\u003cblockquote\u003e\n\u003cp\u003e思考下列有关Git的问题：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e在前述已初始化的~/learnGit 目录下，创建一个名为README.txt的文件。执 行命令git status \u0026gt; Untracked.txt（其中的 \u0026gt; 为输出重定向，我们将在0.6.3中详细介绍）。\u003c/li\u003e\n\u003cli\u003e在README.txt 文件中添加任意文件内容，然后使用add命令，再执行命令git status \u0026gt; Stage.txt。\u003c/li\u003e\n\u003cli\u003e提交README.txt，并在提交说明里写入自己的学号。\u003c/li\u003e\n\u003cli\u003e执行命令cat Untracked.txt 和cat Stage.txt，对比两次运行的结果，体会README.txt两次所处位置的不同。\u003c/li\u003e\n\u003cli\u003e修改README.txt 文件，再执行命令git status \u0026gt; Modified.txt。\u003c/li\u003e\n\u003cli\u003e执行命令cat Modified.txt，观察其结果和第一次执行add命令之前的status是否一样，并思考原因。\u003c/li\u003e\n\u003c/ul\u003e\u003c/blockquote\u003e\n\u003chr\u003e\n\u003ch3 id=\"1-untrackedtxt\"\u003e1. Untracked.txt\u003c/h3\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e$  cat Untracked.txt\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e位于分支 master\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e未跟踪的文件:\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  （使用 \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;git add \u0026lt;文件\u0026gt;...\u0026#34;\u003c/span\u003e 以包含要提交的内容）\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        README.txt\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        Untracked.txt\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e提交为空，但是存在尚未跟踪的文件（使用 \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;git add\u0026#34;\u003c/span\u003e 建立跟踪）\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e新建了\u003ccode\u003eREADME.txt\u003c/code\u003e文件，处于Untracked状态。\u003c/p\u003e","title":"[BUAA-OS] Lab 0 实验报告"},{"content":"点此查看作业源文件 1.什么是多道程序设计？多道程序设计与分时系统的区别是什么？ 多道程序设计技术，是指允许多个程序同时进⼊内存并运⾏。即同时把多个程序放⼊内存中，并允许它们交替在CPU中运⾏，共享系统中的各种硬、软件资源，当⼀道程序因I/O请求⽽暂停运⾏时，CPU便⽴即转去运⾏另⼀道程序。多道程序设计技术提⾼了CPU、I/O设备和内存的利⽤率，从⽽提⾼了整个系统的资源利⽤率和系统吞吐量，最终提⾼了整个系统的效率。\n多道程序设计与分时系统的区别在于：多道程序设计主要关注的是如何让多个程序在内存中同时存在并交替执⾏，以提⾼资源利⽤率。分时系统则是在多道程序设计的基础上进⼀步发展，它不仅允许多个程序并发执⾏，还通过时间⽚轮转的⽅式为每个⽤户分配CPU时间，使得多个⽤户可以⼏乎同时使⽤计算机，提供交互式服务。\n2.什么原因推动了操作系统从批处理发展到多道程序，进而发展到分时系统？ 批处理系统的运⾏效率被低速I/O设备限制，CPU空闲时间多，利⽤率低，因此发展出多道程序系统；\n多道程序系统平均周转时间⻓，不能提供交互作⽤能⼒，因此发展出允许多个⽤户共享计算机，多个程序分时共享硬、软件资源的分时系统。\n3.什么是陷阱？与中断的区别是什么？什么是系统调用？ 陷阱是⼀种同步异常，是程序内部有意设置的某⼀特定指令执⾏的结果，例如系统调⽤。陷阱是程序执⾏过程中预期的⾏为，可以复现，⽤于请求操作系统提供服务等。\n中断是⼀种异步异常，通常由外部事件（I/O设备、处理器时钟或定时器）触发，与处理器正在执⾏的内容⽆关。中断是不可预测的，⽤于处理外部事件。\n系统调⽤是⽤户程序与操作系统内核之间的接⼝，允许⽤户程序请求操作系统提供的服务。系统调⽤本质上是⼀种同步异常，或陷阱，⽤于安全地进⼊内核模式并执⾏特权操作。\n4.判断：可移植的操作系统可以从一个系统架构移植到另外一个系统架构而无需修改。 错误。不同系统架构之间存在指令集差异、内存管理方式不同、硬件寄存器配置不一致等根本性区别，操作系统必须针对这些硬件特性进行调整。\n(1)请解释为什么构建完全可移植的OS是不可能的？ 不同硬件架构的指令集、总线设计和CPU字长等存在差异，操作系统必须依赖硬件相关代码，⽆法完全通⽤。\n(2)如果需要你设计一个高度可移植的OS，那么请描述你需要设计的两个层次？ 高度可移植的操作系统由机器相关层和机器无关层组成。机器无关层只需实现一次即可。\n机器相关层处理硬件的具体特性，必须针对每个架构单独实现。该层为机器无关层提供统一的接口。为实现高度可移植性，机器相关层的规模应尽可能最小化。\n5.在设计操作系统时，一些设计指标是相互矛盾的，例如资源利用率、吞吐量、处理时间、健壮性等。请给出一对相互矛盾的设计实例。 资源利⽤率与响应时间。\n资源利⽤率⾼意味着尽可能多地利⽤系统资源，但可能导致频繁的切换和复杂的调度策略，从⽽增加响应时间。响应时间短要求操作系统能够快速响应⽤户请求，可能保留更多的资源⽤于即时响应，导致资源利⽤率下降。\n6.一个计算机系统有输入机一台、打印机两台，现有二道程序同时投入运行，且程序A先开始运行，程序B后运行。程序A的运行轨迹为：计算50ms，打印信息100ms，再计算50ms，打印信息100ms，结束。程序B运行的轨迹为：计算50ms，输入数据80ms，再计算100ms，结束。要求： (1)用图画出这二道程序并发执行时的工作情况。 (2)说明在二道程序运行时，CPU有无空闲等待？若有，在哪段时间内等待？为什么会空闲等待？ 有。在100ms~150ms，程序A在打印信息，程序B在输入数据，故CPU处于空闲等待。\n(3)程序A、B运行时有无等待现象？在什么时候会发生等待现象？ 程序A没有，程序B有。\n在180ms~200ms，程序B完成了输入数据，在等待CPU空闲，而程序A占用了处理器，正在进行计算，故程序B等待了20ms。\n","permalink":"https://oNya685.github.io/posts/buaa/os/homework-1/","summary":"\u003cp\u003e\u003cstrong\u003e\u003ca href=\"%e4%bd%9c%e4%b8%9a1.pdf\" target=\"_blank\"\u003e点此查看作业源文件\u003c/a\u003e\n\u003c/strong\u003e\u003c/p\u003e\n\u003ch1 id=\"1什么是多道程序设计多道程序设计与分时系统的区别是什么\"\u003e1.什么是多道程序设计？多道程序设计与分时系统的区别是什么？\u003c/h1\u003e\n\u003cp\u003e多道程序设计技术，是指允许多个程序同时进⼊内存并运⾏。即同时把多个程序放⼊内存中，并允许它们交替在CPU中运⾏，共享系统中的各种硬、软件资源，当⼀道程序因I/O请求⽽暂停运⾏时，CPU便⽴即转去运⾏另⼀道程序。多道程序设计技术提⾼了CPU、I/O设备和内存的利⽤率，从⽽提⾼了整个系统的资源利⽤率和系统吞吐量，最终提⾼了整个系统的效率。\u003c/p\u003e","title":"[BUAA-OS] 理论作业 1"}]