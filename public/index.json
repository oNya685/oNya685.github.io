[{"content":"架构简介 在本单元中，作业要求我们对提供了形式化表述的复杂表达式进行解析和化简，并要求尽可能简短的输出以度量性能分数。\n而经过三次作业迭代（其中包含一次重构），最终架构设计图如下：\n核心处理部分在于递归解析模块的两个递归，在图中具体表现为两个圈。接下来介绍和分析各模块的结构。\n主线处理 本模块是整个项目的主体部分，其中箭头含义表示流程顺序，不代表类的继承关系。主要流程呈现为main方法：\nString input = scanner.nextLine(); // 读入 Lexer lexer = new Lexer(input.replaceAll(\u0026#34; \u0026#34;, \u0026#34;\u0026#34;).replaceAll(\u0026#34;\\t\u0026#34;, \u0026#34;\u0026#34;)); // 词法解析 Parser parser = new Parser(lexer); // 传入Tokens System.out.println(parser .parseExpr() // 语法解析 .assign(null) // 赋值处理函数调用 .toPoly() // 计算化简 .Print() // 构造StringBuilder .toString()); // 输出结果 这样类似流水线的设计的优点是显而易见的，我们只需写好每一模块，封装成黑盒，确保每一部分的程序正确性，就可以完整实现所需功能。\n然而，见上面整体图可以看出，除了实现核心功能的解析模块，其余部分的耦合度其实是偏高的。\n我们会发现，Lexer, Parser, Poly这几个在主线中实现了相当一部分功能的类，因为把大量的重复性功能藏在一个类甚至一个方法内部实现（例如Lexer的大量if-else出现了控制分支数目大的问题），出现了耦合度过高、可读性差的问题。\n举例来说，我们可以分析这个只由两个类实现计算、化简、简化功能的模块：\n计算化简 这个模块内部实现了过多功能，方法个数多，方法规模大，只因它们都涉及到用于存储化简后输出结果的类——Poly（多项式）和Mono（单项式）——这就导致了这一部分难读、难拆、难拓展。\n递归解析 而与之相对的，由于有先导课程的最后一次作业的架构作参考，这个采用递归下降法解析和存储的模块有相当良好的可拓展性和低耦合度。\n这一模块的度量值相当良好，故省略去分析。这一部分的递归主要在于\nExpr - Term - \u0026lt;Factor\u0026gt; ExprFactor - Expr （见橙色箭头）形成的环，该递归改编自先导课程作业代码。 Expr - Term - \u0026lt;Factor\u0026gt; \u0026lt;VarFactor\u0026gt; FuncCall - \u0026lt;FuncDefine.exprs\u0026gt; Expr 。这一递归赋值处理函数调用的思路详见我在第二次作业中的讨论发帖 ，当然，在非校园网环境下，你也可以从此获取 。这一设计有极好的可拓展性，我们将在下一节进一步讨论。 迭代成型 第一次作业 通过采用先导课的递归下降设计，第一次作业的难点就主要在于计算与化简的部分了。此时我们埋下了直接导致需要重构的第一个雷，对于幂函数的处理，我没有完全参照形式化表述的思路，而是单独设计了一个类来表示幂函数，并于计算时再具体展开。\n第二次作业 重构：形式化表述 重构前后的复杂度其实近似，故省去分析，但值得注意的是前后的架构设计：\n其实都很明了，但最主要的区别其实是：重构后的类的设计完全符合了给出的形式化表述。第二次作业的迭代突然把形式化表述内容几乎翻倍不止，如果要沿着原来的架构像打补丁一样加上这大量的迭代内容，很可能最后根本写不完。\n而重构后的迭代体验也大幅提升：我只需要无脑照抄形式化表述，就能写好解析器，设计好各个类，这不仅省下了时间，也直接跳过了大量与形式化表述不统一而可能引发的潜在的bug。\n另一个大任务是递归函数调用的处理 在得知该迭代需求后，我耗费了相当久的时间思考如何以合理、优雅的方式处理递归函数调用，最终设计的一套处理思路 取得了相当好的可拓展性和相对低的耦合度，并结合动态规划和藏在其中的部分简化（例如，若某ExprFactor的Expr有且只有一个Term，该Term有且只有一个Factor，则该ExprFactor的简化方法返回该Factor，否则返回自身），实现了时间和空间上的大幅优化，并顺利解决掉了当f{n}的n过大时易爆栈的问题（事实上，事后发现课程组的Cost限制完全不足以超时或爆栈）。\n第三次作业 虽说在第二次作业的互测里被打了不少次，理应来说，如果有继续迭代开发的需求，我会继续重构，并明确几点：\n对象属性是否可变，会用到返回值的各种方法除了返回值之外应不应该产生副作用，会不会错误得复用某对象。 明确哪些类需要重写hashCode()和equals()，这一点对于优化性能得分至关重要。 耦合度过高的Poly和Mono是肯定要拆的，怎么分解而能继续实现原有功能，怎么设计更适合迭代的架构，怎么给优化性能留位置等。 但我并没有重构——第三次作业的需求很简单：\n一是普通函数调用，我原设计的递归函数调用处理方法有相当的可拓展性，我甚至没有修改函数相关的类就轻松实现了该要求。\n二是求导因子，但课程组给求导因子的限制过大，尤其是出现范围十分限定，因此我们只需在主线的流水线挑一个方便的环节（包括解析，运算，赋值，简化），附带上求导运算，就实现了。\n所以为什么不重构？第二次作业虽然烂了点，但经过强侧和互测的检验，打完补丁就是能保障正确性的代码。重构意味着要重新面对潜在的bug，而在当前这一坨上作简单的迭代并没有显著难度，正确性也更有保障。因此，没有第二次重构。\nBug分析 诡异的HashMap 这一bug并不是被测出来的：不解决这bug程序完全不能跑。这一单元里，大家都或多或少地与HashMap之类的容器或者hashCode等方法斗争了许久。至今我也不知道，除了新建一个容器往里塞，怎么遍历才能做到不报错。如果有下次，我可能选.stream().map().collect()。\n完全符合形式化表述，但符合得不太完全 \u0026lt;递推表达式\u0026gt; → \u0026lt;常数因子\u0026gt; \u0026lt;空白项\u0026gt; \u0026#39;*\u0026#39; \u0026lt;空白项\u0026gt; \u0026lt;自定义递推函数调用n-1\u0026gt; \u0026lt;空白项\u0026gt; \u0026lt;加减\u0026gt; \u0026lt;空白项\u0026gt; \u0026lt;常数因子\u0026gt; \u0026lt;空白项\u0026gt; \u0026#39;*\u0026#39; \u0026lt;空白项\u0026gt; \u0026lt;自定义递推函数调用n-2\u0026gt; [\u0026lt;空白项\u0026gt; \u0026#39;+\u0026#39; \u0026lt;空白项\u0026gt; \u0026lt;函数表达式\u0026gt;] 虽然经过一次完全符合形式化表述的重构，但因为我的设计足以实现对函数调用的解析，所以我本以为递推表达式就是比较特殊的表达式，其实不然。这个[\u0026lt;空白项\u0026gt; '+' \u0026lt;空白项\u0026gt; \u0026lt;函数表达式\u0026gt;]的诡异的加号让... + + + +1这样的表述变成了可能。这一bug着实很坑，但也没有什么经验可总结。\n谁会在sin()里套sin()*sin()？ 本以为第三次作业大家都差不多，互测更是全房 0 Hack，应该不会有bug了……吗？\n啊，输出了sin(sin(...)*sin(...))，但里面是一个表达式而非一个因子，所以应该是sin((sin(...)*sin(...)))。省去了不该省的括号。这个小bug从第二次作业互测测到第三次作业互测，都没有被测出来，第三次强测反倒测出来了，如果侥幸一点没测出来，这个bug可能永远都不会被发现了。\n当然也有喜闻乐见的 最喜欢分析的bug是别人的bug，在此稍加分析有参考意义的两例。\nextraTriangle!!! extraTriangle!!!一位没删用于调试的输出信息的同学如是喊道。\n这一bug值得分析是因为教会了我们设计一个调试开关，例如：\n// MainClass.java public Class MainClass { public static boolean debug() { return true; } ... public static void main(String[] args) { if (MainClass.debug()) { System.out.println(\u0026#34;Debug模式还没关，别看都不看就直接交了\u0026#34;); } ... } } 可能复用的对象，clone()或谨防副作用 我用一个简单的函数，调用了f{5}(x,x^2)，就一次刀穿了三人（不过其中一人其实没错，他只是在喊extraTriangle!!!），仔细看看，竟与之前发现并修掉的bug如出一辙。有的时候，我们需要这个对象本身，有的时候，我们只是需要这个对象的值。\n张三长大了一岁，无论是谁眼中的张三，都长大了一岁。有的时候，我们需要给张三拍照，把他当前的样子保留下来（或者是生成一个和当前的张三长得一样的克隆人）。问题就出在，可能A让张三长大了一岁，而B想给张三拍照时并没考虑到张三长大了一岁，拍下了不符合预期的照片。\n我的解决方案是，A生成张三的克隆人，并把克隆人当成张三，后续让“张三”长大一岁，原来的张三就不会受到影响，B随时都可以给张三拍照拍到正确的样子。\n测试策略 看源代码还是太折磨了，只有第一次作业读代码来设计测试用例了，后来都找不到用正则解析的了，大家处理思路十分趋同，与其看代码，不如直接构造各类极端样例，进行盲测了。\n当然不能直接用互测窗口测，CD太长；也不能开八个IDEA窗口挨个输入，效率太低；首先将八个压缩包编译生成八个jar包，然后用命令行批量处理，用文件实现读写，最后把大家的答案扔进优化得最好最稳定的同学的jar包，就能得到格式统一的输出了。当然这是不够严谨的做法，我们也可以采取python的一些妙妙工具，把输出的字符串里的x直接文本替换成各种刁钻的数值，评判输出的纯数字结果是不是相隔很小即可（理论上结果应该一模一样，但三角函数优化和浮点数带来的误差不可避免）。\n优化策略 前文已经提到了大部分的优化，因为实在无力处理三角函数的各种优化，且保住正确性分比贪性能分更稳妥。\n现介绍前文未提到的两处优化：\n重写equals()以合并同类项 与之对应的，我们也要重写hashCode()以实现在HashMap中能找到该同类项。\n这样我们就可以应对括号内的值存在关联性的三角函数之间的合并了。\n为返回值作顺带简化 例如前文提到的将ExprFactor返回其中仅有的Factor，可以一定程度上省去不必要的括号；又如cos(0)和sin(0)，可以直接返回具体数值。\n心得体会 虽然第三次作业的轻松要求确实减少了我们的工作量，让我直接放弃了第二次的重构，但我仍没能理解普通函数调用为什么会放在递归函数调用之后作为新要求迭代。第二次作业的任务量也着实有些惊悚，不知是传统还是失误。\n总的来说，第一单元在先导课提供了参考架构的基础上还算顺利，也能明显感到有所收获，期待第二单元的灵异电梯。\n","permalink":"https://oNya685.github.io/posts/buaa/oo/unit-1/summary/","summary":"\u003ch1 id=\"架构简介\"\u003e架构简介\u003c/h1\u003e\n\u003cp\u003e在本单元中，作业要求我们对提供了\u003cstrong\u003e形式化表述\u003c/strong\u003e的复杂表达式进行\u003cstrong\u003e解析和化简\u003c/strong\u003e，并要求尽可能简短的输出以度量性能分数。\u003c/p\u003e\n\u003cp\u003e而经过三次作业迭代（其中包含一次重构），最终架构设计图如下：\u003c/p\u003e","title":"[BUAA-OO] Unit 1 总结"},{"content":"一、思考题 Thinking 0.1 思考下列有关Git的问题：\n在前述已初始化的~/learnGit 目录下，创建一个名为README.txt的文件。执行命令git status \u0026gt; Untracked.txt（其中的 \u0026gt; 为输出重定向，我们将在0.6.3中详细介绍）。 在README.txt 文件中添加任意文件内容，然后使用add命令，再执行命令git status \u0026gt; Stage.txt。 提交README.txt，并在提交说明里写入自己的学号。 执行命令cat Untracked.txt 和cat Stage.txt，对比两次运行的结果，体会README.txt两次所处位置的不同。 修改README.txt 文件，再执行命令git status \u0026gt; Modified.txt。 执行命令cat Modified.txt，观察其结果和第一次执行add命令之前的status是否一样，并思考原因。 1. Untracked.txt $ cat Untracked.txt 位于分支 master 未跟踪的文件: （使用 \u0026#34;git add \u0026lt;文件\u0026gt;...\u0026#34; 以包含要提交的内容） README.txt Untracked.txt 提交为空，但是存在尚未跟踪的文件（使用 \u0026#34;git add\u0026#34; 建立跟踪） 新建了README.txt文件，处于Untracked状态。\n2. Staged.txt $ cat Staged.txt 位于分支 master 要提交的变更： （使用 \u0026#34;git restore --staged \u0026lt;文件\u0026gt;...\u0026#34; 以取消暂存） 新文件： README.txt 未跟踪的文件: （使用 \u0026#34;git add \u0026lt;文件\u0026gt;...\u0026#34; 以包含要提交的内容） Staged.txt Untracked.txt 修改了README.txt的文件内容，并跟踪和暂存该文件，处于Staged状态。\n3. Modified.txt $ cat Modified.txt 位于分支 master 尚未暂存以备提交的变更： （使用 \u0026#34;git add \u0026lt;文件\u0026gt;...\u0026#34; 更新要提交的内容） （使用 \u0026#34;git restore \u0026lt;文件\u0026gt;...\u0026#34; 丢弃工作区的改动） 修改： README.txt 未跟踪的文件: （使用 \u0026#34;git add \u0026lt;文件\u0026gt;...\u0026#34; 以包含要提交的内容） Modified.txt Staged.txt Untracked.txt 修改尚未加入提交（使用 \u0026#34;git add\u0026#34; 和/或 \u0026#34;git commit -a\u0026#34;） README.txt经暂存和提交后处于Unmodified状态，修改文件内容使其进入Modified状态等待暂存。\nThinking 0.2 仔细看看0.10 ，思考一下箭头中的add the file、stage the file和commit分别对应的是Git里的哪些命令呢？\n1. add the file add the file 对应的是git add。\n2. stage the file stage the file 对应的是git add。\n3. commit commit 对应的是git commit。\nThinking 0.3 思考下列问题：\n代码文件print.c被错误删除时，应当使用什么命令将其恢复？ 代码文件print.c被错误删除后，执行了git rm print.c命令，此时应当使用什么命令将其恢复？ 无关文件hello.txt已经被添加到暂存区时，如何在不删除此文件的前提下将其移出暂存区？ 1. 代码文件 print.c 被错误删除时，应当使用什么命令将其恢复？ git restore print.c print.c 尚未执行git add，故可以从暂存区将print.c恢复到工作区中。\n2. 代码文件 print.c 被错误删除后，执行了 git rm print.c 命令，此时应当使用什么命令将其恢复？ git reset HEAD print.c git restore print.c 首先撤销暂存区的修改（删除了print.c），然后将print.c从暂存区恢复到工作区。\n3. 无关文件 hello.txt 已经被添加到暂存区时，如何在不删除此文件的前提下将其移出暂存区？ git reset HEAD hello.txt 撤销暂存区的修改，把暂存区恢复到执行git add之前的状态。\nThinking 0.4 思考下列有关 Git 的问题：\n找到在 /home/22xxxxxx/learnGit 下刚刚创建的 README.txt 文件，若不存在则新建该文件。 在文件里加入 Testing 1，git add，git commit，提交说明记为 1。 模仿上述做法，把 1 分别改为 2 和 3，再提交两次。 使用 git log 命令查看提交日志，看是否已经有三次提交，记下提交说明为 3 的哈希值1。 进行版本回退。执行命令 git reset \u0026ndash;hard HEAD^ 后，再执行 git log，观察其变化。 找到提交说明为 1 的哈希值，执行命令 git reset \u0026ndash;hard \u0026lt;hash\u0026gt; 后，再执行 git log，观察其变化。 现在已经回到了旧版本，为了再次回到新版本，执行 git reset \u0026ndash;hard \u0026lt;hash\u0026gt;，再执行 git log，观察其变化。 $ git log commit a6ebe244272dd6bcb1f57ba9af3c957f3e7235b3 (HEAD -\u0026gt; master) Author: 姜宇墨 \u0026lt;YumoJiang@buaa.edu.cn\u0026gt; Date: Tue Mar 11 19:08:41 2025 +0800 3 commit 1d11df1461528ce8e2b67151384d4b24bdfec571 Author: 姜宇墨 \u0026lt;YumoJiang@buaa.edu.cn\u0026gt; Date: Tue Mar 11 19:08:33 2025 +0800 2 commit 3f8eb4043efae29bbb9eb626444f955a825f3535 Author: 姜宇墨 \u0026lt;YumoJiang@buaa.edu.cn\u0026gt; Date: Tue Mar 11 19:08:12 2025 +0800 1 提交说明为3的哈希值为a6ebe244272dd6bcb1f57ba9af3c957f3e7235b3。\n$ git reset --hard HEAD^ HEAD 现在位于 1d11df1 2 $ git log commit 1d11df1461528ce8e2b67151384d4b24bdfec571 (HEAD -\u0026gt; master) Author: 姜宇墨 \u0026lt;YumoJiang@buaa.edu.cn\u0026gt; Date: Tue Mar 11 19:08:33 2025 +0800 2 commit 3f8eb4043efae29bbb9eb626444f955a825f3535 Author: 姜宇墨 \u0026lt;YumoJiang@buaa.edu.cn\u0026gt; Date: Tue Mar 11 19:08:12 2025 +0800 1 变化：当前Git仓库的状态回到了2。\n$ git reset --hard 3f8eb4043efae29bbb9eb626444f955a825f3535 HEAD 现在位于 3f8eb40 1 $ git log commit 3f8eb4043efae29bbb9eb626444f955a825f3535 (HEAD -\u0026gt; master) Author: 姜宇墨 \u0026lt;YumoJiang@buaa.edu.cn\u0026gt; Date: Tue Mar 11 19:08:12 2025 +0800 1 变化：当前Git仓库的状态回到了1。\n$ git reset --hard a6ebe244272dd6bcb1f57ba9af3c957f3e7235b3 HEAD 现在位于 a6ebe24 3 $ git log commit a6ebe244272dd6bcb1f57ba9af3c957f3e7235b3 (HEAD -\u0026gt; master) Author: 姜宇墨 \u0026lt;YumoJiang@buaa.edu.cn\u0026gt; Date: Tue Mar 11 19:08:41 2025 +0800 3 commit 1d11df1461528ce8e2b67151384d4b24bdfec571 Author: 姜宇墨 \u0026lt;YumoJiang@buaa.edu.cn\u0026gt; Date: Tue Mar 11 19:08:33 2025 +0800 2 commit 3f8eb4043efae29bbb9eb626444f955a825f3535 Author: 姜宇墨 \u0026lt;YumoJiang@buaa.edu.cn\u0026gt; Date: Tue Mar 11 19:08:12 2025 +0800 1 变化：当前Git仓库的状态回到了3。\nThinking 0.5 执行如下命令, 并查看结果\necho first echo second \u0026gt; output.txt echo third \u0026gt; output.txt echo forth \u0026raquo; output.txt $ echo first first $ echo second \u0026gt; output.txt \u0026amp;\u0026amp; cat output.txt second $ echo third \u0026gt; output.txt \u0026amp;\u0026amp; cat output.txt third $ echo forth \u0026gt;\u0026gt; output.txt \u0026amp;\u0026amp; cat output.txt third forth Thinking 0.6 使用你知道的方法（包括重定向）创建下图内容的文件（文件命名为 test），将创建该文件的命令序列保存在command文件中，并将test文件作为批处理文件运行，将运行结果输出至result文件中。给出command文件和result文件的内容，并对最后的结果进行解释说明（可以从test文件的内容入手）。具体实现的过程中思考下列问题: echo echo Shell Start 与 echo `echo Shell Start` 效果是否有区别; echo echo $c\u0026gt;file1 与 echo `echo $c\u0026gt;file1` 效果是否有区别.\n# command echo \u0026#39;echo Shell Start...\u0026#39; \u0026gt; test echo \u0026#39;echo set a = 1\u0026#39; \u0026gt;\u0026gt; test echo \u0026#39;a=1\u0026#39; \u0026gt;\u0026gt; test echo \u0026#39;echo set b = 2\u0026#39; \u0026gt;\u0026gt; test echo \u0026#39;b=2\u0026#39; \u0026gt;\u0026gt; test echo \u0026#39;echo set c = a+b\u0026#39; \u0026gt;\u0026gt; test echo \u0026#39;c=$[$a+$b]\u0026#39; \u0026gt;\u0026gt; test echo \u0026#39;echo c = $c\u0026#39; \u0026gt;\u0026gt; test echo \u0026#39;echo save c to ./file1\u0026#39; \u0026gt;\u0026gt; test echo \u0026#39;echo $c\u0026gt;file1\u0026#39; \u0026gt;\u0026gt; test echo \u0026#39;echo save b to ./file2\u0026#39; \u0026gt;\u0026gt; test echo \u0026#39;echo $b\u0026gt;file2\u0026#39; \u0026gt;\u0026gt; test echo \u0026#39;echo save a to ./file3\u0026#39; \u0026gt;\u0026gt; test echo \u0026#39;echo $a\u0026gt;file3\u0026#39; \u0026gt;\u0026gt; test echo \u0026#39;echo save file1 file2 file3 to file4\u0026#39; \u0026gt;\u0026gt; test echo \u0026#39;cat file1\u0026gt;file4\u0026#39; \u0026gt;\u0026gt; test echo \u0026#39;cat file2\u0026gt;\u0026gt;file4\u0026#39; \u0026gt;\u0026gt; test echo \u0026#39;cat file3\u0026gt;\u0026gt;file4\u0026#39; \u0026gt;\u0026gt; test echo \u0026#39;echo save file4 to ./result\u0026#39; \u0026gt;\u0026gt; test echo \u0026#39;cat file4\u0026gt;\u0026gt;result\u0026#39; \u0026gt;\u0026gt; test # test echo Shell Start... # 输出初始化提示 echo set a = 1 a=1 # 设置变量a=1 echo set b = 2 b=2 # 设置变量b=2 echo set c = a+b c=$[$a+$b] # 执行算术运算c=a+b=1+2=3 echo c = $c # 输出计算结果 echo save c to ./file1 echo $c\u0026gt;file1 # 将c的值写入file1 echo save b to ./file2 echo $b\u0026gt;file2 # 将b的值写入file2 echo save a to ./file3 echo $a\u0026gt;file3 # 将a的值写入file3 echo save file1 file2 file3 to file4 cat file1\u0026gt;file4 # 创建file4并写入file1内容 cat file2\u0026gt;\u0026gt;file4 # 追加file2内容 cat file3\u0026gt;\u0026gt;file4 # 追加file3内容 echo save file4 to ./result cat file4\u0026gt;\u0026gt;result # 最终结果是c,b,a的值 $ ./test Shell Start... set a = 1 set b = 2 set c = a+b c = 3 save c to ./file1 save b to ./file2 save a to ./file3 save file1 file2 file3 to file4 save file4 to ./result $ cat result 3 2 1 反引号会先执行命令替换，改变重定向行为。\necho echo Shell Start echo `echo Shell Start` 输出字符串echo Shell Start 先执行命令echo Shell Start再输出该命令的执行结果Shell Start echo echo $c\u0026gt;file1 echo `echo $c\u0026gt;file1` 将字符串echo 3写入file1 先将3写入file1，再输出写入的执行结果（为空），即终端无输出 二、难点分析与实验体会 本次实验的主要难点在于工具链的命令行参数和shell编程掌握不够熟练。\n难点1：sed的用法 为实现在 hello_os.sh 所处的目录新建一个名为BBB的文件，其内容为 AAA文件的第8、32、128、512、1024行的内容提取，构造sed命令\nsed -n \u0026#39;8p;32p;128p;512p;1024p\u0026#39; \u0026#34;$1\u0026#34; \u0026gt; \u0026#34;$2\u0026#34; 难点2：awk行号提取 grep -n \u0026#34;$2\u0026#34; ./\u0026#34;$1\u0026#34; | awk -F \u0026#39;:\u0026#39; \u0026#39;{print $1}\u0026#39; \u0026gt; ./\u0026#34;$3\u0026#34; 难点3：GCC与Make的特殊用法 # 多目录编译示例 gcc -I ../include -c fibo.c -o fibo.o # 调用子目录make命令示例 make -C code fibo.o 三、原创说明 在本次实验中，对工具链的使用参考了官方manual和--help参数。\n在Neovim和LazyVim的安装与配置中，参考了如何在Ubuntu上安装最新版本的Neovim并快速配置_ubuntu安装neovim-CSDN博客 使用 git log 命令时，在 commit 标识符后的一长串数字和字母组成的字符串\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","permalink":"https://oNya685.github.io/posts/buaa/os/lab-0-report/","summary":"\u003ch1 id=\"一思考题\"\u003e一、思考题\u003c/h1\u003e\n\u003ch2 id=\"thinking-01\"\u003eThinking 0.1\u003c/h2\u003e\n\u003cblockquote\u003e\n\u003cp\u003e思考下列有关Git的问题：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e在前述已初始化的~/learnGit 目录下，创建一个名为README.txt的文件。执行命令git status \u0026gt; Untracked.txt（其中的 \u0026gt; 为输出重定向，我们将在0.6.3中详细介绍）。\u003c/li\u003e\n\u003cli\u003e在README.txt 文件中添加任意文件内容，然后使用add命令，再执行命令git status \u0026gt; Stage.txt。\u003c/li\u003e\n\u003cli\u003e提交README.txt，并在提交说明里写入自己的学号。\u003c/li\u003e\n\u003cli\u003e执行命令cat Untracked.txt 和cat Stage.txt，对比两次运行的结果，体会README.txt两次所处位置的不同。\u003c/li\u003e\n\u003cli\u003e修改README.txt 文件，再执行命令git status \u0026gt; Modified.txt。\u003c/li\u003e\n\u003cli\u003e执行命令cat Modified.txt，观察其结果和第一次执行add命令之前的status是否一样，并思考原因。\u003c/li\u003e\n\u003c/ul\u003e\u003c/blockquote\u003e\n\u003chr\u003e\n\u003ch3 id=\"1-untrackedtxt\"\u003e1. Untracked.txt\u003c/h3\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e$  cat Untracked.txt\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e位于分支 master\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e未跟踪的文件:\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  （使用 \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;git add \u0026lt;文件\u0026gt;...\u0026#34;\u003c/span\u003e 以包含要提交的内容）\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        README.txt\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        Untracked.txt\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e提交为空，但是存在尚未跟踪的文件（使用 \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;git add\u0026#34;\u003c/span\u003e 建立跟踪）\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e新建了\u003ccode\u003eREADME.txt\u003c/code\u003e文件，处于Untracked状态。\u003c/p\u003e","title":"[BUAA-OS] Lab 0 实验报告"},{"content":"点此查看作业源文件 1.什么是多道程序设计？多道程序设计与分时系统的区别是什么？ 多道程序设计技术，是指允许多个程序同时进⼊内存并运⾏。即同时把多个程序放⼊内存中，并允许它们交替在CPU中运⾏，共享系统中的各种硬、软件资源，当⼀道程序因I/O请求⽽暂停运⾏时，CPU便⽴即转去运⾏另⼀道程序。多道程序设计技术提⾼了CPU、I/O设备和内存的利⽤率，从⽽提⾼了整个系统的资源利⽤率和系统吞吐量，最终提⾼了整个系统的效率。\n多道程序设计与分时系统的区别在于：多道程序设计主要关注的是如何让多个程序在内存中同时存在并交替执⾏，以提⾼资源利⽤率。分时系统则是在多道程序设计的基础上进⼀步发展，它不仅允许多个程序并发执⾏，还通过时间⽚轮转的⽅式为每个⽤户分配CPU时间，使得多个⽤户可以⼏乎同时使⽤计算机，提供交互式服务。\n2.什么原因推动了操作系统从批处理发展到多道程序，进而发展到分时系统？ 批处理系统的运⾏效率被低速I/O设备限制，CPU空闲时间多，利⽤率低，因此发展出多道程序系统；\n多道程序系统平均周转时间⻓，不能提供交互作⽤能⼒，因此发展出允许多个⽤户共享计算机，多个程序分时共享硬、软件资源的分时系统。\n3.什么是陷阱？与中断的区别是什么？什么是系统调用？ 陷阱是⼀种同步异常，是程序内部有意设置的某⼀特定指令执⾏的结果，例如系统调⽤。陷阱是程序执⾏过程中预期的⾏为，可以复现，⽤于请求操作系统提供服务等。\n中断是⼀种异步异常，通常由外部事件（I/O设备、处理器时钟或定时器）触发，与处理器正在执⾏的内容⽆关。中断是不可预测的，⽤于处理外部事件。\n系统调⽤是⽤户程序与操作系统内核之间的接⼝，允许⽤户程序请求操作系统提供的服务。系统调⽤本质上是⼀种同步异常，或陷阱，⽤于安全地进⼊内核模式并执⾏特权操作。\n4.判断：可移植的操作系统可以从一个系统架构移植到另外一个系统架构而无需修改。 错误。不同系统架构之间存在指令集差异、内存管理方式不同、硬件寄存器配置不一致等根本性区别，操作系统必须针对这些硬件特性进行调整。\n(1)请解释为什么构建完全可移植的OS是不可能的？ 不同硬件架构的指令集、总线设计和CPU字长等存在差异，操作系统必须依赖硬件相关代码，⽆法完全通⽤。\n(2)如果需要你设计一个高度可移植的OS，那么请描述你需要设计的两个层次？ 高度可移植的操作系统由机器相关层和机器无关层组成。机器无关层只需实现一次即可。\n机器相关层处理硬件的具体特性，必须针对每个架构单独实现。该层为机器无关层提供统一的接口。为实现高度可移植性，机器相关层的规模应尽可能最小化。\n5.在设计操作系统时，一些设计指标是相互矛盾的，例如资源利用率、吞吐量、处理时间、健壮性等。请给出一对相互矛盾的设计实例。 资源利⽤率与响应时间。\n资源利⽤率⾼意味着尽可能多地利⽤系统资源，但可能导致频繁的切换和复杂的调度策略，从⽽增加响应时间。响应时间短要求操作系统能够快速响应⽤户请求，可能保留更多的资源⽤于即时响应，导致资源利⽤率下降。\n6.一个计算机系统有输入机一台、打印机两台，现有二道程序同时投入运行，且程序A先开始运行，程序B后运行。程序A的运行轨迹为：计算50ms，打印信息100ms，再计算50ms，打印信息100ms，结束。程序B运行的轨迹为：计算50ms，输入数据80ms，再计算100ms，结束。要求： (1)用图画出这二道程序并发执行时的工作情况。 (2)说明在二道程序运行时，CPU有无空闲等待？若有，在哪段时间内等待？为什么会空闲等待？ 有。在100ms~150ms，程序A在打印信息，程序B在输入数据，故CPU处于空闲等待。\n(3)程序A、B运行时有无等待现象？在什么时候会发生等待现象？ 程序A没有，程序B有。\n在180ms~200ms，程序B完成了输入数据，在等待CPU空闲，而程序A占用了处理器，正在进行计算，故程序B等待了20ms。\n","permalink":"https://oNya685.github.io/posts/buaa/os/homework-1/","summary":"\u003cp\u003e\u003cstrong\u003e\u003ca href=\"%e4%bd%9c%e4%b8%9a1.pdf\" target=\"_blank\"\u003e点此查看作业源文件\u003c/a\u003e\n\u003c/strong\u003e\u003c/p\u003e\n\u003ch1 id=\"1什么是多道程序设计多道程序设计与分时系统的区别是什么\"\u003e1.什么是多道程序设计？多道程序设计与分时系统的区别是什么？\u003c/h1\u003e\n\u003cp\u003e多道程序设计技术，是指允许多个程序同时进⼊内存并运⾏。即同时把多个程序放⼊内存中，并允许它们交替在CPU中运⾏，共享系统中的各种硬、软件资源，当⼀道程序因I/O请求⽽暂停运⾏时，CPU便⽴即转去运⾏另⼀道程序。多道程序设计技术提⾼了CPU、I/O设备和内存的利⽤率，从⽽提⾼了整个系统的资源利⽤率和系统吞吐量，最终提⾼了整个系统的效率。\u003c/p\u003e","title":"[BUAA-OS] 理论作业 1"},{"content":"函数调用处理机制 核心思路 实参与形参分离：通过assignment哈希表实现参数映射，实现形参（函数定义时的参数名）与相对实参（调用时传入的具体因子）的对应关系。 递归替换：通过assign方法逐层展开函数调用 终止条件：当递归到初始定义表达式时完成解析 关键实现步骤 数据结构 为函数调用因子引入通过HashMap\u0026lt;String, Factor\u0026gt;实现的新成员变量assignment，并在为语素实现的assign方法中作为传入参数。\n对于FuncCall因子，引入Integer index，FuncDefine，ArrayList\u0026lt;Factor\u0026gt;，用于实现对Expr中的FuncCall因子的完全解析。\npublic class FuncCall extends VarFactor { private final ConstantFactor index; private final FuncDefine define; private final HashMap\u0026lt;BaseVar, Factor\u0026gt; assignment; // 实际参数列表 } 处理流程 通过expr = expr.assign(null)中调用funcCall.define.get(index).assign(assignment).assign(null)，因除FuncCall以外的其他语素有其assign方法，所以将不断递归下降直到funcCall.define.get(1)和funcCall.define.get(0)。此时再递归向下将不再出现FuncCall类，递归结束并逐级返回。从而实现的Expr的去FuncCall流程，以便进行toPoly和simplify。\n初始化调用\nexpr = expr.assign(null); // 通过expr.assign(null)启动替换链条，null参数表示要解析的最上层表达式中的参数为绝对实参 参数替换机制\n// FuncCall.java ExprFactor assign(HashMap\u0026lt;String, Factor\u0026gt; assignment) { return this.define.get(this.index) .assign(this.assignment) // 先应用this.assignment当前层的参数绑定 .assign(assignment); // 再应用外层传入的assignment参数，实现参数作用域的嵌套覆盖 } 递归展开过程\n// 高层调用 → 中间层展开 → 基础层解析 funcCall.assign(null) → funcCall.define.get(index).assign(assignment).assign(null) → ... → funcCall\u0026#39;.define.get(index\u0026#39;).assign(assignment\u0026#39;).assign(assignment).assign(null) → ... → funcCall\u0026#39;\u0026#39;.define.get(index\u0026#39;\u0026#39;).assign(assignment\u0026#39;\u0026#39;).assign(assignment\u0026#39;).assign(assignment).assign(null) → ... → funcCall.define.get(0 | 1).assign... // 初始定义表达式 类方法实现 经assign方法，BaseVar.assign(assignment)返回Factor，PowerFunc.assign(assignment)返回ExprFactor，FuncCall递归调用(Expr)define.get(this.index).assign(this.assignment).assign(assignment)返回ExprFactor，其他语素的assign方法返回同类对象。最终递归返回不含FuncCall的纯Expr，即可施之toPoly方法。\n类名 assign方法行为 返回类型 BaseVar 直接返回对应的含相对实参的Factor Factor PowerFunc 返回参数赋值的ExprFactor ExprFactor FuncCall 递归调用下层定义进行参数替换 ExprFactor 其他因子 返回由自身组成语素.assign()构造的同类对象 同类对象 处理终点 当递归到define.get(0 | 1)时：\n不再包含FuncCall对象，函数调用结构完全消解 所有形参已被实际参数替换 表达式完全展开为基本元素 可安全调用toPoly()进行多项式转换 可进行最终化简simplify() ","permalink":"https://oNya685.github.io/posts/buaa/oo/unit-1/homework-2-function/","summary":"\u003ch1 id=\"函数调用处理机制\"\u003e函数调用处理机制\u003c/h1\u003e\n\u003ch2 id=\"核心思路\"\u003e核心思路\u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003e实参与形参分离\u003c/strong\u003e：通过\u003ccode\u003eassignment\u003c/code\u003e哈希表实现参数映射，实现\u003cstrong\u003e形参\u003c/strong\u003e（函数定义时的参数名）与\u003cstrong\u003e相对实参\u003c/strong\u003e（调用时传入的具体因子）的对应关系。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e递归替换\u003c/strong\u003e：通过\u003ccode\u003eassign\u003c/code\u003e方法逐层展开函数调用\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e终止条件\u003c/strong\u003e：当递归到\u003cstrong\u003e初始定义\u003c/strong\u003e表达式时完成解析\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2 id=\"关键实现步骤\"\u003e关键实现步骤\u003c/h2\u003e\n\u003ch3 id=\"数据结构\"\u003e数据结构\u003c/h3\u003e\n\u003cp\u003e为函数调用因子引入通过\u003ccode\u003eHashMap\u0026lt;String, Factor\u0026gt;\u003c/code\u003e实现的新成员变量\u003ccode\u003eassignment\u003c/code\u003e，并在为语素实现的\u003ccode\u003eassign\u003c/code\u003e方法中作为传入参数。\u003c/p\u003e","title":"[BUAA-OO] Unit 1 递归函数调用的解析与计算"}]