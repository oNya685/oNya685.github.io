[{"content":"一、思考题 Thinking 2.1 请根据上述说明，回答问题：在编写的 C 程序中，指针变量中存储的地址被视为虚拟地址，还是物理地址？MIPS 汇编程序中 lw和sw 指令使用的地址被视为虚拟地址，还是物理地址？\n都是虚拟地址。本质都是翻译为含虚拟地址的机器码，交由CPU进行访存。\nThinking 2.2 请思考下述两个问题：\n从可重用性的角度，阐述用宏来实现链表的好处。 查看实验环境中的/usr/include/sys/queue.h，了解其中单向链表与循环链表的实现，比较它们与本实验中使用的双向链表，分析三者在插入与删除操作上的性能差异。 通过宏定义，该链表实现了对于各种类型的可重用性。 上机后补充：例如MBlock与其field（mb_link），可以直接使用该链表以及操作链表的宏（例如LIST_INSERT_AFTER与LIST_REMOVE）。 比较单向链表、循环链表与双向链表： 操作 单向链表 循环链表 双向链表 插入 性能相似，但插入到尾结点需要完整遍历链表 性能相似，但插入到尾结点更快 性能相似，但插入到尾结点需要完整遍历链表 删除 需要找上一结点的位置，O(n) 性能与双向链表相似 性能与循环链表相似 Thinking 2.3 请阅读include/queue.h以及include/pmap.h,将Page_list的结构梳理清楚，选择正确的展开结构。\n选C。\n首先，le_prev是指向前继结点的后继指针的指针，类型是struct Type **，排除A。\n其次，lh_first是指向链表首结点的指针，类型是struct Type *，排除B。\nThinking 2.4 请思考下面两个问题：\n请阅读上面有关TLB的描述，从虚拟内存和多进程操作系统的实现角度，阐述ASID的必要性。 请阅读 MIPS 4Kc 文档《MIPS32® 4K™ Processor Core Family Software User’s Manual》的 Section 3.3.1 与 Section 3.4，结合 ASID 段的位数，说明 4Kc 中可容纳不同的地址空间的最大数量。 某一虚拟地址在不同地址空间中可以被映射到不同物理地址，所以需要ASID以确定地址空间。\n可容纳最多64个不同的地址空间。\nInstead, the OS assigns a 6-bit unique code to each task’s distinct address space. Since the ASID is only 6 bits long, OS software does have to lend a hand if there are ever more than 64 address spaces in concurrent use; but it probably won’t happen too often. Thinking 2.5 请回答下述三个问题：\ntlb_invalidate和tlb_out的调用关系？ 请用一句话概括tlb_invalidate的作用。 逐行解释tlb_out中的汇编代码。 tlb_invalidate调用了tlb_out。 调用tlb_invalidate可以将该地址与虚拟地址的映射表项从TLB中清除。 tlb_out：用于清除指定虚拟地址对应的TLB表项。通过先保存当前ENTRYHI值，然后设置新的ENTRYHI进行TLB探测，找到对应表项后通过写入空值实现删除，最后恢复原始ENTRYHI值。 LEAF(tlb_out) // 定义名为tlb_out的叶子函数 .set noreorder // 禁止汇编器重新排列指令顺序 mfc0 t0, CP0_ENTRYHI // 将协处理器CP0的ENTRYHI寄存器值保存到t0 mtc0 a0, CP0_ENTRYHI // 将参数寄存器a0的值写入CP0的ENTRYHI寄存器 nop // 空操作，确保mtc0操作完成 /* Step 1: Use \u0026#39;tlbp\u0026#39; to probe TLB entry */ /* Exercise 2.8: Your code here. (1/2) */ tlbp // TLB探测指令，根据ENTRYHI查找匹配的TLB条目 nop // 保证tlbp指令完成 /* Step 2: Fetch the probe result from CP0.Index */ mfc0 t1, CP0_INDEX // 将CP0的INDEX寄存器值读取到t1 .set reorder // 允许汇编器重新排列指令顺序 bltz t1, NO_SUCH_ENTRY // 如果未找到该ENTRY，跳转到NO_SUCH_ENTRY .set noreorder // 再次禁止指令重排 mtc0 zero, CP0_ENTRYHI // 清零CP0的ENTRYHI寄存器 mtc0 zero, CP0_ENTRYLO0 // 清零CP0的ENTRYLO0寄存器 mtc0 zero, CP0_ENTRYLO1 // 清零CP0的ENTRYLO1寄存器 nop // 保证寄存器写入操作完成 /* Step 3: Use \u0026#39;tlbwi\u0026#39; to write CP0.EntryHi/Lo into TLB at CP0.Index */ /* Exercise 2.8: Your code here. (2/2) */ tlbwi // 将当前EntryHi/EntryLo写入TLB表项，删除该条目 .set reorder // 恢复指令重排 NO_SUCH_ENTRY: // 未找到对应TLB条目时的标签 mtc0 t0, CP0_ENTRYHI // 恢复原始ENTRYHI寄存器值 j ra // 函数返回 END(tlb_out) // 函数结束 Thinking 2.6 请结合 Lab2 开始的 CPU 访存流程与下图中的 Lab2 用户函数部分，尝试将函数调用与CPU访存流程对应起来，思考函数调用与CPU访存流程的关系。\n在 Lab2（以及后续实验）中，4Kc CPU 的访存过程可以概括为以下几个关键步骤\n当 CPU 执行一条访存相关的指令（包含取指令、读数据、写数据）时，会把虚拟地址送入 MMU。 MMU 会首先在 TLB 中查找该虚拟地址是否有对应的物理地址映射。 若命中（TLB Hit），CPU 即可直接得知该虚拟地址对应的物理地址，并进行后续的读写缓存或内存操作。 若未命中（TLB Miss），CPU 会触发异常，进入内核执行 TLB refill / page fault 处理流程（视情况而定），由操作系统的异常/中断处理例程负责查找该虚拟地址应对应的物理地址、分配物理页、更新 TLB。 当映射关系建立后，CPU 可以“拿到”正确的物理地址并进行实际的内存（或外设寄存器）读写操作。 在这个过程中，所看到的「kuseg、kseg0、kseg1」等地址段的区别，决定了 CPU 是否直接对高地址位清零映射（无缓存/有缓存）或者需要通过 TLB。对于用户态的地址（kuseg，0x00000000~0x7fffffff），一定要通过 TLB。\n在 Lab2 中，当我们调用函数时，背后的硬件过程正是 CPU 发出虚拟地址、经 TLB 查表或异常处理、进而映射到物理地址并访问内存的流程。函数调用是软件层面分配、管理地址空间的逻辑，而 CPU 访存流程是硬件层面真正将指令和数据从内存取出、写入的机制；两者一一对应、紧密耦合。通过把它们结合起来，我们就能全面理解操作系统与用户态程序在地址空间管理上的工作原理。\nThinking 2.7 从下述三个问题中任选其一回答：\n简单了解并叙述X86体系结构中的内存管理机制，比较X86和MIPS 在内存管理上的区别。 简单了解并叙述RISC-V 中的内存管理机制，比较RISC-V 与 MIPS 在内存管理上的区别。 简单了解并叙述LoongArch 中的内存管理机制，比较 LoongArch 与 MIPS 在内存管理上的区别。 X86 与 MIPS 内存管理的主要区别\n分段机制与固定地址区间 X86：\n传统上依靠分段来实现内存保护和地址转换，虽然现代操作系统多采用扁平模型，但分段概念依然存在，并且在保护模式下提供了多级特权和动态调整段基址的能力。 MIPS：\n使用固定的地址区间划分（如kuseg、kseg0、kseg1），没有灵活的分段机制，内核与用户空间的划分由硬件地址范围直接确定，整体设计更加简单。 分页管理方式 X86：\n采用硬件支持的多级页表结构，地址转换过程由硬件直接完成（结合 TLB 缓存），在现代 x86-64 中使用 4 级或更多级页表，同时支持 PAE 和 NX 等扩展特性。 MIPS：\n通常依赖软件管理的 TLB，当发生 TLB miss 时，通过异常处理由操作系统完成页表查找和 TLB 填充，其页表结构也较为灵活，但整体在硬件自动化管理程度上较 X86 要简单。 TLB 设计 X86：\nTLB 作为硬件缓存，通常与分页机制紧密结合，自动维护地址映射缓存，减少页表查找延迟。 MIPS：\nTLB 由软件管理，需要操作系统在 TLB miss 异常处理程序中主动维护，虽然这种设计在一定程度上降低了硬件复杂性，但对操作系统的设计与调度要求更高。 二、难点分析与实验体会 1. 链表宏的理解与使用 链表中大量指针，指针的指针，混杂在一起，较难理解其具体含义。经过struct Page链表的阅读及补全后初步理解链表宏的使用流程与传参细节。\n2. 二级页表的实现 经过实验代码，我们能发现二级页表的页表项其实是u_long类型，由页框号与有效位组成。通过这一类型的实现有一些反直觉，在理解其为字对齐后便理解了一些实现细节。\n三、原创说明 参考资料：\nMIPS32® 4K™ Processor Core Family Software User’s Manual 全网超详细解析！X86/X64处理器体系结构及寻址模式 - 知乎 X86内存管理机制\u0026ndash;分段机制详析_x86 为什么要这么多段寄存器-CSDN博客 ","permalink":"https://oNya685.github.io/posts/buaa/os/lab-2-report/","summary":"\u003ch1 id=\"一思考题\"\u003e一、思考题\u003c/h1\u003e\n\u003ch2 id=\"thinking-21\"\u003eThinking 2.1\u003c/h2\u003e\n\u003cblockquote\u003e\n\u003cp\u003e请根据上述说明，回答问题：在编写的 C 程序中，指针变量中存储的地址被视为虚拟地址，还是物理地址？MIPS 汇编程序中 lw和sw 指令使用的地址被视为虚拟地址，还是物理地址？\u003c/p\u003e","title":"[BUAA-OS] Lab 2 实验报告"},{"content":"点此查看作业源文件 第一题 （1）请问进程整个的地址空间有多少字节？一页有多少字节？ $$ 进程整个的地址空间 = 2^{32}B = 4GB $$$$一页有 2^{12}B = 4KB$$（2）一个进程如果从 0x80000000 开始映射 4MB 大小页表空间，求第一级页表（页目录）的起始逻辑地址，并指出从哪个逻辑地址可以读出第一级页表（页目录）所在的物理页框号。说明理由。（注意 B 代表字节，一个 32 位地址占 4 字节） 进程页表空间映射起始地址为0x80000000，故页目录起始逻辑地址为0x80000000。\n页目录自映射，其页框号存在自身的首个页目录项中。因此访问页目录起始逻辑地址0x80000000可以读取页目录所在的物理页框号。\n（3）如果当前进程的页目录物理基地址、页目录和相应页表内容如图下所示，请描述访问以下逻辑地址时系统进行地址转换的过程，如可行，给出最终访存读取到的数据。逻辑地址：0x0、0x00803004、0x00402001 访问0x0： | 0000 0000 00 | 00 0000 0000 | 0000 0000 0000 | 找页目录第0项 -\u0026gt; 页表项内容：00000 | 000 缺页异常 访问0x00803004： | 0000 0000 10 | 00 0000 0011 | 0000 0000 0100 | 找页目录第2项 -\u0026gt; 页表项：00005 | 001 页表地址：0x5000，有效 找页表第3项 -\u0026gt; 页表项：00020 | 001 页地址：0x20000 物理地址：0x20000 + 0x004 = 0x20004 读取到的字为0x326001 读取到的数据：0x00（小端序）或0x01（大端序） 访问0x00402001： | 0000 0000 01 | 00 0000 0010 | 0000 0000 0001 | 找页目录第1项 -\u0026gt; 页表项内容：00001 | 001 页表地址：0x1000，有效 找页表第2项 -\u0026gt; 页表项：00005 | 001 页地址：0x5000 物理地址：0x5000 + 0x001 = 0x5001 读取到的字为0x0 读取到的数据：0x00 （4）要想访问物理地址 0x326028，需要使用哪个逻辑地址？ 页内偏移：0x028 页框号：0x326，出现在0x20000 + 1 * 0x4，所以二级页表号：0x1 页框号：0x20，出现在0x1000 + 3 * 0x4，所以一级页表号：0x3 逻辑地址：| 0000 0000 11 | 00 0000 0001 | 0000 0010 1000 | 即：0x00c01028 第二题 （1）Load [0x00001022] 页目录号：0x000 访问0x0020 0000 + 4 * 0x000 = 0x0020 0000：0x0010 0007 二级页表页框号：0x00100 标志位：0x007，Valid, Read/Write 二级页表号：0x001 访问0x0010 0000 + 4 * 0x001 = 0x0010 0004：0x0000 4067 物理页框号：0x00004 标志位：0x067，Valid, Read/Write 页内偏移量：0x022 访问0x0000 4000 + 0x022 = 0x0000 4022：0x20 成功：0x20 （2）Store [0x00C07222] 页目录号：0x003 访问0x0020 0000 + 4 * 0x003 = 0x0020 000C：0x0010 3007 二级页表页框号：0x00103 标志位：0x007，Valid, Read/Write 二级页表号：0x007 访问0x0010 3000 + 4 * 0x007 = 0x0010 301C：0xEEFF 0001 标志位：0x001，Valid, Read Only 页内偏移量：0x222 Error: Read Only (3) Store [0x00C005BF] 页目录号：0x003 访问0x0020 0000 + 4 * 0x003 = 0x0020 000C：0x0010 3007 二级页表页框号：0x00103 标志位：0x007，Valid, Read/Write 二级页表号：0x000 访问0x0010 3000 + 4 * 0x000 = 0x0010 3000：0x1122 0067 物理页框号：0x11220 标志位：0x067，Valid, Read/Write 页内偏移量：0x5BF 写入0x1122 0000 + 0x067 = 0x1122 0067 OK: 0x1122 0067 （4）Load [0x00003013] 页目录号：0x000 访问0x0020 0000 + 4 * 0x000 = 0x0020 0000：0x0010 0007 二级页表页框号：0x00100 标志位：0x007，Valid, Read/Write 二级页表号：0x003 访问0x0010 0000 + 4 * 0x003 = 0x0010 000C：0x0000 4007 物理页框号：0x00004 标志位：0x007，Valid, Read/Write 页内偏移量：0x013 访问0x0000 4000 + 0x013 = 0x0000 4013：0x19 成功：0x19 （5）Load [0xFF80078F] 页目录号：0x3FE 访问0x0020 0000 + 4 * 0x3FE = 0x0020 0FF8：0x001F E007 二级页表页框号：0x001FE 标志位：0x007，Valid, Read/Write 二级页表号：0x000 访问0x001F E000 + 4 * 0x000 = 0x001F E000：0x0415 0000 标志位：0x000，Invalid 页内偏移量：0x78F Error: Invalid （6）Load [0xFFFFF005] 页目录号：0x3FF 访问0x0020 0000 + 4 * 0x3FF = 0x0020 0FFC：0x001F F007 二级页表页框号：0x001FF 标志位：0x007，Valid, Read/Write 二级页表号：0x3FF 访问0x001F F000 + 4 * 0x3FF = 0x001F FFFC：0x0010 3067 物理页框号：0x00103 标志位：0x067，Valid, Read/Write 页内偏移量：0x005 访问0x0010 3000 + 0x005 = 0x0010 3005：0x66 成功：0x66 综上所述：\n指令 结果 Load [0x00001022] 0x20 Store [0x00C07222] Error Store [0x00C005BF] OK Load [0x00003013] 0x19 Load [0xFF80078F] Error Load [0xFFFFF005] 0x66 ","permalink":"https://oNya685.github.io/posts/buaa/os/homework-3/","summary":"\u003cp\u003e\u003cstrong\u003e\u003ca href=\"%e4%bd%9c%e4%b8%9a3.pdf\" target=\"_blank\"\u003e点此查看作业源文件\u003c/a\u003e\n\u003c/strong\u003e\u003c/p\u003e\n\u003ch1 id=\"第一题\"\u003e第一题\u003c/h1\u003e\n\u003ch2 id=\"1请问进程整个的地址空间有多少字节一页有多少字节\"\u003e（1）请问进程整个的地址空间有多少字节？一页有多少字节？\u003c/h2\u003e\n$$ 进程整个的地址空间 = 2^{32}B = 4GB $$$$一页有 2^{12}B = 4KB$$\u003ch2 id=\"2一个进程如果从-0x80000000-开始映射-4mb-大小页表空间求第一级页表页目录的起始逻辑地址并指出从哪个逻辑地址可以读出第一级页表页目录所在的物理页框号说明理由注意-b-代表字节一个-32-位地址占-4-字节\"\u003e（2）一个进程如果从 0x80000000 开始映射 4MB 大小页表空间，求第一级页表（页目录）的起始逻辑地址，并指出从哪个逻辑地址可以读出第一级页表（页目录）所在的物理页框号。说明理由。（注意 B 代表字节，一个 32 位地址占 4 字节）\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e进程页表空间映射起始地址为\u003ccode\u003e0x80000000\u003c/code\u003e，故页目录起始逻辑地址为\u003ccode\u003e0x80000000\u003c/code\u003e。\u003c/p\u003e","title":"[BUAA-OS] 理论作业 3"},{"content":"点此查看作业源文件 1. 动态内存分配需要对内存分区进行管理，一般使用位图和空闲链表两种方法。128MB的内存以n字节为单元分配，对于链表，假设内存中数据段和空闲区交替排列，长度均为64KB。并假设链表中的每个节点需要记录32位的内存地址信息、16位长度信息和16位下一节点域信息。这两种方法分别需要多少字节的存储空间？哪种方法更好？ 若使用位图方法： $$单元数 = \\frac{128MB}{nB} = \\frac{2^{27}}{n}块$$$$所需存储空间 = \\frac{2^{27}}{n}b = \\frac{16}{n}MB$$ 若使用空闲链表方法： $$段数=\\frac{128MB}{64KB+64KB} = 2^{10}段$$$$所需存储空间 = 2^{10} \\times (32 + 16 + 16)b = 8KB$$ 哪种方法更好： 当n\u0026lt;2048时，空闲链表所需存储空间更小，空闲链表方法更好； 当n\u0026gt;2048时，位图所需存储空间更小，位图方法更好。 2. 在一个交换系统中，按内存地址排列的空闲区大小是: 10KB、4KB、20KB、18KB、7KB、9KB、12KB和15KB。对于连续的段请求：12KB、10KB、9KB。使用FirstFit、BestFit、WorstFit和NextFit将找出哪些空闲区？ 段请求 FirstFit BestFit WorstFit NextFit 12KB 20KB 12KB 20KB 20KB 10KB 10KB 10KB 18KB 18KB 9KB 18KB 9KB 15KB 9KB 3. 解释逻辑地址、物理地址、地址映射，并举例说明。 逻辑地址（Logical Address）： 逻辑地址是程序运行时由 CPU 生成的地址，也称为虚拟地址。用户进程只能访问逻辑地址，不能直接访问物理内存。\n例如某程序访问地址 0x1234，但该地址只是进程的逻辑地址空间中的一部分。\n物理地址（Physical Address）：\n物理地址是实际存在于内存（RAM）中的地址，由操作系统和硬件管理。\n例子： 逻辑地址 0x1234 可能被映射到物理内存的 0xABCD1234。\n地址映射（Address Mapping）：\n地址映射是逻辑地址到物理地址的转换过程，通常由MMU通过分页、分段、段页结合等方式完成。 例子： 在分页系统中，逻辑地址 0x1234 可能属于页号2，页内偏移 0x034，MMU 通过页表找到物理页框5，映射后的物理地址为 0x5034。\n4. 解释页式（段式）存储管理中为什么要设置页（段）表和快表，简述页式（段式）地址转换过程。 为什么要设置页（段）表和快表\n页表（段表）：用于记录逻辑地址到物理地址的映射关系，存储完整的映射信息，保证进程可以正确访问物理内存。 快表：是一种高速缓存，用于存储最近访问的页（段）表项，加速地址转换，提高地址转换效率，减少访问内存的开销。 页式存储管理的地址转换过程\nCPU 生成逻辑地址，包含页号和页内偏移。 查询 TLB，如果页号在 TLB 中，则直接获取对应的物理页框号，得到物理地址。 若TLB 未命中（缺页表项），需要访问页表，通过页号查找对应的物理页框号。 组合物理页框号和页内偏移，形成物理地址，访问数据。 更新 TLB（如果 TLB 未命中，则将新查找的页表项加入 TLB）。 段式存储管理的地址转换过程\nCPU 生成逻辑地址，包含段号和段内偏移。 查询 TLB，如果段号在 TLB 中，则直接获取段的基址，计算物理地址。 若TLB 未命中，访问段表，查找段号对应的段基址和段界限。 检查越界，如果段内偏移\u0026gt;段界限，发生段越界异常，否则继续计算。 物理地址 = 段基址 + 段内偏移，然后访问数据。 更新 TLB（如果 TLB 未命中，则将新的段表项加入 TLB）。 5. 叙述缺页中断的处理流程。 缺页中断发生在进程访问的页面不在内存时，系统需要从外存加载该页面到内存。处理流程如下：\n产生缺页中断\n进程访问某个逻辑地址，CPU 通过页表查找对应的物理页框。 如果该页表项无效（页不在内存），则触发缺页中断。 保存进程状态\nCPU 保存当前进程的上下文，包括程序计数器（PC）和寄存器等，确保中断后能恢复执行。 操作系统处理缺页\n查找页表：操作系统检查该页是否有效。 有效但不在内存 → 继续处理。 非法访问 → 触发异常（如段错误），终止进程。 选择物理页框： 若有空闲页框，直接使用。 若内存已满，使用页面置换算法（如 FIFO、LRU）淘汰一个旧页面。 读取页面到内存\n从外存（如磁盘）读取所需页面，拷贝到选定的物理页框。 更新页表和 TLB\n修改页表项，标记该页已在内存，并更新页框号。 若该页表项在 TLB（快表）中，需更新或清除 TLB 旧项，保证地址转换正确。 恢复进程执行\n恢复进程上下文，重新执行触发缺页的指令。 由于该页已加载到内存，不会再次触发缺页中断。 6. 假设一个机器有38位的虚拟地址和32位的物理地址。 (1) 与一级页表相比，多级页表的主要优点是什么？ 空间利用率高。多级页表只在需要时分配低层页表，从而避免为整个虚拟地址空间都预留大量连续的页表空间，节省内存空间。 (2) 如果使用二级页表，页面大小为16KB，每个页表项有4个字节。应该为虚拟地址中的第一级和第二级页表域各分配多少位？ 页面大小为 16KB，即\n$$16\\,\\text{KB} = 16 \\times 1024 = 2^{14}\\,\\text{字节}$$因此页内偏移需要 14 位，虚拟地址结构如下：\n$$\\underbrace{\\text{第一级页表域}}_{x\\,\\text{位}}\\,\\,\\underbrace{\\text{第二级页表域}}_{y\\,\\text{位}}\\,\\,\\underbrace{\\text{页内偏移}}_{14\\,\\text{位}}$$虚拟地址为38位，因此$x + y + 14 = 38位$，所以$x + y = 24,\\text{位}$。\n每个页表项为4B，页表页的大小与页面大小相同，即16KB。一个页表页能容纳的页表项个数为\n$$\\frac{16\\,\\text{KB}}{4\\,\\text{B}} = 4096 = 2^{12}\\,\\text{项}$$因此第二级页表的索引域需要12位，即$y=12$。\n由$x+y=24$可得$x=12$。即：\n$$\\underbrace{\\text{第一级页表域}}_{12\\,\\text{位}}\\,\\,\\underbrace{\\text{第二级页表域}}_{12\\,\\text{位}}\\,\\,\\underbrace{\\text{页内偏移}}_{14\\,\\text{位}}$$7. 假设页面的访问存在一定的周期性循环，但周期之间会随机出现一些页面的访问。例如：0,1,2…,511,431,0,1,2…511,332,0,1,2,…,511等。请思考： (1) LRU、FIFO和Clock算法的效果如何？ 如果物理页框数不足512个，三种算法会发生相同的几乎全部缺页问题。\n(2) 如果有500个页框，能否设计一个优于LRU、FIFO和Clock的算法？ 其中499个页框对应存储0-498页，第500个页框用于置换。\n8. 一个交换系统通过紧缩技术来清理碎片。如果内存碎片和数据区域是随机分配的。而且假设读写32位内存字需要10nsec. 那么如果紧缩128MB的内存需要多久？简单起见，假设第0个字是碎片的一部分而最高位的字包含了有效的数据。 $$128MB=\\frac{128\\times 2^{23}b}{32b/word} = 2^{25}words$$$$T=2^{25}words \\times (10ns/word + 10ns/word) = 6.711\\times 10^8ns = 0.6711s$$需要约$0.6711s$。\n","permalink":"https://oNya685.github.io/posts/buaa/os/homework-2/","summary":"\u003cp\u003e\u003cstrong\u003e\u003ca href=\"%e4%bd%9c%e4%b8%9a2.pdf\" target=\"_blank\"\u003e点此查看作业源文件\u003c/a\u003e\n\u003c/strong\u003e\u003c/p\u003e\n\u003ch1 id=\"1-动态内存分配需要对内存分区进行管理一般使用位图和空闲链表两种方法128mb的内存以n字节为单元分配对于链表假设内存中数据段和空闲区交替排列长度均为64kb并假设链表中的每个节点需要记录32位的内存地址信息16位长度信息和16位下一节点域信息这两种方法分别需要多少字节的存储空间哪种方法更好\"\u003e1. 动态内存分配需要对内存分区进行管理，一般使用位图和空闲链表两种方法。128MB的内存以n字节为单元分配，对于链表，假设内存中数据段和空闲区交替排列，长度均为64KB。并假设链表中的每个节点需要记录32位的内存地址信息、16位长度信息和16位下一节点域信息。这两种方法分别需要多少字节的存储空间？哪种方法更好？\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003e若使用位图方法：\u003c/li\u003e\n\u003c/ul\u003e\n$$单元数 = \\frac{128MB}{nB} = \\frac{2^{27}}{n}块$$$$所需存储空间 = \\frac{2^{27}}{n}b = \\frac{16}{n}MB$$\u003cul\u003e\n\u003cli\u003e若使用空闲链表方法：\u003c/li\u003e\n\u003c/ul\u003e\n$$段数=\\frac{128MB}{64KB+64KB} = 2^{10}段$$$$所需存储空间 = 2^{10} \\times (32 + 16 + 16)b = 8KB$$\u003cul\u003e\n\u003cli\u003e哪种方法更好：\n\u003cul\u003e\n\u003cli\u003e当n\u0026lt;2048时，空闲链表所需存储空间更小，空闲链表方法更好；\u003c/li\u003e\n\u003cli\u003e当n\u0026gt;2048时，位图所需存储空间更小，位图方法更好。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1 id=\"2-在一个交换系统中按内存地址排列的空闲区大小是-10kb4kb20kb18kb7kb9kb12kb和15kb对于连续的段请求12kb10kb9kb使用firstfitbestfitworstfit和nextfit将找出哪些空闲区\"\u003e2. 在一个交换系统中，按内存地址排列的空闲区大小是: 10KB、4KB、20KB、18KB、7KB、9KB、12KB和15KB。对于连续的段请求：12KB、10KB、9KB。使用FirstFit、BestFit、WorstFit和NextFit将找出哪些空闲区？\u003c/h1\u003e\n\u003ctable\u003e\n  \u003cthead\u003e\n      \u003ctr\u003e\n          \u003cth\u003e段请求\u003c/th\u003e\n          \u003cth\u003eFirstFit\u003c/th\u003e\n          \u003cth\u003eBestFit\u003c/th\u003e\n          \u003cth\u003eWorstFit\u003c/th\u003e\n          \u003cth\u003eNextFit\u003c/th\u003e\n      \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e\u003cstrong\u003e12KB\u003c/strong\u003e\u003c/td\u003e\n          \u003ctd\u003e20KB\u003c/td\u003e\n          \u003ctd\u003e12KB\u003c/td\u003e\n          \u003ctd\u003e20KB\u003c/td\u003e\n          \u003ctd\u003e20KB\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e\u003cstrong\u003e10KB\u003c/strong\u003e\u003c/td\u003e\n          \u003ctd\u003e10KB\u003c/td\u003e\n          \u003ctd\u003e10KB\u003c/td\u003e\n          \u003ctd\u003e18KB\u003c/td\u003e\n          \u003ctd\u003e18KB\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e\u003cstrong\u003e9KB\u003c/strong\u003e\u003c/td\u003e\n          \u003ctd\u003e18KB\u003c/td\u003e\n          \u003ctd\u003e9KB\u003c/td\u003e\n          \u003ctd\u003e15KB\u003c/td\u003e\n          \u003ctd\u003e9KB\u003c/td\u003e\n      \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e\n\u003ch1 id=\"3-解释逻辑地址物理地址地址映射并举例说明\"\u003e3. 解释逻辑地址、物理地址、地址映射，并举例说明。\u003c/h1\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e逻辑地址（Logical Address）：\n逻辑地址是程序运行时由 CPU 生成的地址，也称为虚拟地址。用户进程只能访问逻辑地址，不能直接访问物理内存。\u003cbr\u003e\n例如某程序访问地址 \u003ccode\u003e0x1234\u003c/code\u003e，但该地址只是进程的逻辑地址空间中的一部分。\u003c/p\u003e","title":"[BUAA-OS] 理论作业 2"},{"content":"一、思考题 Thinking 1.1 在阅读附录中的编译链接详解以及本章内容后，尝试分别使用实验环境中的原生x86工具链（gcc、ld、readelf、objdump等）和MIPS交叉编译工具链（带有mips-linux-gnu-前缀，如mips-linux-gnu-gcc、mips-linux-gnu-ld），重复其中的编译和解析过程，观察相应的结果，并解释其中向objdump传入的参数的含义。\ngit@23373270:~/test $ gcc -E hello.c \u0026gt; gcc-E.out # gcc-E.out: ...(\u0026lt;stdio.h\u0026gt;的内容) # 2 \u0026#34;hello.c\u0026#34; 2 # 3 \u0026#34;hello.c\u0026#34; int main() { printf(\u0026#34;Hello World!\\n\u0026#34;); return 0; } git@23373270:~/test $ mips-linux-gnu-gcc -E hello.c \u0026gt; mips-gcc-E.out # mips-gcc-E.out: ...(\u0026lt;stdio.h\u0026gt;的内容) # 2 \u0026#34;hello.c\u0026#34; 2 # 3 \u0026#34;hello.c\u0026#34; int main() { printf(\u0026#34;Hello World!\\n\u0026#34;); return 0; } 进行预处理的情况下，两者几乎没有区别。\ngit@23373270:~/test $ gcc -c hello.c git@23373270:~/test $ objdump -DS hello.o \u0026gt; objdump-DS.out # objdump-DS.out: hello.o： 文件格式 elf64-x86-64 Disassembly of section .text: 0000000000000000 \u0026lt;main\u0026gt;: 0: f3 0f 1e fa endbr64 4: 55 push %rbp 5: 48 89 e5 mov %rsp,%rbp 8: 48 8d 05 00 00 00 00 lea 0x0(%rip),%rax # f \u0026lt;main+0xf\u0026gt; f: 48 89 c7 mov %rax,%rdi 12: e8 00 00 00 00 call 17 \u0026lt;main+0x17\u0026gt; 17: b8 00 00 00 00 mov $0x0,%eax 1c: 5d pop %rbp 1d: c3 ret Disassembly of section .rodata: 0000000000000000 \u0026lt;.rodata\u0026gt;: ... Disassembly of section .comment: 0000000000000000 \u0026lt;.comment\u0026gt;: ... Disassembly of section .note.gnu.property: 0000000000000000 \u0026lt;.note.gnu.property\u0026gt;: ... Disassembly of section .eh_frame: 0000000000000000 \u0026lt;.eh_frame\u0026gt;: ... git@23373270:~/test $ mips-linux-gnu-gcc -c hello.c git@23373270:~/test $ mips-linux-gnu-objdump -DS hello.o \u0026gt; mips-objdump-DS.out # mips-objdump-DS.out: hello.o： 文件格式 elf32-tradbigmips Disassembly of section .text: 00000000 \u0026lt;main\u0026gt;: 0: 27bdffe0 addiu sp,sp,-32 4: afbf001c sw ra,28(sp) 8: afbe0018 sw s8,24(sp) c: 03a0f025 move s8,sp 10: 3c1c0000 lui gp,0x0 14: 279c0000 addiu gp,gp,0 18: afbc0010 sw gp,16(sp) 1c: 3c020000 lui v0,0x0 20: 24440000 addiu a0,v0,0 24: 8f820000 lw v0,0(gp) 28: 0040c825 move t9,v0 2c: 0320f809 jalr t9 30: 00000000 nop 34: 8fdc0010 lw gp,16(s8) 38: 00001025 move v0,zero 3c: 03c0e825 move sp,s8 40: 8fbf001c lw ra,28(sp) 44: 8fbe0018 lw s8,24(sp) 48: 27bd0020 addiu sp,sp,32 4c: 03e00008 jr ra 50: 00000000 nop ... Disassembly of section .reginfo: 00000000 \u0026lt;.reginfo\u0026gt;: ... Disassembly of section .MIPS.abiflags: 00000000 \u0026lt;.MIPS.abiflags\u0026gt;: ... Disassembly of section .pdr: 00000000 \u0026lt;.pdr\u0026gt;: ... Disassembly of section .rodata: 00000000 \u0026lt;.rodata\u0026gt;: ... Disassembly of section .comment: 00000000 \u0026lt;.comment\u0026gt;: ... Disassembly of section .gnu.attributes: 00000000 \u0026lt;.gnu.attributes\u0026gt;: ... 只编译不链接，生成目标文件，发现被编译为不同的汇编语言，且分别为64位和32位。\n其中向objdump传入参数-D和-S。\ngit@23373270:~/test $ objdump --help -D, --disassemble-all Display assembler contents of all sections -S, --source Intermix source code with disassembly -D：显示所有段的汇编内容 -S：将源代码与反汇编代码混合显示\nThinking 1.2 思考下述问题：\n尝试使用我们编写的readelf程序，解析之前在target目录下生成的内核ELF文件。 也许你会发现我们编写的readelf程序是不能解析readelf文件本身的，而我们刚才介绍的系统工具readelf则可以解析，这是为什么呢？（提示：尝试使用readelf -h，并阅读tools/readelf目录下的Makefile，观察readelf与hello的不同） git@23373270:~/23373270 (lab1)$ tools/readelf/readelf target/mos 0:0x0 1:0x80020000 2:0x80021930 3:0x80021948 4:0x80021960 5:0x0 6:0x0 7:0x0 8:0x0 9:0x0 10:0x0 11:0x0 12:0x0 13:0x0 14:0x0 15:0x0 16:0x0 17:0x0 18:0x0 git@23373270:~/23373270/tools/readelf (lab1)$ readelf -h readelf ELF 头： Magic： 7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00 类别: ELF64 数据: 2 补码，小端序 (little endian) Version: 1 (current) OS/ABI: UNIX - System V ABI 版本: 0 类型: DYN (Position-Independent Executable file) 系统架构: Advanced Micro Devices X86-64 版本: 0x1 入口点地址： 0x1180 程序头起点： 64 (bytes into file) Start of section headers: 14488 (bytes into file) 标志： 0x0 Size of this header: 64 (bytes) Size of program headers: 56 (bytes) Number of program headers: 13 Size of section headers: 64 (bytes) Number of section headers: 31 Section header string table index: 30 观察tools/readelf/Makefile：\nreadelf: main.o readelf.o $(CC) $^ -o $@ hello: hello.c $(CC) $^ -o $@ -m32 -static -g 区别在于hello为32位程序，readelf是64位程序，且hello的编译有-static修饰，是静态链接的。\nThinking 1.3 在理论课上我们了解到，MIPS体系结构上电时，启动入口地址为0xBFC00000（其实启动入口地址是根据具体型号而定的，由硬件逻辑确定，也有可能不是这个地址，但一定是一个确定的地址），但实验操作系统的内核入口并没有放在上电启动地址，而是按照内存布局图放置。思考为什么这样放置内核还能保证内核入口被正确跳转到？ （提示：思考实验中启动过程的两阶段分别由谁执行。）\n系统能够正确跳转到内核入口在于两阶段启动过程和链接脚本控制：\n启动阶段划分\n阶段一：硬件上电后执行固化在 ROM 中的代码（地址 0xBFC00000） 阶段二：Bootloader 加载操作系统内核到指定内存地址 链接脚本控制（kernel.lds）\n/* * Set the ENTRY point of the program to _start. */ ENTRY(_start) SECTIONS { . = 0x80020000; .text : { *(.text) } ... } 入口地址设置（start.S） #include \u0026lt;asm/asm.h\u0026gt; #include \u0026lt;mmu.h\u0026gt; .text EXPORT(_start) .set at .set reorder /* Lab 1 Key Code \u0026#34;enter-kernel\u0026#34; */ /* clear .bss segment */ la v0, bss_start la v1, bss_end ... j mips_init 实现原理：\nBootloader 将内核镜像加载到链接脚本指定的内存地址（0x80020000） 通过ENTRY(_start)指定内核入口符号 汇编代码中 _start 符号通过绝对跳转指令（j mips_init）转移到内核主函数 二、难点分析与实验体会 1. ELF文件 对ELF文件的概念缺少理解，写完readelf实际使用后才理解其含义。\n三、原创说明 本以为是readelf在运行时无法读取自己，是因为自己正在运行导致的无法读取。在与赵德祥同学讨论后才注意到readelf与hello在64位和32位上的区别，在此致谢。\n","permalink":"https://oNya685.github.io/posts/buaa/os/lab-1-report/","summary":"\u003ch1 id=\"一思考题\"\u003e一、思考题\u003c/h1\u003e\n\u003ch2 id=\"thinking-11\"\u003eThinking 1.1\u003c/h2\u003e\n\u003cblockquote\u003e\n\u003cp\u003e在阅读附录中的编译链接详解以及本章内容后，尝试分别使用实验环境中的原生x86工具链（gcc、ld、readelf、objdump等）和MIPS交叉编译工具链（带有mips-linux-gnu-前缀，如mips-linux-gnu-gcc、mips-linux-gnu-ld），重复其中的编译和解析过程，观察相应的结果，并解释其中向objdump传入的参数的含义。\u003c/p\u003e","title":"[BUAA-OS] Lab 1 实验报告"},{"content":"架构简介 在本单元中，作业要求我们对提供了形式化表述的复杂表达式进行解析和化简，并要求尽可能简短的输出以度量性能分数。\n而经过三次作业迭代（其中包含一次重构），最终架构设计图如下：\n核心处理部分在于递归解析模块的两个递归，在图中具体表现为两个圈。接下来介绍和分析各模块的结构。\n主线处理 本模块是整个项目的主体部分，其中箭头含义表示流程顺序，不代表类的继承关系。主要流程呈现为main方法：\nString input = scanner.nextLine(); // 读入 Lexer lexer = new Lexer(input.replaceAll(\u0026#34; \u0026#34;, \u0026#34;\u0026#34;).replaceAll(\u0026#34;\\t\u0026#34;, \u0026#34;\u0026#34;)); // 词法解析 Parser parser = new Parser(lexer); // 传入Tokens System.out.println(parser .parseExpr() // 语法解析 .assign(null) // 赋值处理函数调用 .toPoly() // 计算化简 .Print() // 构造StringBuilder .toString()); // 输出结果 这样类似流水线的设计的优点是显而易见的，我们只需写好每一模块，封装成黑盒，确保每一部分的程序正确性，就可以完整实现所需功能。\n然而，见上面整体图可以看出，除了实现核心功能的解析模块，其余部分的耦合度其实是偏高的。\n我们会发现，Lexer, Parser, Poly这几个在主线中实现了相当一部分功能的类，因为把大量的重复性功能藏在一个类甚至一个方法内部实现（例如Lexer的大量if-else出现了控制分支数目大的问题），出现了耦合度过高、可读性差的问题。\n举例来说，我们可以分析这个只由两个类实现计算、化简、简化功能的模块：\n计算化简 这个模块内部实现了过多功能，方法个数多，方法规模大，只因它们都涉及到用于存储化简后输出结果的类——Poly（多项式）和Mono（单项式）——这就导致了这一部分难读、难拆、难拓展。\n递归解析 而与之相对的，由于有先导课程的最后一次作业的架构作参考，这个采用递归下降法解析和存储的模块有相当良好的可拓展性和低耦合度。\n这一模块的度量值相当良好，故省略去分析。这一部分的递归主要在于\nExpr - Term - \u0026lt;Factor\u0026gt; ExprFactor - Expr （见橙色箭头）形成的环，该递归改编自先导课程作业代码。 Expr - Term - \u0026lt;Factor\u0026gt; \u0026lt;VarFactor\u0026gt; FuncCall - \u0026lt;FuncDefine.exprs\u0026gt; Expr 。这一递归赋值处理函数调用的思路详见我在第二次作业中的讨论发帖 ，当然，在非校园网环境下，你也可以从此获取 。这一设计有极好的可拓展性，我们将在下一节进一步讨论。 迭代成型 第一次作业 通过采用先导课的递归下降设计，第一次作业的难点就主要在于计算与化简的部分了。此时我们埋下了直接导致需要重构的第一个雷，对于幂函数的处理，我没有完全参照形式化表述的思路，而是单独设计了一个类来表示幂函数，并于计算时再具体展开。\n第二次作业 重构：形式化表述 重构前后的复杂度其实近似，故省去分析，但值得注意的是前后的架构设计：\n其实都很明了，但最主要的区别其实是：重构后的类的设计完全符合了给出的形式化表述。第二次作业的迭代突然把形式化表述内容几乎翻倍不止，如果要沿着原来的架构像打补丁一样加上这大量的迭代内容，很可能最后根本写不完。\n而重构后的迭代体验也大幅提升：我只需要无脑照抄形式化表述，就能写好解析器，设计好各个类，这不仅省下了时间，也直接跳过了大量与形式化表述不统一而可能引发的潜在的bug。\n另一个大任务是递归函数调用的处理 在得知该迭代需求后，我耗费了相当久的时间思考如何以合理、优雅的方式处理递归函数调用，最终设计的一套处理思路 取得了相当好的可拓展性和相对低的耦合度，并结合动态规划和藏在其中的部分简化（例如，若某ExprFactor的Expr有且只有一个Term，该Term有且只有一个Factor，则该ExprFactor的简化方法返回该Factor，否则返回自身），实现了时间和空间上的大幅优化，并顺利解决掉了当f{n}的n过大时易爆栈的问题（事实上，事后发现课程组的Cost限制完全不足以超时或爆栈）。\n第三次作业 虽说在第二次作业的互测里被打了不少次，理应来说，如果有继续迭代开发的需求，我会继续重构，并明确几点：\n对象属性是否可变，会用到返回值的各种方法除了返回值之外应不应该产生副作用，会不会错误得复用某对象。 明确哪些类需要重写hashCode()和equals()，这一点对于优化性能得分至关重要。 耦合度过高的Poly和Mono是肯定要拆的，怎么分解而能继续实现原有功能，怎么设计更适合迭代的架构，怎么给优化性能留位置等。 但我并没有重构——第三次作业的需求很简单：\n一是普通函数调用，我原设计的递归函数调用处理方法有相当的可拓展性，我甚至没有修改函数相关的类就轻松实现了该要求。\n二是求导因子，但课程组给求导因子的限制过大，尤其是出现范围十分限定，因此我们只需在主线的流水线挑一个方便的环节（包括解析，运算，赋值，简化），附带上求导运算，就实现了。\n所以为什么不重构？第二次作业虽然烂了点，但经过强侧和互测的检验，打完补丁就是能保障正确性的代码。重构意味着要重新面对潜在的bug，而在当前这一坨上作简单的迭代并没有显著难度，正确性也更有保障。因此，没有第二次重构。\nBug分析 诡异的HashMap 这一bug并不是被测出来的：不解决这bug程序完全不能跑。这一单元里，大家都或多或少地与HashMap之类的容器或者hashCode等方法斗争了许久。至今我也不知道，除了新建一个容器往里塞，怎么遍历才能做到不报错。如果有下次，我可能选.stream().map().collect()。\n完全符合形式化表述，但符合得不太完全 \u0026lt;递推表达式\u0026gt; → \u0026lt;常数因子\u0026gt; \u0026lt;空白项\u0026gt; \u0026#39;*\u0026#39; \u0026lt;空白项\u0026gt; \u0026lt;自定义递推函数调用n-1\u0026gt; \u0026lt;空白项\u0026gt; \u0026lt;加减\u0026gt; \u0026lt;空白项\u0026gt; \u0026lt;常数因子\u0026gt; \u0026lt;空白项\u0026gt; \u0026#39;*\u0026#39; \u0026lt;空白项\u0026gt; \u0026lt;自定义递推函数调用n-2\u0026gt; [\u0026lt;空白项\u0026gt; \u0026#39;+\u0026#39; \u0026lt;空白项\u0026gt; \u0026lt;函数表达式\u0026gt;] 虽然经过一次完全符合形式化表述的重构，但因为我的设计足以实现对函数调用的解析，所以我本以为递推表达式就是比较特殊的表达式，其实不然。这个[\u0026lt;空白项\u0026gt; '+' \u0026lt;空白项\u0026gt; \u0026lt;函数表达式\u0026gt;]的诡异的加号让... + + + +1这样的表述变成了可能。这一bug着实很坑，但也没有什么经验可总结。\n谁会在sin()里套sin()*sin()？ 本以为第三次作业大家都差不多，互测更是全房 0 Hack，应该不会有bug了……吗？\n啊，输出了sin(sin(...)*sin(...))，但里面是一个表达式而非一个因子，所以应该是sin((sin(...)*sin(...)))。省去了不该省的括号。这个小bug从第二次作业互测测到第三次作业互测，都没有被测出来，第三次强测反倒测出来了，如果侥幸一点没测出来，这个bug可能永远都不会被发现了。\n当然也有喜闻乐见的 最喜欢分析的bug是别人的bug，在此稍加分析有参考意义的两例。\nextraTriangle!!! extraTriangle!!!一位没删用于调试的输出信息的同学如是喊道。\n这一bug值得分析是因为教会了我们设计一个调试开关，例如：\n// MainClass.java public Class MainClass { public static boolean debug() { return true; } ... public static void main(String[] args) { if (MainClass.debug()) { System.out.println(\u0026#34;Debug模式还没关，别看都不看就直接交了\u0026#34;); } ... } } 可能复用的对象，clone()或谨防副作用 我用一个简单的函数，调用了f{5}(x,x^2)，就一次刀穿了三人（不过其中一人其实没错，他只是在喊extraTriangle!!!），仔细看看，竟与之前发现并修掉的bug如出一辙。有的时候，我们需要这个对象本身，有的时候，我们只是需要这个对象的值。\n张三长大了一岁，无论是谁眼中的张三，都长大了一岁。有的时候，我们需要给张三拍照，把他当前的样子保留下来（或者是生成一个和当前的张三长得一样的克隆人）。问题就出在，可能A让张三长大了一岁，而B想给张三拍照时并没考虑到张三长大了一岁，拍下了不符合预期的照片。\n我的解决方案是，A生成张三的克隆人，并把克隆人当成张三，后续让“张三”长大一岁，原来的张三就不会受到影响，B随时都可以给张三拍照拍到正确的样子。\n测试策略 看源代码还是太折磨了，只有第一次作业读代码来设计测试用例了，后来都找不到用正则解析的了，大家处理思路十分趋同，与其看代码，不如直接构造各类极端样例，进行盲测了。\n当然不能直接用互测窗口测，CD太长；也不能开八个IDEA窗口挨个输入，效率太低；首先将八个压缩包编译生成八个jar包，然后用命令行批量处理，用文件实现读写，最后把大家的答案扔进优化得最好最稳定的同学的jar包，就能得到格式统一的输出了。当然这是不够严谨的做法，我们也可以采取python的一些妙妙工具，把输出的字符串里的x直接文本替换成各种刁钻的数值，评判输出的纯数字结果是不是相隔很小即可（理论上结果应该一模一样，但三角函数优化和浮点数带来的误差不可避免）。\n优化策略 前文已经提到了大部分的优化，因为实在无力处理三角函数的各种优化，且保住正确性分比贪性能分更稳妥。\n现介绍前文未提到的两处优化：\n重写equals()以合并同类项 与之对应的，我们也要重写hashCode()以实现在HashMap中能找到该同类项。\n这样我们就可以应对括号内的值存在关联性的三角函数之间的合并了。\n为返回值作顺带简化 例如前文提到的将ExprFactor返回其中仅有的Factor，可以一定程度上省去不必要的括号；又如cos(0)和sin(0)，可以直接返回具体数值。\n心得体会 虽然第三次作业的轻松要求确实减少了我们的工作量，让我直接放弃了第二次的重构，但我仍没能理解普通函数调用为什么会放在递归函数调用之后作为新要求迭代。第二次作业的任务量也着实有些惊悚，不知是传统还是失误。\n总的来说，第一单元在先导课提供了参考架构的基础上还算顺利，也能明显感到有所收获，期待第二单元的灵异电梯。\n","permalink":"https://oNya685.github.io/posts/buaa/oo/unit-1/summary/","summary":"\u003ch1 id=\"架构简介\"\u003e架构简介\u003c/h1\u003e\n\u003cp\u003e在本单元中，作业要求我们对提供了\u003cstrong\u003e形式化表述\u003c/strong\u003e的复杂表达式进行\u003cstrong\u003e解析和化简\u003c/strong\u003e，并要求尽可能简短的输出以度量性能分数。\u003c/p\u003e\n\u003cp\u003e而经过三次作业迭代（其中包含一次重构），最终架构设计图如下：\u003c/p\u003e","title":"[BUAA-OO] Unit 1 总结"},{"content":"synchronized关键字修饰的局部代码块内，我们能通过wait(), notify(), notifyAll()方法来调控线程之间的协作。\nnotify()和notifyAll()是什么？ 我们先定义两个概念，一个是等待池，一个是锁池，它们都是随一个锁而形成的暂存线程的容器。具体来说：\n等待池中的线程只有被通知（notify）时，才会进入锁池；否则什么也不做。\n锁池中的线程会不断尝试抢锁，如果抢到了锁，会进入synchronized，从开头或上次离开的位置（通过wait离开时）继续执行。\n当某线程尝试进入synchronized，即尝试抢锁，但失败了（因为有其他线程在占用这把锁）时，它会进入锁池，持续不断尝试抢锁。\n当某线程抢锁成功，进入了synchronized，它会离开锁池。\n当某线程进入了synchronized，并遵循程序的设计，执行了wait()方法，它会进入等待池。\n当某线程在synchronized中执行了notify()方法，会从等待池中随机选取一个线程让其移动到锁池。\n当某线程在synchronized中执行了notifyAll()方法，会将等待池中的所有线程移动到锁池。\n什么时候用notify()，什么时候用notifyAll？ 考虑某多线程任务 假设我们有一个资源池，生产者线程向其中添加资源，消费者线程从中获取资源。我们需要确保生产者在资源池满时等待，消费者在资源池空时等待。\nimport java.util.LinkedList; import java.util.Queue; public class ResourcePool { private Queue\u0026lt;Object\u0026gt; resources = new LinkedList\u0026lt;\u0026gt;(); private int capacity; private final Object lock = new Object(); public ResourcePool(int capacity) { this.capacity = capacity; } public void rent(Object resource) { synchronized (lock) { while (resources.size() \u0026gt;= capacity) { try { System.out.println(\u0026#34;生产者进入等待\u0026#34;); lock.wait(); // 如果资源池已满，生产者等待 } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(\u0026#34;生产者被唤醒\u0026#34;); } resources.add(resource); System.out.println(\u0026#34;生产者: 生产了一个资源, 当前资源数: \u0026#34; + resources.size()); lock.notify(); // 唤醒等待的消费者线程 } } public Object consume() { synchronized (lock) { while (resources.isEmpty()) { try { System.out.println(\u0026#34;消费者进入等待\u0026#34;); lock.wait(); // 如果资源池为空，消费者等待 } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(\u0026#34;消费者被唤醒\u0026#34;); } Object resource = resources.remove(); System.out.println(\u0026#34;消费者: 消费了一个资源, 当前资源数: \u0026#34; + resources.size()); lock.notify(); // 唤醒等待的生产者线程 return resource; } } } public class Main { public static void main(String[] args) { ResourcePool pool = new ResourcePool(1); // 借用者1 Thread renter = new Thread(() -\u0026gt; { for (int i = 0; i \u0026lt; 5; i++) { pool.rent(); try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } } }); producer.start(); consumer.start(); } } 在本例中，只有一个生产者线程和一个消费者线程，它们notify()时，只会唤醒彼此，它们被唤醒并继续运行的条件均为resources暂时没被其他人访问。\n考虑生产者-消费者多线程任务 在生产者-消费者模型中，生产者和消费者线程需要协调工作。生产者在资源池满时等待，消费者在资源池空时等待。当资源池有空间或有资源时，相应的线程被唤醒。\nimport java.util.LinkedList; import java.util.Queue; public class ResourcePool { private Queue\u0026lt;Object\u0026gt; resources = new LinkedList\u0026lt;\u0026gt;(); private int capacity; private final Object lock = new Object(); public ResourcePool(int capacity) { this.capacity = capacity; } public void produce(Object resource) { synchronized (lock) { while (resources.size() \u0026gt;= capacity) { try { System.out.println(\u0026#34;生产者进入等待\u0026#34;); lock.wait(); // 如果资源池已满，生产者等待 } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(\u0026#34;生产者被唤醒\u0026#34;); } resources.add(resource); System.out.println(\u0026#34;生产者: 生产了一个资源, 当前资源数: \u0026#34; + resources.size()); lock.notifyAll(); // 唤醒所有等待的消费者线程 } } public Object consume() { synchronized (lock) { while (resources.isEmpty()) { try { System.out.println(\u0026#34;消费者进入等待\u0026#34;); lock.wait(); // 如果资源池为空，消费者等待 } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(\u0026#34;消费者被唤醒\u0026#34;); } Object resource = resources.remove(); System.out.println(\u0026#34;消费者: 消费了一个资源, 当前资源数: \u0026#34; + resources.size()); lock.notifyAll(); // 唤醒所有等待的生产者线程 return resource; } } } public class Main { public static void main(String[] args) { ResourcePool pool = new ResourcePool(3); // 生产者线程 Thread producer = new Thread(() -\u0026gt; { for (int i = 0; i \u0026lt; 5; i++) { pool.produce(new Object()); try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } } }); // 消费者线程1 Thread consumer1 = new Thread(() -\u0026gt; { for (int i = 0; i \u0026lt; 5; i++) { pool.consume(); try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } } }); // 消费者线程2 Thread consumer2 = new Thread(() -\u0026gt; { for (int i = 0; i \u0026lt; 5; i++) { pool.consume(); try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } } }); producer.start(); consumer1.start(); consumer2.start(); } } 为什么要用notifyAll()？用notify()会怎么样？ 使用notifyAll()会唤醒所有等待的线程，确保它们都能重新评估条件。而使用notify()只唤醒一个线程，可能会导致该锁假死：有线程在等待，但没有线程在占用或竞争该锁。\n如果使用notify()：\n如果当前资源数为1，且消费者1消耗了一个资源并执行notify()，此时资源数为0； 如果消费者1恰好notify()了生产者，正常运行； 如果不巧，消费者1notify()了消费者2，消费者2会因为没有可用资源而重新wait()； 此时三者都处于等待池，锁池为空，程序陷入假死。 如果使用notifyAll()：\n所有等待的线程都会被唤醒，重新评估条件。 即使某些线程发现条件不满足并继续等待，其他线程仍然有机会执行。 如何判断用notify()还是notifyAll()？ 判断使用notify()还是notifyAll()的关键在于线程等待的条件（condition）是否相同。\n如果所有等待的线程都在等待同一个条件，使用notify()可能足够。 如果线程等待的条件不同，或者需要确保所有线程都能重新评估条件，使用notifyAll()更安全。 要是我们能给不同的线程设置不同的等待条件该多好。生产者生产后只唤醒条件为资源不为空的消费者，消费者消费后只唤醒条件为资源不为满的生产者们，那就肯定不会假死了！\n用synchronized的代码怎么改造成用ReentrantLock和Condition 什么是ReentrantLock ReentrantLock是一个可重入的互斥锁，它提供了与synchronized类似的功能，但更加灵活。它允许更细粒度的锁控制，并且可以配合Condition对象使用。\nCondition有什么优势 Condition接口提供了类似于wait()、notify()和notifyAll()的方法，但更加灵活。它允许一个锁对象有多个Condition实例，每个实例可以用于不同的条件等待和通知。\n代码改造 将上述代码改造成使用ReentrantLock和Condition：\nimport java.util.LinkedList; import java.util.Queue; import java.util.concurrent.locks.Condition; import java.util.concurrent.locks.Lock; import java.util.concurrent.locks.ReentrantLock; public class ResourcePool { private Queue\u0026lt;Object\u0026gt; resources = new LinkedList\u0026lt;\u0026gt;(); private int capacity; private final Lock lock = new ReentrantLock(); private final Condition notFull = lock.newCondition(); private final Condition notEmpty = lock.newCondition(); public ResourcePool(int capacity) { this.capacity = capacity; } public void produce(Object resource) { lock.lock(); try { while (resources.size() \u0026gt;= capacity) { notFull.await(); // 如果资源池已满，生产者等待 } resources.add(resource); System.out.println(\u0026#34;生产者: 生产了一个资源, 当前资源数: \u0026#34; + resources.size()); notEmpty.signal(); // 唤醒单个等待的消费者线程 } catch (InterruptedException e) { e.printStackTrace(); } finally { lock.unlock(); } } public Object consume() { lock.lock(); try { while (resources.isEmpty()) { notEmpty.await(); // 如果资源池为空，消费者等待 } Object resource = resources.remove(); System.out.println(\u0026#34;消费者: 消费了一个资源, 当前资源数: \u0026#34; + resources.size()); notFull.signal(); // 唤醒单个等待的生产者线程 return resource; } catch (InterruptedException e) { e.printStackTrace(); } finally { lock.unlock(); } } } public class Main { public static void main(String[] args) { ResourcePool pool = new ResourcePool(3); // 生产者线程 Thread producer = new Thread(() -\u0026gt; { for (int i = 0; i \u0026lt; 5; i++) { pool.produce(new Object()); try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } } }); // 消费者线程1 Thread consumer1 = new Thread(() -\u0026gt; { for (int i = 0; i \u0026lt; 5; i++) { pool.consume(); try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } } }); // 消费者线程2 Thread consumer2 = new Thread(() -\u0026gt; { for (int i = 0; i \u0026lt; 5; i++) { pool.consume(); try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } } }); producer.start(); consumer1.start(); consumer2.start(); } } 改造后的代码解释 锁的初始化：\n使用ReentrantLock代替synchronized，提供更灵活的锁控制。 条件的初始化：\n为生产者和消费者分别创建两个Condition实例notFull和notEmpty，分别用于等待资源池满和空的条件。 生产者方法：\n在资源池满时，生产者线程调用notFull.await()进入等待。 当资源池有空间时，调用notEmpty.signal()唤醒单个消费者线程。 消费者方法：\n在资源池空时，消费者线程调用notEmpty.await()进入等待。 当资源池有资源时，调用notFull.signal()唤醒单个生产者线程。 通过这种改造，我们使用ReentrantLock和Condition实现了更灵活的线程同步，避免了synchronized的一些限制。\n","permalink":"https://oNya685.github.io/posts/buaa/oo/condition/","summary":"\u003cp\u003e\u003ccode\u003esynchronized\u003c/code\u003e关键字修饰的局部代码块内，我们能通过\u003ccode\u003ewait()\u003c/code\u003e, \u003ccode\u003enotify()\u003c/code\u003e, \u003ccode\u003enotifyAll()\u003c/code\u003e方法来调控线程之间的协作。\u003c/p\u003e\n\u003ch1 id=\"notify和notifyall是什么\"\u003e\u003ccode\u003enotify()\u003c/code\u003e和\u003ccode\u003enotifyAll()\u003c/code\u003e是什么？\u003c/h1\u003e\n\u003cp\u003e我们先定义两个概念，一个是\u003cstrong\u003e等待池\u003c/strong\u003e，一个是\u003cstrong\u003e锁池\u003c/strong\u003e，它们都是随一个锁而形成的\u003cstrong\u003e暂存线程\u003c/strong\u003e的容器。具体来说：\u003c/p\u003e","title":"用Condition干掉notifyAll"},{"content":"一、思考题 Thinking 0.1 思考下列有关Git的问题：\n在前述已初始化的~/learnGit 目录下，创建一个名为README.txt的文件。执行命令git status \u0026gt; Untracked.txt（其中的 \u0026gt; 为输出重定向，我们将在0.6.3中详细介绍）。 在README.txt 文件中添加任意文件内容，然后使用add命令，再执行命令git status \u0026gt; Stage.txt。 提交README.txt，并在提交说明里写入自己的学号。 执行命令cat Untracked.txt 和cat Stage.txt，对比两次运行的结果，体会README.txt两次所处位置的不同。 修改README.txt 文件，再执行命令git status \u0026gt; Modified.txt。 执行命令cat Modified.txt，观察其结果和第一次执行add命令之前的status是否一样，并思考原因。 1. Untracked.txt $ cat Untracked.txt 位于分支 master 未跟踪的文件: （使用 \u0026#34;git add \u0026lt;文件\u0026gt;...\u0026#34; 以包含要提交的内容） README.txt Untracked.txt 提交为空，但是存在尚未跟踪的文件（使用 \u0026#34;git add\u0026#34; 建立跟踪） 新建了README.txt文件，处于Untracked状态。\n2. Staged.txt $ cat Staged.txt 位于分支 master 要提交的变更： （使用 \u0026#34;git restore --staged \u0026lt;文件\u0026gt;...\u0026#34; 以取消暂存） 新文件： README.txt 未跟踪的文件: （使用 \u0026#34;git add \u0026lt;文件\u0026gt;...\u0026#34; 以包含要提交的内容） Staged.txt Untracked.txt 修改了README.txt的文件内容，并跟踪和暂存该文件，处于Staged状态。\n3. Modified.txt $ cat Modified.txt 位于分支 master 尚未暂存以备提交的变更： （使用 \u0026#34;git add \u0026lt;文件\u0026gt;...\u0026#34; 更新要提交的内容） （使用 \u0026#34;git restore \u0026lt;文件\u0026gt;...\u0026#34; 丢弃工作区的改动） 修改： README.txt 未跟踪的文件: （使用 \u0026#34;git add \u0026lt;文件\u0026gt;...\u0026#34; 以包含要提交的内容） Modified.txt Staged.txt Untracked.txt 修改尚未加入提交（使用 \u0026#34;git add\u0026#34; 和/或 \u0026#34;git commit -a\u0026#34;） README.txt经暂存和提交后处于Unmodified状态，修改文件内容使其进入Modified状态等待暂存。\nThinking 0.2 仔细看看0.10 ，思考一下箭头中的add the file、stage the file和commit分别对应的是Git里的哪些命令呢？\n1. add the file add the file 对应的是git add。\n2. stage the file stage the file 对应的是git add。\n3. commit commit 对应的是git commit。\nThinking 0.3 思考下列问题：\n代码文件print.c被错误删除时，应当使用什么命令将其恢复？ 代码文件print.c被错误删除后，执行了git rm print.c命令，此时应当使用什么命令将其恢复？ 无关文件hello.txt已经被添加到暂存区时，如何在不删除此文件的前提下将其移出暂存区？ 1. 代码文件 print.c 被错误删除时，应当使用什么命令将其恢复？ git restore print.c print.c 尚未执行git add，故可以从暂存区将print.c恢复到工作区中。\n2. 代码文件 print.c 被错误删除后，执行了 git rm print.c 命令，此时应当使用什么命令将其恢复？ git reset HEAD print.c git restore print.c 首先撤销暂存区的修改（删除了print.c），然后将print.c从暂存区恢复到工作区。\n3. 无关文件 hello.txt 已经被添加到暂存区时，如何在不删除此文件的前提下将其移出暂存区？ git reset HEAD hello.txt 撤销暂存区的修改，把暂存区恢复到执行git add之前的状态。\nThinking 0.4 思考下列有关 Git 的问题：\n找到在 /home/22xxxxxx/learnGit 下刚刚创建的 README.txt 文件，若不存在则新建该文件。 在文件里加入 Testing 1，git add，git commit，提交说明记为 1。 模仿上述做法，把 1 分别改为 2 和 3，再提交两次。 使用 git log 命令查看提交日志，看是否已经有三次提交，记下提交说明为 3 的哈希值1。 进行版本回退。执行命令 git reset \u0026ndash;hard HEAD^ 后，再执行 git log，观察其变化。 找到提交说明为 1 的哈希值，执行命令 git reset \u0026ndash;hard \u0026lt;hash\u0026gt; 后，再执行 git log，观察其变化。 现在已经回到了旧版本，为了再次回到新版本，执行 git reset \u0026ndash;hard \u0026lt;hash\u0026gt;，再执行 git log，观察其变化。 $ git log commit a6ebe244272dd6bcb1f57ba9af3c957f3e7235b3 (HEAD -\u0026gt; master) Author: 姜宇墨 \u0026lt;YumoJiang@buaa.edu.cn\u0026gt; Date: Tue Mar 11 19:08:41 2025 +0800 3 commit 1d11df1461528ce8e2b67151384d4b24bdfec571 Author: 姜宇墨 \u0026lt;YumoJiang@buaa.edu.cn\u0026gt; Date: Tue Mar 11 19:08:33 2025 +0800 2 commit 3f8eb4043efae29bbb9eb626444f955a825f3535 Author: 姜宇墨 \u0026lt;YumoJiang@buaa.edu.cn\u0026gt; Date: Tue Mar 11 19:08:12 2025 +0800 1 提交说明为3的哈希值为a6ebe244272dd6bcb1f57ba9af3c957f3e7235b3。\n$ git reset --hard HEAD^ HEAD 现在位于 1d11df1 2 $ git log commit 1d11df1461528ce8e2b67151384d4b24bdfec571 (HEAD -\u0026gt; master) Author: 姜宇墨 \u0026lt;YumoJiang@buaa.edu.cn\u0026gt; Date: Tue Mar 11 19:08:33 2025 +0800 2 commit 3f8eb4043efae29bbb9eb626444f955a825f3535 Author: 姜宇墨 \u0026lt;YumoJiang@buaa.edu.cn\u0026gt; Date: Tue Mar 11 19:08:12 2025 +0800 1 变化：当前Git仓库的状态回到了2。\n$ git reset --hard 3f8eb4043efae29bbb9eb626444f955a825f3535 HEAD 现在位于 3f8eb40 1 $ git log commit 3f8eb4043efae29bbb9eb626444f955a825f3535 (HEAD -\u0026gt; master) Author: 姜宇墨 \u0026lt;YumoJiang@buaa.edu.cn\u0026gt; Date: Tue Mar 11 19:08:12 2025 +0800 1 变化：当前Git仓库的状态回到了1。\n$ git reset --hard a6ebe244272dd6bcb1f57ba9af3c957f3e7235b3 HEAD 现在位于 a6ebe24 3 $ git log commit a6ebe244272dd6bcb1f57ba9af3c957f3e7235b3 (HEAD -\u0026gt; master) Author: 姜宇墨 \u0026lt;YumoJiang@buaa.edu.cn\u0026gt; Date: Tue Mar 11 19:08:41 2025 +0800 3 commit 1d11df1461528ce8e2b67151384d4b24bdfec571 Author: 姜宇墨 \u0026lt;YumoJiang@buaa.edu.cn\u0026gt; Date: Tue Mar 11 19:08:33 2025 +0800 2 commit 3f8eb4043efae29bbb9eb626444f955a825f3535 Author: 姜宇墨 \u0026lt;YumoJiang@buaa.edu.cn\u0026gt; Date: Tue Mar 11 19:08:12 2025 +0800 1 变化：当前Git仓库的状态回到了3。\nThinking 0.5 执行如下命令, 并查看结果\necho first echo second \u0026gt; output.txt echo third \u0026gt; output.txt echo forth \u0026raquo; output.txt $ echo first first $ echo second \u0026gt; output.txt \u0026amp;\u0026amp; cat output.txt second $ echo third \u0026gt; output.txt \u0026amp;\u0026amp; cat output.txt third $ echo forth \u0026gt;\u0026gt; output.txt \u0026amp;\u0026amp; cat output.txt third forth Thinking 0.6 使用你知道的方法（包括重定向）创建下图内容的文件（文件命名为 test），将创建该文件的命令序列保存在command文件中，并将test文件作为批处理文件运行，将运行结果输出至result文件中。给出command文件和result文件的内容，并对最后的结果进行解释说明（可以从test文件的内容入手）。具体实现的过程中思考下列问题: echo echo Shell Start 与 echo `echo Shell Start` 效果是否有区别; echo echo $c\u0026gt;file1 与 echo `echo $c\u0026gt;file1` 效果是否有区别.\n# command echo \u0026#39;echo Shell Start...\u0026#39; \u0026gt; test echo \u0026#39;echo set a = 1\u0026#39; \u0026gt;\u0026gt; test echo \u0026#39;a=1\u0026#39; \u0026gt;\u0026gt; test echo \u0026#39;echo set b = 2\u0026#39; \u0026gt;\u0026gt; test echo \u0026#39;b=2\u0026#39; \u0026gt;\u0026gt; test echo \u0026#39;echo set c = a+b\u0026#39; \u0026gt;\u0026gt; test echo \u0026#39;c=$[$a+$b]\u0026#39; \u0026gt;\u0026gt; test echo \u0026#39;echo c = $c\u0026#39; \u0026gt;\u0026gt; test echo \u0026#39;echo save c to ./file1\u0026#39; \u0026gt;\u0026gt; test echo \u0026#39;echo $c\u0026gt;file1\u0026#39; \u0026gt;\u0026gt; test echo \u0026#39;echo save b to ./file2\u0026#39; \u0026gt;\u0026gt; test echo \u0026#39;echo $b\u0026gt;file2\u0026#39; \u0026gt;\u0026gt; test echo \u0026#39;echo save a to ./file3\u0026#39; \u0026gt;\u0026gt; test echo \u0026#39;echo $a\u0026gt;file3\u0026#39; \u0026gt;\u0026gt; test echo \u0026#39;echo save file1 file2 file3 to file4\u0026#39; \u0026gt;\u0026gt; test echo \u0026#39;cat file1\u0026gt;file4\u0026#39; \u0026gt;\u0026gt; test echo \u0026#39;cat file2\u0026gt;\u0026gt;file4\u0026#39; \u0026gt;\u0026gt; test echo \u0026#39;cat file3\u0026gt;\u0026gt;file4\u0026#39; \u0026gt;\u0026gt; test echo \u0026#39;echo save file4 to ./result\u0026#39; \u0026gt;\u0026gt; test echo \u0026#39;cat file4\u0026gt;\u0026gt;result\u0026#39; \u0026gt;\u0026gt; test # test echo Shell Start... # 输出初始化提示 echo set a = 1 a=1 # 设置变量a=1 echo set b = 2 b=2 # 设置变量b=2 echo set c = a+b c=$[$a+$b] # 执行算术运算c=a+b=1+2=3 echo c = $c # 输出计算结果 echo save c to ./file1 echo $c\u0026gt;file1 # 将c的值写入file1 echo save b to ./file2 echo $b\u0026gt;file2 # 将b的值写入file2 echo save a to ./file3 echo $a\u0026gt;file3 # 将a的值写入file3 echo save file1 file2 file3 to file4 cat file1\u0026gt;file4 # 创建file4并写入file1内容 cat file2\u0026gt;\u0026gt;file4 # 追加file2内容 cat file3\u0026gt;\u0026gt;file4 # 追加file3内容 echo save file4 to ./result cat file4\u0026gt;\u0026gt;result # 最终结果是c,b,a的值 $ ./test Shell Start... set a = 1 set b = 2 set c = a+b c = 3 save c to ./file1 save b to ./file2 save a to ./file3 save file1 file2 file3 to file4 save file4 to ./result $ cat result 3 2 1 反引号会先执行命令替换，改变重定向行为。\necho echo Shell Start echo `echo Shell Start` 输出字符串echo Shell Start 先执行命令echo Shell Start再输出该命令的执行结果Shell Start echo echo $c\u0026gt;file1 echo `echo $c\u0026gt;file1` 将字符串echo 3写入file1 先将3写入file1，再输出写入的执行结果（为空），即终端无输出 二、难点分析与实验体会 本次实验的主要难点在于工具链的命令行参数和shell编程掌握不够熟练。\n难点1：sed的用法 为实现在 hello_os.sh 所处的目录新建一个名为BBB的文件，其内容为 AAA文件的第8、32、128、512、1024行的内容提取，构造sed命令\nsed -n \u0026#39;8p;32p;128p;512p;1024p\u0026#39; \u0026#34;$1\u0026#34; \u0026gt; \u0026#34;$2\u0026#34; 难点2：awk行号提取 grep -n \u0026#34;$2\u0026#34; ./\u0026#34;$1\u0026#34; | awk -F \u0026#39;:\u0026#39; \u0026#39;{print $1}\u0026#39; \u0026gt; ./\u0026#34;$3\u0026#34; 难点3：GCC与Make的特殊用法 # 多目录编译示例 gcc -I ../include -c fibo.c -o fibo.o # 调用子目录make命令示例 make -C code fibo.o 三、原创说明 在本次实验中，对工具链的使用参考了官方manual和--help参数。\n在Neovim和LazyVim的安装与配置中，参考了如何在Ubuntu上安装最新版本的Neovim并快速配置_ubuntu安装neovim-CSDN博客 使用 git log 命令时，在 commit 标识符后的一长串数字和字母组成的字符串\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","permalink":"https://oNya685.github.io/posts/buaa/os/lab-0-report/","summary":"\u003ch1 id=\"一思考题\"\u003e一、思考题\u003c/h1\u003e\n\u003ch2 id=\"thinking-01\"\u003eThinking 0.1\u003c/h2\u003e\n\u003cblockquote\u003e\n\u003cp\u003e思考下列有关Git的问题：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e在前述已初始化的~/learnGit 目录下，创建一个名为README.txt的文件。执行命令git status \u0026gt; Untracked.txt（其中的 \u0026gt; 为输出重定向，我们将在0.6.3中详细介绍）。\u003c/li\u003e\n\u003cli\u003e在README.txt 文件中添加任意文件内容，然后使用add命令，再执行命令git status \u0026gt; Stage.txt。\u003c/li\u003e\n\u003cli\u003e提交README.txt，并在提交说明里写入自己的学号。\u003c/li\u003e\n\u003cli\u003e执行命令cat Untracked.txt 和cat Stage.txt，对比两次运行的结果，体会README.txt两次所处位置的不同。\u003c/li\u003e\n\u003cli\u003e修改README.txt 文件，再执行命令git status \u0026gt; Modified.txt。\u003c/li\u003e\n\u003cli\u003e执行命令cat Modified.txt，观察其结果和第一次执行add命令之前的status是否一样，并思考原因。\u003c/li\u003e\n\u003c/ul\u003e\u003c/blockquote\u003e\n\u003chr\u003e\n\u003ch3 id=\"1-untrackedtxt\"\u003e1. Untracked.txt\u003c/h3\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e$  cat Untracked.txt\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e位于分支 master\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e未跟踪的文件:\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  （使用 \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;git add \u0026lt;文件\u0026gt;...\u0026#34;\u003c/span\u003e 以包含要提交的内容）\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        README.txt\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        Untracked.txt\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e提交为空，但是存在尚未跟踪的文件（使用 \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;git add\u0026#34;\u003c/span\u003e 建立跟踪）\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e新建了\u003ccode\u003eREADME.txt\u003c/code\u003e文件，处于Untracked状态。\u003c/p\u003e","title":"[BUAA-OS] Lab 0 实验报告"},{"content":"点此查看作业源文件 1.什么是多道程序设计？多道程序设计与分时系统的区别是什么？ 多道程序设计技术，是指允许多个程序同时进⼊内存并运⾏。即同时把多个程序放⼊内存中，并允许它们交替在CPU中运⾏，共享系统中的各种硬、软件资源，当⼀道程序因I/O请求⽽暂停运⾏时，CPU便⽴即转去运⾏另⼀道程序。多道程序设计技术提⾼了CPU、I/O设备和内存的利⽤率，从⽽提⾼了整个系统的资源利⽤率和系统吞吐量，最终提⾼了整个系统的效率。\n多道程序设计与分时系统的区别在于：多道程序设计主要关注的是如何让多个程序在内存中同时存在并交替执⾏，以提⾼资源利⽤率。分时系统则是在多道程序设计的基础上进⼀步发展，它不仅允许多个程序并发执⾏，还通过时间⽚轮转的⽅式为每个⽤户分配CPU时间，使得多个⽤户可以⼏乎同时使⽤计算机，提供交互式服务。\n2.什么原因推动了操作系统从批处理发展到多道程序，进而发展到分时系统？ 批处理系统的运⾏效率被低速I/O设备限制，CPU空闲时间多，利⽤率低，因此发展出多道程序系统；\n多道程序系统平均周转时间⻓，不能提供交互作⽤能⼒，因此发展出允许多个⽤户共享计算机，多个程序分时共享硬、软件资源的分时系统。\n3.什么是陷阱？与中断的区别是什么？什么是系统调用？ 陷阱是⼀种同步异常，是程序内部有意设置的某⼀特定指令执⾏的结果，例如系统调⽤。陷阱是程序执⾏过程中预期的⾏为，可以复现，⽤于请求操作系统提供服务等。\n中断是⼀种异步异常，通常由外部事件（I/O设备、处理器时钟或定时器）触发，与处理器正在执⾏的内容⽆关。中断是不可预测的，⽤于处理外部事件。\n系统调⽤是⽤户程序与操作系统内核之间的接⼝，允许⽤户程序请求操作系统提供的服务。系统调⽤本质上是⼀种同步异常，或陷阱，⽤于安全地进⼊内核模式并执⾏特权操作。\n4.判断：可移植的操作系统可以从一个系统架构移植到另外一个系统架构而无需修改。 错误。不同系统架构之间存在指令集差异、内存管理方式不同、硬件寄存器配置不一致等根本性区别，操作系统必须针对这些硬件特性进行调整。\n(1)请解释为什么构建完全可移植的OS是不可能的？ 不同硬件架构的指令集、总线设计和CPU字长等存在差异，操作系统必须依赖硬件相关代码，⽆法完全通⽤。\n(2)如果需要你设计一个高度可移植的OS，那么请描述你需要设计的两个层次？ 高度可移植的操作系统由机器相关层和机器无关层组成。机器无关层只需实现一次即可。\n机器相关层处理硬件的具体特性，必须针对每个架构单独实现。该层为机器无关层提供统一的接口。为实现高度可移植性，机器相关层的规模应尽可能最小化。\n5.在设计操作系统时，一些设计指标是相互矛盾的，例如资源利用率、吞吐量、处理时间、健壮性等。请给出一对相互矛盾的设计实例。 资源利⽤率与响应时间。\n资源利⽤率⾼意味着尽可能多地利⽤系统资源，但可能导致频繁的切换和复杂的调度策略，从⽽增加响应时间。响应时间短要求操作系统能够快速响应⽤户请求，可能保留更多的资源⽤于即时响应，导致资源利⽤率下降。\n6.一个计算机系统有输入机一台、打印机两台，现有二道程序同时投入运行，且程序A先开始运行，程序B后运行。程序A的运行轨迹为：计算50ms，打印信息100ms，再计算50ms，打印信息100ms，结束。程序B运行的轨迹为：计算50ms，输入数据80ms，再计算100ms，结束。要求： (1)用图画出这二道程序并发执行时的工作情况。 (2)说明在二道程序运行时，CPU有无空闲等待？若有，在哪段时间内等待？为什么会空闲等待？ 有。在100ms~150ms，程序A在打印信息，程序B在输入数据，故CPU处于空闲等待。\n(3)程序A、B运行时有无等待现象？在什么时候会发生等待现象？ 程序A没有，程序B有。\n在180ms~200ms，程序B完成了输入数据，在等待CPU空闲，而程序A占用了处理器，正在进行计算，故程序B等待了20ms。\n","permalink":"https://oNya685.github.io/posts/buaa/os/homework-1/","summary":"\u003cp\u003e\u003cstrong\u003e\u003ca href=\"%e4%bd%9c%e4%b8%9a1.pdf\" target=\"_blank\"\u003e点此查看作业源文件\u003c/a\u003e\n\u003c/strong\u003e\u003c/p\u003e\n\u003ch1 id=\"1什么是多道程序设计多道程序设计与分时系统的区别是什么\"\u003e1.什么是多道程序设计？多道程序设计与分时系统的区别是什么？\u003c/h1\u003e\n\u003cp\u003e多道程序设计技术，是指允许多个程序同时进⼊内存并运⾏。即同时把多个程序放⼊内存中，并允许它们交替在CPU中运⾏，共享系统中的各种硬、软件资源，当⼀道程序因I/O请求⽽暂停运⾏时，CPU便⽴即转去运⾏另⼀道程序。多道程序设计技术提⾼了CPU、I/O设备和内存的利⽤率，从⽽提⾼了整个系统的资源利⽤率和系统吞吐量，最终提⾼了整个系统的效率。\u003c/p\u003e","title":"[BUAA-OS] 理论作业 1"},{"content":"函数调用处理机制 核心思路 实参与形参分离：通过assignment哈希表实现参数映射，实现形参（函数定义时的参数名）与相对实参（调用时传入的具体因子）的对应关系。 递归替换：通过assign方法逐层展开函数调用 终止条件：当递归到初始定义表达式时完成解析 关键实现步骤 数据结构 为函数调用因子引入通过HashMap\u0026lt;String, Factor\u0026gt;实现的新成员变量assignment，并在为语素实现的assign方法中作为传入参数。\n对于FuncCall因子，引入Integer index，FuncDefine，ArrayList\u0026lt;Factor\u0026gt;，用于实现对Expr中的FuncCall因子的完全解析。\npublic class FuncCall extends VarFactor { private final ConstantFactor index; private final FuncDefine define; private final HashMap\u0026lt;BaseVar, Factor\u0026gt; assignment; // 实际参数列表 } 处理流程 通过expr = expr.assign(null)中调用funcCall.define.get(index).assign(assignment).assign(null)，因除FuncCall以外的其他语素有其assign方法，所以将不断递归下降直到funcCall.define.get(1)和funcCall.define.get(0)。此时再递归向下将不再出现FuncCall类，递归结束并逐级返回。从而实现的Expr的去FuncCall流程，以便进行toPoly和simplify。\n初始化调用\nexpr = expr.assign(null); // 通过expr.assign(null)启动替换链条，null参数表示要解析的最上层表达式中的参数为绝对实参 参数替换机制\n// FuncCall.java ExprFactor assign(HashMap\u0026lt;String, Factor\u0026gt; assignment) { return this.define.get(this.index) .assign(this.assignment) // 先应用this.assignment当前层的参数绑定 .assign(assignment); // 再应用外层传入的assignment参数，实现参数作用域的嵌套覆盖 } 递归展开过程\n// 高层调用 → 中间层展开 → 基础层解析 funcCall.assign(null) → funcCall.define.get(index).assign(assignment).assign(null) → ... → funcCall\u0026#39;.define.get(index\u0026#39;).assign(assignment\u0026#39;).assign(assignment).assign(null) → ... → funcCall\u0026#39;\u0026#39;.define.get(index\u0026#39;\u0026#39;).assign(assignment\u0026#39;\u0026#39;).assign(assignment\u0026#39;).assign(assignment).assign(null) → ... → funcCall.define.get(0 | 1).assign... // 初始定义表达式 类方法实现 经assign方法，BaseVar.assign(assignment)返回Factor，PowerFunc.assign(assignment)返回ExprFactor，FuncCall递归调用(Expr)define.get(this.index).assign(this.assignment).assign(assignment)返回ExprFactor，其他语素的assign方法返回同类对象。最终递归返回不含FuncCall的纯Expr，即可施之toPoly方法。\n类名 assign方法行为 返回类型 BaseVar 直接返回对应的含相对实参的Factor Factor PowerFunc 返回参数赋值的ExprFactor ExprFactor FuncCall 递归调用下层定义进行参数替换 ExprFactor 其他因子 返回由自身组成语素.assign()构造的同类对象 同类对象 处理终点 当递归到define.get(0 | 1)时：\n不再包含FuncCall对象，函数调用结构完全消解 所有形参已被实际参数替换 表达式完全展开为基本元素 可安全调用toPoly()进行多项式转换 可进行最终化简simplify() ","permalink":"https://oNya685.github.io/posts/buaa/oo/unit-1/homework-2-function/","summary":"\u003ch1 id=\"函数调用处理机制\"\u003e函数调用处理机制\u003c/h1\u003e\n\u003ch2 id=\"核心思路\"\u003e核心思路\u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003e实参与形参分离\u003c/strong\u003e：通过\u003ccode\u003eassignment\u003c/code\u003e哈希表实现参数映射，实现\u003cstrong\u003e形参\u003c/strong\u003e（函数定义时的参数名）与\u003cstrong\u003e相对实参\u003c/strong\u003e（调用时传入的具体因子）的对应关系。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e递归替换\u003c/strong\u003e：通过\u003ccode\u003eassign\u003c/code\u003e方法逐层展开函数调用\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e终止条件\u003c/strong\u003e：当递归到\u003cstrong\u003e初始定义\u003c/strong\u003e表达式时完成解析\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2 id=\"关键实现步骤\"\u003e关键实现步骤\u003c/h2\u003e\n\u003ch3 id=\"数据结构\"\u003e数据结构\u003c/h3\u003e\n\u003cp\u003e为函数调用因子引入通过\u003ccode\u003eHashMap\u0026lt;String, Factor\u0026gt;\u003c/code\u003e实现的新成员变量\u003ccode\u003eassignment\u003c/code\u003e，并在为语素实现的\u003ccode\u003eassign\u003c/code\u003e方法中作为传入参数。\u003c/p\u003e","title":"[BUAA-OO] Unit 1 递归函数调用的解析与计算"}]