[{"content":"点此查看作业源文件 1. 有五个进程P1、P2、P3、P4、P5，它们同时依次进入就绪队列，它们的优先数和需要的处理器时间如下表 进程 处理器时间 优先级（数小优先级高） P1 $10$ $3$ P2 $1$ $1$ P3 $2$ $3$ P4 $1$ $4$ P5 $5$ $2$ 忽略进行调度等所花费的时间，回答下列问题：\n(1) 写出采用“先来先服务”、“短作业（进程）优先”、“非抢占式的优先数”和“轮转法”等调度算法，进程执行的次序。（其中轮转法的时间片为2） 调度算法 先来先服务 P1 P2 P3 P4 P5 短作业（进程）优先 P2 P4 P3 P5 P1 非抢占式的优先数 P2 P5 P1 P3 P4 轮转法 P1: 2 P2: 3 P3: 5 P4: 6 P5: 8 P1: 10 P5: 12 P1: 14 P5: 15 P1: 17 P1: 19 (2) 分别计算上述算法中各进程的周转时间和等待时间，以及平均周转时间。 调度算法 P1等待时间 P2等待时间 P3等待时间 P4等待时间 P5等待时间 先来先服务 $0$ $10$ $11$ $13$ $14$ 短作业（进程）优先 $9$ $0$ $2$ $1$ $4$ 非抢占式的优先数 $6$ $0$ $16$ $18$ $1$ 轮转法 $0$ $2$ $3$ $5$ $6$ 调度算法 P1周转时间 P2周转时间 P3周转时间 P4周转时间 P5周转时间 平均周转时间$T$ 先来先服务 $10$ $11$ $13$ $14$ $19$ $13.4$ 短作业（进程）优先 $19$ $1$ $4$ $2$ $9$ $7$ 非抢占式的优先数 $16$ $1$ $18$ $19$ $6$ $12$ 轮转法 $19$ $3$ $5$ $6$ $15$ $9.6$ 2. 假设某系统使用时间片轮转调度算法进行CPU调度，时间片大小为5ms，系统共10个进程，初始时均处于就绪队列，执行结束前仅处于执行态或就绪态。若队尾的进程P所需的CPU时间最短，时间为25ms，不考虑系统开销，则进程P的周转时间为？ 0-45ms在依次执行其他进程，45-50ms首次执行进程P，P剩余所需CPU时间20ms。\n由于进程P所需的CPU时间最短，所以每周期执行进程P前都需要45ms依次执行其他进程，50ms为一周期。\n以此类推，第195-200ms第四次执行进程P，P剩余所需CPU时间5ms。第200-245ms依次执行其他进程，第245-250ms第五次执行进程P，250ms时进程P执行结束。\n故进程P的周转时间为250ms。\n3. 某个进程调度程序采用基于优先数(priority)的调度策略，即选择优先数最小的进程运行，运行创建时由用户指定一个nice作为静态优先数。为了动态调整优先数，引入运行时间cpuTime和等待时间waitTime，初值为0。进程处于执行态时，cpuTime定时加1，且waitTime置0；进程处于就绪态时，cpuTime置0，waitTime定时加1。 (1) 若调度程序只将nice的值作为进程优先级，即priority = nice，则可能出现饥饿现象。为什么？ 当调度程序仅将用户指定的静态优先数 nice 作为进程优先级时，静态优先级无法动态调整。\n若系统中持续有低 nice 值（高优先级）的进程到达，高 nice 值（低优先级）的进程可能因无法获得 CPU 时间而长期处于就绪队列，导致饥饿。低 nice 值的进程可能因优先级高而持续占用 CPU，即使其实际运行时间较长或资源需求不合理，也会挤压其他进程的执行机会。\n(2) 使用nice，cpuTime，waitTime设计一种动态优先数计算方法，以避免产生饥饿现象，并说明waitTime的作用 设计动态优先数公式：\n$$\\text{priority} = \\text{nice} + k_1 \\times \\text{cpuTime} - k_2 \\times \\text{waitTime}, k_1 \u003e 0, k_2 \u003e 0$$• k1 \u0026gt; 0：惩罚 CPU 占用时间长的进程（防止 CPU 霸占）。\n• k2 \u0026gt; 0：补偿等待时间长的进程（避免饥饿）。\n• cpuTime 的作用：进程运行时，cpuTime 定时增加。若进程长期占用 CPU，其优先级会因 cpuTime 增大而降低，从而让出 CPU 给其他进程。\n• waitTime 的作用：进程就绪时，waitTime 定时增加。其值越大，优先级提升越多，确保长时间等待的进程能被及时调度，通过补偿等待时间，确保低优先级进程最终能被调度，避免饥饿。\n4. 死锁 (1) 有m个同类资源供n个进程共享，若每个进程最多申请k个资源（k\u0026gt;=1），采用银行家算法分配资源，为保证系统不发生死锁，则各进程的最大需求量之和为？并说明理由 最坏情况下，每个进程均已分配$k-1$个资源，此时要保证存在至少一个安全序列。则剩余资源$m-n\\times (k-1) \\geq 1$，即需求量之和$nk\\leq m+n-1$。\n因此，各进程的最大需求量之和为$m+n-1$。\n(2) 有8台打印机，由K个进程竞争使用，每个进程最多使用3台打印机。求K的最大值，使系统可能发生死锁。 为使系统发生死锁，$3\\times K \\geq 8 + K$，即$K \\geq 4$。所以：\n使系统不发生死锁的K的最大值为3；\n使系统可能发生死锁的K的最小值为4。\n(3) 某系统有n台互斥使用的同类设备，三个并发进程分别需要3，4，5台设备。求n的最小值，使系统不发生死锁。 假设给三个并发进程已经分别发配了2，3，4台设备，则剩余资源$n-2-3-4\\geq 1$，即$n \\geq 10$。\n故使系统不发生死锁的最小值为10。\n5. 什么是进程之间的同步关系？什么是进程之间的互斥关系？ 互斥：某一资源同时只允许一个访问者对其进行访问，具有唯一性和排它性 同步：是指在互斥的基础上（大多数情况），通过其它机制实现访问者对资源的有序访问 6. 假设具有5个进程的进程集合P= {P0,P1,P2,P3,P4}，系统中有三类资源A,B,C，假设在某时刻有如下状态： 进程 Allocation Max Available $\\left(\\begin{matrix} A \u0026amp;\u0026amp; B \u0026amp;\u0026amp; C \\end{matrix}\\right)$ $\\left(\\begin{matrix} A \u0026amp;\u0026amp; B \u0026amp;\u0026amp; C \\end{matrix}\\right)$ $\\left(\\begin{matrix} A \u0026amp;\u0026amp; B \u0026amp;\u0026amp; C \\end{matrix}\\right)$ P0 $\\left(\\begin{matrix} 0 \u0026amp;\u0026amp; 0 \u0026amp;\u0026amp; 3 \\end{matrix}\\right)$ $\\left(\\begin{matrix} 0 \u0026amp;\u0026amp; 0 \u0026amp;\u0026amp; 4 \\end{matrix}\\right)$ $\\left(\\begin{matrix} 1 \u0026amp;\u0026amp; 4 \u0026amp;\u0026amp; 0 \\end{matrix}\\right)$ P1 $\\left(\\begin{matrix} 1 \u0026amp;\u0026amp; 0 \u0026amp;\u0026amp; 0 \\end{matrix}\\right)$ $\\left(\\begin{matrix} 1 \u0026amp;\u0026amp; 7 \u0026amp;\u0026amp; 5 \\end{matrix}\\right)$ P2 $\\left(\\begin{matrix} 1 \u0026amp;\u0026amp; 3 \u0026amp;\u0026amp; 5 \\end{matrix}\\right)$ $\\left(\\begin{matrix} 2 \u0026amp;\u0026amp; 3 \u0026amp;\u0026amp; 5 \\end{matrix}\\right)$ P3 $\\left(\\begin{matrix} 0 \u0026amp;\u0026amp; 0 \u0026amp;\u0026amp; 2 \\end{matrix}\\right)$ $\\left(\\begin{matrix} 0 \u0026amp;\u0026amp; 6 \u0026amp;\u0026amp; 4 \\end{matrix}\\right)$ P4 $\\left(\\begin{matrix} 0 \u0026amp;\u0026amp; 0 \u0026amp;\u0026amp; 1 \\end{matrix}\\right)$ $\\left(\\begin{matrix} 0 \u0026amp;\u0026amp; 6 \u0026amp;\u0026amp; 5 \\end{matrix}\\right)$ (1) 根据上表内容，当前系统是否处于安全状态？ Work 进程 Need Allocation Work+Allocation Finish $\\left(\\begin{matrix} A \u0026amp;\u0026amp; B \u0026amp;\u0026amp; C \\end{matrix}\\right)$ $\\left(\\begin{matrix} A \u0026amp;\u0026amp; B \u0026amp;\u0026amp; C \\end{matrix}\\right)$ $\\left(\\begin{matrix} A \u0026amp;\u0026amp; B \u0026amp;\u0026amp; C \\end{matrix}\\right)$ $\\left(\\begin{matrix} A \u0026amp;\u0026amp; B \u0026amp;\u0026amp; C \\end{matrix}\\right)$ $\\left(\\begin{matrix} 1 \u0026amp;\u0026amp; 4 \u0026amp;\u0026amp; 0 \\end{matrix}\\right)$ P2 $\\left(\\begin{matrix} 1 \u0026amp;\u0026amp; 0 \u0026amp;\u0026amp; 0 \\end{matrix}\\right)$ $\\left(\\begin{matrix} 1 \u0026amp;\u0026amp; 3 \u0026amp;\u0026amp; 5 \\end{matrix}\\right)$ $\\left(\\begin{matrix} 2 \u0026amp;\u0026amp; 7 \u0026amp;\u0026amp; 5 \\end{matrix}\\right)$ true $\\left(\\begin{matrix} 2 \u0026amp;\u0026amp; 7 \u0026amp;\u0026amp; 5 \\end{matrix}\\right)$ P0 $\\left(\\begin{matrix} 0 \u0026amp;\u0026amp; 0 \u0026amp;\u0026amp; 1 \\end{matrix}\\right)$ $\\left(\\begin{matrix} 0 \u0026amp;\u0026amp; 0 \u0026amp;\u0026amp; 3 \\end{matrix}\\right)$ $\\left(\\begin{matrix} 2 \u0026amp;\u0026amp; 7 \u0026amp;\u0026amp; 8 \\end{matrix}\\right)$ true $\\left(\\begin{matrix} 2 \u0026amp;\u0026amp; 7 \u0026amp;\u0026amp; 8 \\end{matrix}\\right)$ P1 $\\left(\\begin{matrix} 0 \u0026amp;\u0026amp; 7 \u0026amp;\u0026amp; 5 \\end{matrix}\\right)$ $\\left(\\begin{matrix} 1 \u0026amp;\u0026amp; 0 \u0026amp;\u0026amp; 0 \\end{matrix}\\right)$ $\\left(\\begin{matrix} 3 \u0026amp;\u0026amp; 7 \u0026amp;\u0026amp; 8 \\end{matrix}\\right)$ true $\\left(\\begin{matrix} 3 \u0026amp;\u0026amp; 7 \u0026amp;\u0026amp; 8 \\end{matrix}\\right)$ P3 $\\left(\\begin{matrix} 0 \u0026amp;\u0026amp; 6 \u0026amp;\u0026amp; 2 \\end{matrix}\\right)$ $\\left(\\begin{matrix} 0 \u0026amp;\u0026amp; 0 \u0026amp;\u0026amp; 2 \\end{matrix}\\right)$ $\\left(\\begin{matrix} 3 \u0026amp;\u0026amp; 7 \u0026amp;\u0026amp; 10 \\end{matrix}\\right)$ true $\\left(\\begin{matrix} 3 \u0026amp;\u0026amp; 7 \u0026amp;\u0026amp; 10 \\end{matrix}\\right)$ P4 $\\left(\\begin{matrix} 0 \u0026amp;\u0026amp; 6 \u0026amp;\u0026amp; 4 \\end{matrix}\\right)$ $\\left(\\begin{matrix} 0 \u0026amp;\u0026amp; 0 \u0026amp;\u0026amp; 1 \\end{matrix}\\right)$ $\\left(\\begin{matrix} 3 \u0026amp;\u0026amp; 7 \u0026amp;\u0026amp; 11 \\end{matrix}\\right)$ true 当前系统处于安全状态，存在安全序列：$\\text{P2} \\to \\text{P0} \\to \\text{P1} \\to \\text{P3} \\to \\text{P4}$\n(2) 若系统中的可利用资源 Available 为（0,6,2），系统是否安全？若系统处在安全状态，请给出安全序列；若系统处在非安全状态，简要说明原因。 Work 进程 Need Allocation Work+Allocation Finish $\\left(\\begin{matrix} A \u0026amp;\u0026amp; B \u0026amp;\u0026amp; C \\end{matrix}\\right)$ $\\left(\\begin{matrix} A \u0026amp;\u0026amp; B \u0026amp;\u0026amp; C \\end{matrix}\\right)$ $\\left(\\begin{matrix} A \u0026amp;\u0026amp; B \u0026amp;\u0026amp; C \\end{matrix}\\right)$ $\\left(\\begin{matrix} A \u0026amp;\u0026amp; B \u0026amp;\u0026amp; C \\end{matrix}\\right)$ $\\left(\\begin{matrix} 0 \u0026amp;\u0026amp; 6 \u0026amp;\u0026amp; 2 \\end{matrix}\\right)$ P0 $\\left(\\begin{matrix} 0 \u0026amp;\u0026amp; 0 \u0026amp;\u0026amp; 1 \\end{matrix}\\right)$ $\\left(\\begin{matrix} 0 \u0026amp;\u0026amp; 0 \u0026amp;\u0026amp; 3 \\end{matrix}\\right)$ $\\left(\\begin{matrix} 0 \u0026amp;\u0026amp; 6 \u0026amp;\u0026amp; 5 \\end{matrix}\\right)$ true $\\left(\\begin{matrix} 0 \u0026amp;\u0026amp; 6 \u0026amp;\u0026amp; 5 \\end{matrix}\\right)$ P3 $\\left(\\begin{matrix} 0 \u0026amp;\u0026amp; 6 \u0026amp;\u0026amp; 2 \\end{matrix}\\right)$ $\\left(\\begin{matrix} 0 \u0026amp;\u0026amp; 0 \u0026amp;\u0026amp; 2 \\end{matrix}\\right)$ $\\left(\\begin{matrix} 0 \u0026amp;\u0026amp; 6 \u0026amp;\u0026amp; 7 \\end{matrix}\\right)$ true $\\left(\\begin{matrix} 0 \u0026amp;\u0026amp; 6 \u0026amp;\u0026amp; 7 \\end{matrix}\\right)$ P4 $\\left(\\begin{matrix} 0 \u0026amp;\u0026amp; 6 \u0026amp;\u0026amp; 4 \\end{matrix}\\right)$ $\\left(\\begin{matrix} 0 \u0026amp;\u0026amp; 0 \u0026amp;\u0026amp; 1 \\end{matrix}\\right)$ $\\left(\\begin{matrix} 0 \u0026amp;\u0026amp; 6 \u0026amp;\u0026amp; 8 \\end{matrix}\\right)$ true $\\left(\\begin{matrix} 0 \u0026amp;\u0026amp; 6 \u0026amp;\u0026amp; 8 \\end{matrix}\\right)$ P1 $\\left(\\begin{matrix} 0 \u0026amp;\u0026amp; 7 \u0026amp;\u0026amp; 5 \\end{matrix}\\right)$ $\\left(\\begin{matrix} 1 \u0026amp;\u0026amp; 0 \u0026amp;\u0026amp; 0 \\end{matrix}\\right)$ —— false $\\left(\\begin{matrix} 0 \u0026amp;\u0026amp; 6 \u0026amp;\u0026amp; 8 \\end{matrix}\\right)$ P2 $\\left(\\begin{matrix} 1 \u0026amp;\u0026amp; 0 \u0026amp;\u0026amp; 0 \\end{matrix}\\right)$ $\\left(\\begin{matrix} 1 \u0026amp;\u0026amp; 3 \u0026amp;\u0026amp; 5 \\end{matrix}\\right)$ —— false 因此，系统处于非安全状态。\n部分进程可执行： 初始可用资源 (0,6,2) 可满足 P0（Need (0,0,1)），执行后释放资源，可用资源更新为 (0,6,5)。 资源 (0,6,5) 可满足 P3（Need (0,6,2)），执行后可用资源更新为 (0,6,7)。 资源 (0,6,7) 可满足 P4（Need (0,6,4)），执行后可用资源更新为 (0,6,8)。 剩余进程无法执行： P1 需要 B=7，但当前可用 B=6，资源不足。 P2 需要 A=1，但当前可用 A=0，资源不足。 无法形成完整安全序列： P0 → P3 → P4 可执行，但剩余进程 P1 和 P2 的资源需求无法满足，无法形成完整安全序列。 ","permalink":"https://oNya685.github.io/posts/buaa/os/homework-5/","summary":"\u003cp\u003e\u003cstrong\u003e\u003ca href=\"%e4%bd%9c%e4%b8%9a5.pdf\" target=\"_blank\"\u003e点此查看作业源文件\u003c/a\u003e\n\u003c/strong\u003e\u003c/p\u003e\n\u003ch1 id=\"1-有五个进程p1p2p3p4p5它们同时依次进入就绪队列它们的优先数和需要的处理器时间如下表\"\u003e1. 有五个进程P1、P2、P3、P4、P5，它们同时依次进入就绪队列，它们的优先数和需要的处理器时间如下表\u003c/h1\u003e\n\u003ctable\u003e\n  \u003cthead\u003e\n      \u003ctr\u003e\n          \u003cth style=\"text-align: center\"\u003e进程\u003c/th\u003e\n          \u003cth style=\"text-align: center\"\u003e处理器时间\u003c/th\u003e\n          \u003cth style=\"text-align: center\"\u003e优先级\u003c!-- raw HTML omitted --\u003e（数小优先级高）\u003c/th\u003e\n      \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: center\"\u003eP1\u003c/td\u003e\n          \u003ctd style=\"text-align: center\"\u003e$10$\u003c/td\u003e\n          \u003ctd style=\"text-align: center\"\u003e$3$\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: center\"\u003eP2\u003c/td\u003e\n          \u003ctd style=\"text-align: center\"\u003e$1$\u003c/td\u003e\n          \u003ctd style=\"text-align: center\"\u003e$1$\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: center\"\u003eP3\u003c/td\u003e\n          \u003ctd style=\"text-align: center\"\u003e$2$\u003c/td\u003e\n          \u003ctd style=\"text-align: center\"\u003e$3$\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: center\"\u003eP4\u003c/td\u003e\n          \u003ctd style=\"text-align: center\"\u003e$1$\u003c/td\u003e\n          \u003ctd style=\"text-align: center\"\u003e$4$\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: center\"\u003eP5\u003c/td\u003e\n          \u003ctd style=\"text-align: center\"\u003e$5$\u003c/td\u003e\n          \u003ctd style=\"text-align: center\"\u003e$2$\u003c/td\u003e\n      \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e\n\u003cp\u003e忽略进行调度等所花费的时间，回答下列问题：\u003c/p\u003e","title":"[BUAA-OS] 理论作业 5"},{"content":"机器学习实验报告\n一、数据预处理：归一化与标准化处理\n（一）实验中的预处理方法\n是否进行归一化/标准化\n实验中使用了 标准化（Standardization） 处理，具体代码为：\nscaler = StandardScaler() X_train = scaler.fit_transform(X_train) X_test = scaler.transform(X_test) • fit_transform 对训练集计算均值和标准差并应用转换。\n• transform 对测试集直接使用训练集的参数进行转换。\n归一化与标准化的区别\n• 归一化（Normalization）：\n将数据缩放到固定范围（如[0,1]），公式为：\n\\[ x_{\\text{norm}} = \\frac{x - x_{\\min}}{x_{\\max} - x_{\\min}} \\]\n• 标准化（Standardization）：\n将数据调整为均值为0、标准差为1的分布，公式为：\n\\[ x_{\\text{std}} = \\frac{x - \\mu}{\\sigma} \\] 线性回归对特征尺度敏感的原因\n• 解析解稳定性：参数解析解 \\( w = (X^T X)^{-1} X^T y \\) 中，若特征尺度差异大，矩阵 \\( X^T X \\) 的条件数增大，导致求逆不稳定。\n• 梯度下降效率：不同尺度的特征需不同的学习率，尺度差异大会导致收敛速度慢。\n二、线性回归目标函数与参数求解\n（一）目标函数与解析解推导\n目标函数：\n\\[ J(w) = \\sum_{i=1}^N (w^T x_i - y_i)^2 \\] 解析解推导：\n• 矩阵形式：\\( J(w) = (Xw - y)^T (Xw - y) \\)\n• 对 \\( w \\) 求导并令导数为零：\n\\[ \\frac{\\partial J(w)}{\\partial w} = 2X^T (Xw - y) = 0 \\]\n• 解得：\n\\[ w = (X^T X)^{-1} X^T y \\] （二）标准方程组法与梯度下降法的对比\n优势：\n• 精确解：直接得到全局最优解，无需迭代调参。\n• 效率高：当特征数 \\( d \\) 较小时（实验数据集特征数 \\( d=8 \\)），计算复杂度 \\( O(d^3) \\) 可接受。\n劣势：\n• 计算复杂度：若 \\( d \u003e 10^4 \\)，矩阵求逆计算不可行。\n• 内存限制：存储 \\( X^T X \\) 需要 \\( O(d^2) \\) 内存。\n三、模型评估指标分析\n（一）指标定义与意义\n均方误差（MSE）：\n\\[ \\text{MSE} = \\frac{1}{N} \\sum_{i=1}^N (y_i - \\hat{y}_i)^2 \\]\n• 反映预测值与真实值的平均平方误差，值越小越好。\n均方根误差（RMSE）：\n\\[ \\text{RMSE} = \\sqrt{\\text{MSE}} \\]\n• 与目标变量单位一致，更易解释误差的实际影响。\n决定系数（R²）：\n\\[ R^2 = 1 - \\frac{\\sum_{i=1}^N (y_i - \\hat{y}_i)^2}{\\sum_{i=1}^N (y_i - \\bar{y})^2} \\]\n• 表示模型解释的方差比例，范围 \\( (-\\infty, 1] \\)，越接近1越好。\n（二）R²为负的原因\n• 模型性能极差：当 \\( \\sum (y_i - \\hat{y}_i)^2 \u003e \\sum (y_i - \\bar{y})^2 \\)，即模型预测比直接取均值更差。\n• 可能原因：\n数据存在严重噪声或非线性关系未被捕捉。 特征与目标变量无关，模型欠拟合。 四、非线性关系的拟合方法\n（一）问题分析\n直接使用线性回归无法捕捉特征与目标变量之间的非线性关系（如二次函数），导致预测性能下降。\n（二）改进方法\n多项式特征扩展：\n• 添加特征的高次项（如 \\( x^2, x^3 \\)）或交互项（如 \\( x_1 x_2 \\)）。\n• 代码示例：\npoly = PolynomialFeatures(degree=2) X_poly = poly.fit_transform(X) 核方法（Kernel Trick）：\n• 将特征映射到高维空间，间接实现非线性拟合。\n树模型（如决策树、随机森林）：\n• 直接处理非线性关系，但需牺牲模型可解释性。\n（三）实验中的应用建议\n• 在步骤二中引入 PolynomialFeatures 生成多项式特征，再使用线性回归拟合。\n结论\n实验通过标准化处理提升模型稳定性，利用线性回归解析解高效求解参数，并通过评估指标验证模型性能。针对非线性关系，可通过特征工程扩展模型表达能力。\n","permalink":"https://oNya685.github.io/posts/buaa/ml/report-1/","summary":"\u003cp\u003e机器学习实验报告\u003c/p\u003e\n\u003chr\u003e\n\u003cp\u003e一、数据预处理：归一化与标准化处理\u003cbr\u003e\n（一）实验中的预处理方法\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e是否进行归一化/标准化\u003cbr\u003e\n实验中使用了 标准化（Standardization） 处理，具体代码为：\u003c/p\u003e","title":"[BUAA-ML] 第一次实验报告"},{"content":"一、思考题 Thinking 3.1 请结合MOS中的页目录自映射应用解释代码中 e-\u0026gt;env_pgdir[PDX(UVPT)] = PADDR(e-\u0026gt;env_pgdir) | PTE_V 的含义。\nUVPT是用户页表的起始虚拟地址，所以e-\u0026gt;env_pgdir[PDX(UVPT)]是当前进程的虚拟内存中，UVPT地址所在的页目录项。而e-\u0026gt;env_pgdir是当前进程页目录的虚拟地址，PADDR(e-\u0026gt;env_pgdir)则是其物理地址，| PTE_V是附上权限位。\n这句赋值语句的含义是，将访问UVPT时解析的页目录项映射到的页框号设置为页目录的物理地址所在页的页框号，并附上权限位。\nThinking 3.2 elf_load_seg 以函数指针的形式，接受外部自定义的回调函数 map_page。请你找到与之相关的data这一参数在此处的来源，并思考它的作用。没有这个参数可不可以？为什么？\ndata 是传入load_icode函数的参数中的指向一个进程控制块的指针(struct Env *)。\n不能没有这个参数。它的作用是传入load_icode_mapper类型转换为进程控制块指针，获取其env_pgdir并对其进程空间执行page_insert。缺少该参数则无法正常运行load_icode_mapper。\nThinking 3.3 结合 elf_load_seg 的参数和实现，考虑该函数需要处理哪些页面加载的情况。\nint elf_load_seg(Elf32_Phdr *ph, const void *bin, elf_mapper_t map_page, void *data) { u_long va = ph-\u0026gt;p_vaddr; size_t bin_size = ph-\u0026gt;p_filesz; size_t sgsize = ph-\u0026gt;p_memsz; u_int perm = PTE_V; if (ph-\u0026gt;p_flags \u0026amp; PF_W) { perm |= PTE_D; } int r; size_t i; u_long offset = va - ROUNDDOWN(va, PAGE_SIZE); // 1.非页对齐的段起始地址 // 当段的虚拟地址va不是页对齐的（offset != 0），函数会先映射一个不完整的页，加载文件中对应的部分数据到该页的偏移位置。 if (offset != 0) { if ((r = map_page(data, va, offset, perm, bin, MIN(bin_size, PAGE_SIZE - offset))) != 0) { return r; } } // 2.逐页加载文件数据 // 对于段中包含文件数据的部分（bin_size范围内），函数分页处理，每页调用map_page，将文件数据加载到对应虚拟地址。 /* Step 1: load all content of bin into memory. */ for (i = offset ? MIN(bin_size, PAGE_SIZE - offset) : 0; i \u0026lt; bin_size; i += PAGE_SIZE) { if ((r = map_page(data, va + i, 0, perm, bin + i, MIN(bin_size - i, PAGE_SIZE))) != 0) { return r; } } // 3.内存扩展分配与零初始化 // 当段的内存大小sgsize大于文件大小bin_size时，函数继续分配页并初始化为零，确保段在内存中完整分配。 /* Step 2: alloc pages to reach `sgsize` when `bin_size` \u0026lt; `sgsize`. */ while (i \u0026lt; sgsize) { if ((r = map_page(data, va + i, 0, perm, NULL, MIN(sgsize - i, PAGE_SIZE))) != 0) { return r; } i += PAGE_SIZE; } return 0; } Thinking 3.4 思考上面这一段话，并根据自己在Lab2中的理解，回答：\n你认为这里的env_tf.cp0_epc存储的是物理地址还是虚拟地址? epc存储的是虚拟地址。\nThinking 3.5 试找出0、1、2、3号异常处理函数的具体实现位置。8号异常（系统调用）涉及的do_syscall()函数将在Lab4中实现。\n0、1、2、3号异常处理函数的具体实现在genex.S中。\nThinking 3.6 阅读entry.S、genex.S和env_asm.S这几个文件，并尝试说出时钟中断在哪些时候开启，在哪些时候关闭。\n在entry.S中关闭时钟中断； 在env_asm.S中重置时钟； 在genex.S中开启时钟中断。\nThinking 3.7 阅读相关代码，思考操作系统是怎么根据时钟中断切换进程的。\n在进程运行时触发时钟中断，跳转exc_gen_entry，进入hande_int，从而通过schedule进行调度切换进程。\n二、难点分析与实验体会 1. 进程的内存空间分布 进程的内存空间由页目录和页表进行管理，页目录项自映射使得页目录本身的物理地址能够被映射到虚拟地址空间（如UVPT）。这为内核提供了直接访问进程页目录的能力，方便进行页表操作和内存空间的管理。 进程的用户态页面（如代码段、数据段、堆栈等）通过页目录和页表进行映射，系统调用elf_load_seg等函数时，会根据 ELF 文件的程序头部信息，将文件中的代码和数据段加载到相应的虚拟地址，并设置正确的页权限。 2. 中断的处理流程 中断处理从硬件触发开始，CPU在检测到中断信号后，会暂停当前进程的执行，保存当前的执行上下文（如cp0_epc寄存器保存中断发生时的指令指针），并将控制权转移到中断处理程序。 时钟中断通过genex.S中的异常处理入口exc_gen_entry进行处理。内核会根据中断类型调用相应的处理函数，如时钟中断主要用于进程调度，通过调用schedule函数实现进程的切换。 中断处理需要考虑中断源的多样性，包括时钟中断、外部设备中断、软件异常等，并执行相应的处理逻辑。 三、原创说明 无参考资料。\n","permalink":"https://oNya685.github.io/posts/buaa/os/lab-3-report/","summary":"\u003ch1 id=\"一思考题\"\u003e一、思考题\u003c/h1\u003e\n\u003ch2 id=\"thinking-31\"\u003eThinking 3.1\u003c/h2\u003e\n\u003cblockquote\u003e\n\u003cp\u003e请结合MOS中的页目录自映射应用解释代码中 \u003ccode\u003ee-\u0026gt;env_pgdir[PDX(UVPT)] = PADDR(e-\u0026gt;env_pgdir) | PTE_V\u003c/code\u003e 的含义。\u003c/p\u003e\u003c/blockquote\u003e\n\u003chr\u003e\n\u003cp\u003e\u003ccode\u003eUVPT\u003c/code\u003e是用户页表的起始虚拟地址，所以\u003ccode\u003ee-\u0026gt;env_pgdir[PDX(UVPT)]\u003c/code\u003e是当前进程的虚拟内存中，\u003ccode\u003eUVPT\u003c/code\u003e地址所在的页目录项。而\u003ccode\u003ee-\u0026gt;env_pgdir\u003c/code\u003e是当前进程页目录的虚拟地址，\u003ccode\u003ePADDR(e-\u0026gt;env_pgdir)\u003c/code\u003e则是其物理地址，\u003ccode\u003e| PTE_V\u003c/code\u003e是附上权限位。\u003c/p\u003e","title":"[BUAA-OS] Lab 3 实验报告"},{"content":" 几千字的流水账真的会有人从头看到尾吗（？\n不按作业的要求顺序来了，有意思的放最前，重要的放其次，其余的往后排。\n我们真的需要一台电梯么？ 首先，回顾一下作业要求：我们要模拟六台电梯的运行、调度，和其开关门、移动、对乘客的接、送行为，其中大部分行为需要等待一定的现实时间。而评测要求我们在每一状态转移完成时输出一条信息，以供测评评测机中模拟的电梯状态机是否在符合正确性规范的前提下完成功能，并评测性能。\n为什么是状态机 Everything is a state machine.\n经常上OS的同学都知道，状态机是一种表示可数个（我想表达的意思是，可以依据规律枚举、列举出，即使有无限种）状态以及在这些状态之间的转移和动作等行为的数学模型。\n我们看该单元的电梯系统的架构设计：绝大部分同学（不如说难道还有用其他架构的吗）采取的是这样一种“三段式架构”：\n$$输入线程 \\rightarrow 请求队列 \\rightarrow 分配器线程 \\rightarrow 等待队列 \\rightarrow 电梯线程$$当然，根据大家设计的不同，可能还有其他的共享对象或者其他的箭头关系（主要取决于应对电梯踢人OUT-F和接受临时调度、Update等奇葩请求的设计）。\n而电梯是如何决策其状态转移的呢？电梯有如下状态等：当前楼层，是否开门，等待（下称pending）队列，电梯内乘客队列（下称current）。在第一次作业我们就实现了这样一个状态机：采用ALS, LOOK, 或者其他的什么算法。我采用的是出于优先级考虑的，在高覆盖率的同时降低加权平均等待时间的改进的LOOK算法。\nexecutions的引入 那么，这一状态机的输入是什么？\n回顾我们的架构设计，理所当然的，我们会说：输入当然是分配器分配给该电梯的等待队列，吗？\n事实上，其决策并不依赖输入，换言之，并不是只有有新的请求时电梯才会动的。即使没有请求，电梯也会把自己唤醒，逐步更新自己的状态，直到回归pending和current都变为空的状态。\n也就是说，在任一时刻，若假定该状态机不再会有新的输入（不再分配新的请求），那我们就能推演出该状态机的后续所有行为。 所以，在后文中，我们暂且规定，称“状态机”为这种没有输入的，自动决策状态转移的状态机。 有没有很像上学期计组做的那个CPU，把机器码记录在文件中加载出来，就能自动执行状态转移？如果把CPU和记录机器码的存储设备框在一起，而不认为机器码是一种输入。把机器码比作pending和current中的数据，和这一单元的电梯是不是很像？\n那我们还该如何定义“分配新请求”这种行为呢？很简单，每次分配了新请求，或者告诉电梯要进行SCHE或UPDATE时，我们可以重新计算一遍该电梯从当前状态作所有决策，直到回归空闲状态这一区间中，所有的状态转移，并将其更新给电梯线程，电梯线程依次执行即可。\n这里，我们引入一个队列 LinkedList\u0026lt;Executeable\u0026gt; executions。用以存储当前电梯所有的状态转移行为，依次执行完就可以抵达名为空闲的终点。\nInterface Executeable，要求实现方法execute(Elevator elevator); 执行时实现状态转移，更新电梯的当前状态\n解构一台电梯 我们实现了对电梯这一对象的逐步解构：现在你还可以坚持称电梯线程在模拟一台电梯，实际上它在做的事情只有：计算executions，execute执行，或者当时间条件不满足时await()。\n下述是对该电梯完全解构的最后一步：把计算executions的工作交给分配器\n为什么要这么做？这么做有什么好处？我们考虑分配器的如下分配策略：\n分配器现在需要分配某乘客请求给六台电梯中的任一台，如果可以的话，它希望知道分配给具体哪一台电梯能获得最优性能。（当然，不可以的话，随机挑一台塞进去也不是不能跑） 既然对分配器想要分配的这一时刻来说，每一台电梯的接下来的所有行为都是已知的，那么每一台电梯接下来的行为可以用以计算其成本。 那么，分配器想知道分配给哪一台电梯能让总成本最低，就会依次尝试把乘客请求分配给其中某一台电梯的情况，并希望知道其总成本：这样，选出总成本最低的一种情况，不就是局部的、已知的最优策略了么。相当于在若干条时间线，选了最完美的一条。 但是，怎么知道每一台电梯接下来的行为，甚至是，每一台电梯在接受了当前乘客请求的这一IF线下，接下来的行为呢？我们刚才已经讨论过了，既然是状态机，那么必然是可以计算的。 把电梯线程叫醒帮自己计算看上去不太现实（事实上也不太现实），那就自己计算吧，把六个状态机的状态拷贝一份，再创造六个接受了当前乘客分配的IF线状态机，选出最好的一条IF线，并拿这个IF线状态机替换掉真正的状态机，狸猫换太子，就实现了最优分配策略。 那，算都算完了，电梯线程偷个懒不算了，拿着分配器算好的executions，到时间就执行并且输出就好了。 影子电梯：但是只有影子电梯 至此，这一臃肿的、模拟真实电梯运行的线程的工作，只剩下：维护一个状态已知、接下来所有状态转移已知的状态机，到了时间就给状态机执行一步状态转移并输出，没到时间就回去等着。\n那么，电梯还存在吗？或许游离于分配器的心中，或许藏匿于状态机的状态里，又或许闪烁在评测机的眼中，反正不可能说它存在于电梯线程的模拟中了，这么说电梯线程也不能答应的，它只是拿着一串executions，到时间就输出出来而已，连execute都是封装好的。所以我称这样的“电梯线程”为Class Printer extends Thread，它就是一台到时间就自动打印的打印机而已。\n按道理来说，贴代码是没人有心思看的，自己的代码自己迭代时都懒得读，但是这是这个线程所剩下的全部内容了，还是读一下吧？ 为可读性优化和简化了部分，所以算伪代码。\npublic void run() { long lastTime = System.currentTimeMillis(); lock.lock(); // 为方便读，这里省掉了await的try-catch包装块。 while (true) { ExecuteAble execution = null; // 瞬间的行为，循环依次完成。 while (!executions.isEmpty()) { execution = executions.getFirst(); if (needTimeToExecute(execution)) { break; } lastTime = executeAndUpdate(execution, lastTime); } // 空闲状态，尝试结束或等待新任务的分配。 if (executions.isEmpty()) { if (end) { break; } MainProcess.signalDispatcher(); printable.await(); continue; } // 非瞬间行为，判断是否满足执行条件，失败则等待。 long timeToWait = lastTime + needTimeMap.get(execution) - System.currentTimeMillis(); if (timeToWait \u0026lt;= 0) { lastTime = executeAndUpdate(execution, lastTime); } else { printable.await(timeToWait, TimeUnit.MILLISECONDS); } } lock.unlock(); } 于是，我们实现了所谓影子电梯，证明了影子电梯的可行性，但是全部都是影子电梯。与其说分配器是通过影子电梯计算出分配给具体哪一台真正的电梯，不如说分配器是拿一台更新后的影子电梯换掉了原来的影子电梯。\n既然影子电梯可行，如何适应性能指标？ 现在谈谈该调度策略是如何权衡总时间、加权平均时间和电量的：\n首先，我们要尽量降低总时间$T_{run}$：这一性能指标显然比另外两个重要的多，如果为追求低功耗而$T_{run}$过大，我们甚至会被判断为效率太低而超时，而平均分配、随机分配等方法，也都是在放弃对于加权平均时间和功耗的考量下，追求$T_{run}$的解法。 但是，$T_{run}$有两个特性：\n一是对于所有电梯来说，只有最大的$T_{run}$是有意义的，当其中一台电梯的总时间很长，而给其他某台电梯分配了请求后总时间依然不比最长的总时间长，那么$T_{run}$是没有变化的，此时追求降低$T_{run}$是一种没太大意义的行为。 二是对于当前$T_{run}$最大的电梯来说，捎带请求是一种以牺牲少量$T_{run}$换取极大加权平均时间和功耗上收益的决策。代价是你需要花额外0.4s的$T_{run}$在这一层停下并开关门，性能上却相当划算。 因此，在六台电梯分别接受分配请求的时间线中，我选出所有接受分配请求后，$\\Delta T_{run} \\leq 1s$的时间线并纳入考虑，如果没有符合条件的，则选出$T_{run}$增加值最小的一种情况直接作为分配结果。\n接下来我们就可以不考虑$T_{run}$对性能的影响了，即使还有影响，也不到1s，可以大致忽略。我们要考虑，经过筛选后的若干种情况里，加权平均时间$wT$和功耗$W$综合最优的一种情况。但由于性能分是与同学们排名后计算的，我并不知道怎样取得综合最优，理论上我们需要满足：\n$$\\begin{align*} \\Delta \\text{cost} \u0026= a \\Delta wT + b \\Delta W, \\quad a + b = 1 \\\\ \\begin{pmatrix} a \u0026 b \\end{pmatrix} \u0026= \\arg\\min \\Delta \\text{cost} \\end{align*}$$我取$\\begin{pmatrix} a \u0026amp; b \\end{pmatrix} = \\begin{pmatrix} \\frac{10}{10+1} \u0026amp; \\frac{1}{10+1} \\end{pmatrix}$，最后效果尚可。\n双轿厢：线程协作是否应该影响对象行为？ 我们已经论述过了，时间是线程（具体来讲，是Printer这一打印机线程）要考虑的，线程是动态的、连续的，共享对象只有状态，是静态的、瞬间的。\n所以双轿厢电梯的行为，是共享对象所考虑的，同步开始改造和避免相撞却是线程所需保证的。\n具体来讲，我们采取的策略是到达临界楼层后，通过锁等方式让协作线程若有需求先等待自己完成任务，自己完成后尽快退出临界楼层（当然该行为也是共享对象所存储的，而非线程唤起的），放还锁让协作线程继续动态行为。\n而在同步改造方面：\n当两电梯的下一execution均为UPDATE-BEGIN时，由分配器输出UPDATE-BEGIN并唤醒两打印机线程进入计时。两线程共享一把锁。 其中一台电梯UPDATE-BEGIN时锁上共享锁，UPDATE-END时先输出UPDATE-END，然后放还共享锁。 另一台电梯不输出，UPDATE-BEGIN时无行为，但UPDATE-END时先尝试拿到共享锁，拿到后立即放还，然后才执行自己的后续操作。 这样，我们就实现了两协作线程的同步。 在这一过程中，线程间的交互不对对象状态产生影响，只对状态转移的时间，即线程行为有所限制。故而，线程协作不影响对象行为。\n接下来补充比较重要的内容。\n架构设计 很明显能看出三段的设计：$线程-共享对象-线程-共享对象-线程$。\n前文已介绍过该架构的工作流程，在第一次作业中，我采用与大家相同的架构，而在第二次作业的重构中，我将电梯线程的功能解构提取，变成了如上的只保留简单功能的PrinterThread。第三次作业中，无新增类。\n值得介绍的是Scheduler类，其包装了该状态机的决策行为，也即其所有的状态转移计算过程。通过封装Scheduler，我们实现了电梯决策器的可拓展性：当我们需要更换、优化电梯算法，只需要换一个Scheduler或者继承原Scheduler即可。\n这里给出一种性能优化思路，配备多种Scheduler，考虑每种电梯装载不同Scheduler，采取不同算法的时间线，并综合总的性能考量，返回给各状态机最优的executions。但该方法的计算量预估提升了一个数量级，为避免CTLE，应谨慎考虑。\n线程协作 上图已明了介绍线程中的协作关系，此处详细解释最后的线程结束的判定：\n首先，输入线程的结束条件很清晰：读取到值为null的请求时。 但对于Request Queue来说，输入线程与六个电梯线程同时作为生产者，分配器作为消费者；同时，对于每个电梯状态机，分配器是生产者，电梯线程是消费者。 这就形成了一个圈：分配器与电梯互为消费者和生产者，而生产者没有结束时，消费者自然不可以结束。 因此，我们重新定义电梯线程作为生产者的结束：当其executions为空，即空闲状态下，它自然不可能再放归新的请求，我们可以认为其处于临时的结束状态。 而对于此时的调度器，倘若没有需要分配的请求，其会尝试结束： 输入线程已结束 各电梯线程处于空闲状态 也即对于RequestQueue，不会有新的生产，也因此没有消费行为和消费行为导致的新的生产。 此时调度器可以认为达到结束条件，结束自身线程并对后续所有线程设置结束。 有趣的和重要的均已结束，现在补充作业要求的其他内容。\n易变的内容 稳定的内容已于上文完成分析，而易变的内容，我们需着眼分析两个“例外”：SCHE和UPDATE。\n对于SCHE，我选择将ScheBegin和ScheEnd纳入Executeable范畴，将其视为状态机的正常状态转移行为，从而使其回归稳定的内容的体系； 对于UPDATE大体相同，但UPDATE-BEGIN实在太特殊，为了两电梯之间的同步，我将其设置为电梯的一种新的状态并因此补充了大量特判，这也是引发我bug的直接原因：补丁没打全。 Bug分析与Debug方法 第一二次作业无bug，对第三次作业的UPDATE-BEGIN处理引发了第三次作业的bug，并直接导致了强测爆炸：\n对于UPDATE-ACCEPT前分配给电梯的请求，经过改造后并不一定能接受，因为其所在楼层不一定属于自己所能移动的范围内。而为了避免UPDATE和SCHE之间无法RECEIVE请求导致分配器轮询，我为每个电梯配置RECEIVE请求缓存区，囤积在END后再输出，因此错过了UPDATE-BEGIN时清空当前已RECEIVE请求的机会，从而可能RECEIVE改造后无法处理的请求。\n改正方法为：UPDATE开始时清除RECEIVE缓存区中自己改造后无法处理的请求。\nDebug方法为输出。当debug模式启用时，输出各关键行为前后的线程状态、状态机状态。\n// MainProcess.java public static boolean debug() { return false; } 虽然本次作业没有要求课程建议，但是实在很想建议：\n能不能给一个TimableOutput.debug(String string)然后输出内容不计入评测，只供debug时便于人类查看，间接解决掉评测出的bug在本地无法复现的问题？这样只要写好关键步骤的日志，就能快速定位到bug，即使本地无法复现也可以正常修复？\n线程安全与层次化设计 锁的合理使用 在本次作业中，线程安全是至关重要的。尤其是在处理多线程的电梯调度和状态更新时，锁的使用非常关键。例如，在电梯线程和分配器线程之间共享的状态机状态（如电梯的当前楼层、电梯内乘客队列等）必须通过锁来保证线程安全。 我们使用了ReentrantLock来确保在更新状态时不会出现竞态条件。例如，在电梯线程执行状态转移时，需要对executions队列进行操作，此时必须加锁，防止分配器线程同时修改该队列。同时，锁的使用也需要谨慎，避免死锁的发生。在电梯线程和分配器线程之间，我们通过合理的锁顺序和锁的释放时机来避免死锁。 使用ReentrantLock有什么好处？条件管理更灵活，而且锁可以脱离对象或代码块而存在，请看使用了ReentrantLock的影子电梯的名场面六把锁： elevators.forEach(Elevator::lock); // 计算与分配 elevators.forEach(Elevator::unlock); 线程间通信的同步机制 线程间通信的安全性也是线程安全的重要方面。在本次作业中，电梯线程和分配器线程之间通过executions队列进行通信，而这个队列的更新和读取必须是线程安全的。 我们使用了Condition来实现线程间的同步。例如，当电梯线程处于空闲状态时，它会调用await()等待分配器线程的信号。分配器线程在计算出新的executions后，会调用signal()唤醒电梯线程。这种同步机制确保了线程间通信的正确性和及时性。 同时，在处理双轿厢电梯的同步（改造期间）与互斥（临界楼层）时，我们通过共享一把ReentrantLock来实现两台电梯线程之间的同步。这种同步机制不仅保证了线程安全，还避免了电梯之间的冲突。 架构设计的层次化 层次化设计使得代码更加清晰和易于维护。在本次作业中，我们将整个电梯系统划分为多个功能模块，每个模块负责特定的功能。 例如，输入线程负责读取请求并将其放入请求队列；分配器线程负责从请求队列中取出请求并分配给电梯；电梯线程负责执行电梯的状态转移。这种模块划分使得每个线程的功能单一，便于理解和维护。 同时，我们还引入了Scheduler类来封装电梯的状态转移计算逻辑。这样，当需要更换或优化电梯算法时，只需要修改Scheduler类，而不需要修改电梯线程的代码。这种层次化设计提高了代码的可扩展性和可维护性。 ","permalink":"https://oNya685.github.io/posts/buaa/oo/unit-2/summary/","summary":"\u003cblockquote\u003e\n\u003cp\u003e几千字的流水账真的会有人从头看到尾吗（？\u003c/p\u003e\n\u003cp\u003e不按作业的要求顺序来了，有意思的放最前，重要的放其次，其余的往后排。\u003c/p\u003e\u003c/blockquote\u003e\n\u003ch1 id=\"我们真的需要一台电梯么\"\u003e我们真的需要一台电梯么？\u003c/h1\u003e\n\u003cp\u003e首先，回顾一下作业要求：我们要\u003cstrong\u003e模拟\u003c/strong\u003e六台电梯的运行、调度，和其开关门、移动、对乘客的接、送行为，其中大部分行为需要等待一定的\u003cstrong\u003e现实时间\u003c/strong\u003e。而评测要求我们在每一\u003cstrong\u003e状态转移完成\u003c/strong\u003e时输出一条信息，以供测评\u003cstrong\u003e评测机中模拟的电梯状态机\u003c/strong\u003e是否在\u003cstrong\u003e符合正确性规范\u003c/strong\u003e的前提下\u003cstrong\u003e完成功能\u003c/strong\u003e，并\u003cstrong\u003e评测性能\u003c/strong\u003e。\u003c/p\u003e","title":"[BUAA-OO] Unit 2 总结"},{"content":"点此查看作业源文件 1. 读者写者问题（写者优先） 共享读; 互斥写、读写互斥; 写者优先于读者（一旦有写者，则后续读者必须等待，唤醒时优先考虑写者）。 semaphore room_empty = 1; // 读写互斥 semaphore mutex_read = 1; // 保护 read_count semaphore mutex_write = 1; // 保护 write_count semaphore write_priority = 1; // 写者优先锁 int read_count = 0, write_count = 0; void reader() { P(write_priority); // 检查是否有写者等待 P(mutex_read); read_count++; if (read_count == 1) { P(room_empty); // 第一个读者获取读写锁 } V(mutex_read); V(write_priority); // 释放写者优先锁 // 读取 P(mutex_read); read_count--; if (read_count == 0) { V(room_empty); // 最后一个读者释放读写锁 } V(mutex_read); } void writer() { P(mutex_write); write_count++; if (write_count == 1) { P(write_priority); // 第一个写者阻止新读者 } V(mutex_write); P(room_empty); // 获取读写锁 // 写入 V(room_empty); P(mutex_write); write_count--; if (write_count == 0) { V(write_priority); // 最后一个写者允许新读者 } V(mutex_write); } 2. 寿司店问题 假设一个寿司店有5个座位，如果你到达的时候有一个空座位，你可以立刻就坐。但是如果你到达的时候5个座位都是满的有人已经就坐，这就意味着这些人都是一起来吃饭的，那么你需要等待所有的人一起离开才能就坐。编写同步原语，实现这个场景的约束。\nsemaphore mutex = 1; // 保护共享变量 semaphore batch_lock = 1; // 批次锁 semaphore waiting = 0; // 等待新批次 int count = 0; // 当前批次人数 void customer() { CONSUME: P(mutex); if (count == 0) { // 新批次开始 P(batch_lock); // 获取批次锁 } if (count \u0026lt; 5) { count++; V(mutex); // 就坐 // 离开 P(mutex); count--; if (count == 0) { // 批次结束，唤醒等待者 V(batch_lock); for (int i = 0; i \u0026lt; 5; i++) { V(waiting); // 唤醒最多5人 } } V(mutex); } else { V(mutex); P(waiting); // 等待新批次 // 上一批次结束，被唤醒 goto CONSUME; } } 3. 进门问题。 （1）请给出P、V操作和信号量的物理意义。 信号量的物理意义：信号量是一种同步机制，用于控制多个进程/线程对共享资源的访问。可以看作是一个计数器，表示当前可用的资源数量或某种状态。 P操作的物理意义：表示申请资源。在互斥访问中，P(S) 相当于加锁。 V操作的物理意义：表示释放资源，如果有进程在等待该资源，则唤醒其中一个。在互斥访问中，V(S) 相当于解锁。 （2）一个软件公司有5名员工，每人刷卡上班。员工刷卡后需要等待，直到所有员工都刷卡后才能进入公司。为了避免拥挤，公司要求员工一个一个通过大门。所有员工都进入后，最后进入的员工负责关门。请用P、V操作实现员工之间的同步关系。 semaphore barrier = 0; // 等待所有员工到达 semaphore door = 1; // 控制逐个通过 semaphore mutex = 1; // 保护计数器 int count = 0; void employee() { P(mutex); count++; if (count == 5) { V(barrier); // 第5人触发屏障 } V(mutex); P(barrier); // 所有员工等待在此 V(barrier); // 保持屏障信号 P(door); // 通过大门 V(door); P(mutex); count--; if (count == 0) { // 关门 } V(mutex); } 4. 搜索-插入-删除问题。 三个线程对一个单链表进行并发的访问，分别进行搜索、插入和删除。搜索线程仅仅读取链表，因此多个搜索线程可以并发。插入线程把数据项插入到链表最后的位置；多个插入线程必须互斥防止同时执行插入操作。但是，一个插入线程可以和多个搜索线程并发执行。最后，删除线程可以从链表中任何一个位置删除数据。一次只能有一个删除线程执行；删除线程之间，删除线程和搜索线程，删除线程和插入线程都不能同时执行。\n请编写三类线程的同步互斥代码，描述这种三路的分类互斥问题。\nsemaphore search_mutex = 1; // 搜索并发控制 semaphore insert_mutex = 1; // 插入互斥 semaphore delete_mutex = 1; // 删除独占 int search_count = 0; void search() { P(search_mutex); search_count++; if (search_count == 1) { P(delete_mutex); // 阻止删除 } V(search_mutex); // 搜索 P(search_mutex); search_count--; if (search_count == 0) { V(delete_mutex); } V(search_mutex); } void insert() { P(insert_mutex); // 插入互斥 // 插入 V(insert_mutex); } void delete() { P(delete_mutex); // 独占删除 // 删除 V(delete_mutex); } ","permalink":"https://oNya685.github.io/posts/buaa/os/homework-4/","summary":"\u003cp\u003e\u003cstrong\u003e\u003ca href=\"%e4%bd%9c%e4%b8%9a4.pdf\" target=\"_blank\"\u003e点此查看作业源文件\u003c/a\u003e\n\u003c/strong\u003e\u003c/p\u003e\n\u003ch1 id=\"1-读者写者问题写者优先\"\u003e1. 读者写者问题（写者优先）\u003c/h1\u003e\n\u003col\u003e\n\u003cli\u003e共享读;\u003c/li\u003e\n\u003cli\u003e互斥写、读写互斥;\u003c/li\u003e\n\u003cli\u003e写者优先于读者（一旦有写者，则后续读者必须等待，唤醒时优先考虑写者）。\u003c/li\u003e\n\u003c/ol\u003e\n\u003chr\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c\" data-lang=\"c\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esemaphore room_empty \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e;      \u003cspan style=\"color:#75715e\"\u003e// 读写互斥\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003esemaphore mutex_read \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e;      \u003cspan style=\"color:#75715e\"\u003e// 保护 read_count\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003esemaphore mutex_write \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e;     \u003cspan style=\"color:#75715e\"\u003e// 保护 write_count\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003esemaphore write_priority \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e;  \u003cspan style=\"color:#75715e\"\u003e// 写者优先锁\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e read_count \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e, write_count \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003ereader\u003c/span\u003e() {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#a6e22e\"\u003eP\u003c/span\u003e(write_priority);         \u003cspan style=\"color:#75715e\"\u003e// 检查是否有写者等待\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e    \u003cspan style=\"color:#a6e22e\"\u003eP\u003c/span\u003e(mutex_read);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    read_count\u003cspan style=\"color:#f92672\"\u003e++\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003eif\u003c/span\u003e (read_count \u003cspan style=\"color:#f92672\"\u003e==\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#a6e22e\"\u003eP\u003c/span\u003e(room_empty);         \u003cspan style=\"color:#75715e\"\u003e// 第一个读者获取读写锁\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#a6e22e\"\u003eV\u003c/span\u003e(mutex_read);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#a6e22e\"\u003eV\u003c/span\u003e(write_priority);         \u003cspan style=\"color:#75715e\"\u003e// 释放写者优先锁\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e    \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#75715e\"\u003e// 读取\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e    \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#a6e22e\"\u003eP\u003c/span\u003e(mutex_read);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    read_count\u003cspan style=\"color:#f92672\"\u003e--\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003eif\u003c/span\u003e (read_count \u003cspan style=\"color:#f92672\"\u003e==\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#a6e22e\"\u003eV\u003c/span\u003e(room_empty);           \u003cspan style=\"color:#75715e\"\u003e// 最后一个读者释放读写锁\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#a6e22e\"\u003eV\u003c/span\u003e(mutex_read);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003ewriter\u003c/span\u003e() {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#a6e22e\"\u003eP\u003c/span\u003e(mutex_write);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    write_count\u003cspan style=\"color:#f92672\"\u003e++\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003eif\u003c/span\u003e (write_count \u003cspan style=\"color:#f92672\"\u003e==\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#a6e22e\"\u003eP\u003c/span\u003e(write_priority);     \u003cspan style=\"color:#75715e\"\u003e// 第一个写者阻止新读者\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#a6e22e\"\u003eV\u003c/span\u003e(mutex_write);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#a6e22e\"\u003eP\u003c/span\u003e(room_empty);             \u003cspan style=\"color:#75715e\"\u003e// 获取读写锁\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e    \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#75715e\"\u003e// 写入\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\t\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#a6e22e\"\u003eV\u003c/span\u003e(room_empty);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#a6e22e\"\u003eP\u003c/span\u003e(mutex_write);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    write_count\u003cspan style=\"color:#f92672\"\u003e--\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003eif\u003c/span\u003e (write_count \u003cspan style=\"color:#f92672\"\u003e==\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#a6e22e\"\u003eV\u003c/span\u003e(write_priority);     \u003cspan style=\"color:#75715e\"\u003e// 最后一个写者允许新读者\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#a6e22e\"\u003eV\u003c/span\u003e(mutex_write);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch1 id=\"2-寿司店问题\"\u003e2. 寿司店问题\u003c/h1\u003e\n\u003cp\u003e假设一个寿司店有5个座位，如果你到达的时候有一个空座位，你可以立刻就坐。但是如果你到达的时候5个座位都是满的有人已经就坐，这就意味着这些人都是一起来吃饭的，那么你需要等待所有的人一起离开才能就坐。编写同步原语，实现这个场景的约束。\u003c/p\u003e","title":"[BUAA-OS] 理论作业 4"},{"content":"一、思考题 Thinking 2.1 请根据上述说明，回答问题：在编写的 C 程序中，指针变量中存储的地址被视为虚拟地址，还是物理地址？MIPS 汇编程序中 lw和sw 指令使用的地址被视为虚拟地址，还是物理地址？\n都是虚拟地址。本质都是翻译为含虚拟地址的机器码，交由CPU进行访存。\nThinking 2.2 请思考下述两个问题：\n从可重用性的角度，阐述用宏来实现链表的好处。 查看实验环境中的/usr/include/sys/queue.h，了解其中单向链表与循环链表的实现，比较它们与本实验中使用的双向链表，分析三者在插入与删除操作上的性能差异。 通过宏定义，该链表实现了对于各种类型的可重用性。 上机后补充：例如MBlock与其field（mb_link），可以直接使用该链表以及操作链表的宏（例如LIST_INSERT_AFTER与LIST_REMOVE）。 比较单向链表、循环链表与双向链表： 操作 单向链表 循环链表 双向链表 插入 性能相似，但插入到尾结点需要完整遍历链表 性能相似，但插入到尾结点更快 性能相似，但插入到尾结点需要完整遍历链表 删除 需要找上一结点的位置，O(n) 性能与双向链表相似 性能与循环链表相似 Thinking 2.3 请阅读include/queue.h以及include/pmap.h,将Page_list的结构梳理清楚，选择正确的展开结构。\n选C。\n首先，le_prev是指向前继结点的后继指针的指针，类型是struct Type **，排除A。\n其次，lh_first是指向链表首结点的指针，类型是struct Type *，排除B。\nThinking 2.4 请思考下面两个问题：\n请阅读上面有关TLB的描述，从虚拟内存和多进程操作系统的实现角度，阐述ASID的必要性。 请阅读 MIPS 4Kc 文档《MIPS32® 4K™ Processor Core Family Software User’s Manual》的 Section 3.3.1 与 Section 3.4，结合 ASID 段的位数，说明 4Kc 中可容纳不同的地址空间的最大数量。 某一虚拟地址在不同地址空间中可以被映射到不同物理地址，所以需要ASID以确定地址空间。\n可容纳最多64个不同的地址空间。\nInstead, the OS assigns a 6-bit unique code to each task’s distinct address space. Since the ASID is only 6 bits long, OS software does have to lend a hand if there are ever more than 64 address spaces in concurrent use; but it probably won’t happen too often. Thinking 2.5 请回答下述三个问题：\ntlb_invalidate和tlb_out的调用关系？ 请用一句话概括tlb_invalidate的作用。 逐行解释tlb_out中的汇编代码。 tlb_invalidate调用了tlb_out。 调用tlb_invalidate可以将该地址与虚拟地址的映射表项从TLB中清除。 tlb_out：用于清除指定虚拟地址对应的TLB表项。通过先保存当前ENTRYHI值，然后设置新的ENTRYHI进行TLB探测，找到对应表项后通过写入空值实现删除，最后恢复原始ENTRYHI值。 LEAF(tlb_out) // 定义名为tlb_out的叶子函数 .set noreorder // 禁止汇编器重新排列指令顺序 mfc0 t0, CP0_ENTRYHI // 将协处理器CP0的ENTRYHI寄存器值保存到t0 mtc0 a0, CP0_ENTRYHI // 将参数寄存器a0的值写入CP0的ENTRYHI寄存器 nop // 空操作，确保mtc0操作完成 /* Step 1: Use \u0026#39;tlbp\u0026#39; to probe TLB entry */ /* Exercise 2.8: Your code here. (1/2) */ tlbp // TLB探测指令，根据ENTRYHI查找匹配的TLB条目 nop // 保证tlbp指令完成 /* Step 2: Fetch the probe result from CP0.Index */ mfc0 t1, CP0_INDEX // 将CP0的INDEX寄存器值读取到t1 .set reorder // 允许汇编器重新排列指令顺序 bltz t1, NO_SUCH_ENTRY // 如果未找到该ENTRY，跳转到NO_SUCH_ENTRY .set noreorder // 再次禁止指令重排 mtc0 zero, CP0_ENTRYHI // 清零CP0的ENTRYHI寄存器 mtc0 zero, CP0_ENTRYLO0 // 清零CP0的ENTRYLO0寄存器 mtc0 zero, CP0_ENTRYLO1 // 清零CP0的ENTRYLO1寄存器 nop // 保证寄存器写入操作完成 /* Step 3: Use \u0026#39;tlbwi\u0026#39; to write CP0.EntryHi/Lo into TLB at CP0.Index */ /* Exercise 2.8: Your code here. (2/2) */ tlbwi // 将当前EntryHi/EntryLo写入TLB表项，删除该条目 .set reorder // 恢复指令重排 NO_SUCH_ENTRY: // 未找到对应TLB条目时的标签 mtc0 t0, CP0_ENTRYHI // 恢复原始ENTRYHI寄存器值 j ra // 函数返回 END(tlb_out) // 函数结束 Thinking 2.6 请结合 Lab2 开始的 CPU 访存流程与下图中的 Lab2 用户函数部分，尝试将函数调用与CPU访存流程对应起来，思考函数调用与CPU访存流程的关系。\n在 Lab2（以及后续实验）中，4Kc CPU 的访存过程可以概括为以下几个关键步骤\n当 CPU 执行一条访存相关的指令（包含取指令、读数据、写数据）时，会把虚拟地址送入 MMU。 MMU 会首先在 TLB 中查找该虚拟地址是否有对应的物理地址映射。 若命中（TLB Hit），CPU 即可直接得知该虚拟地址对应的物理地址，并进行后续的读写缓存或内存操作。 若未命中（TLB Miss），CPU 会触发异常，进入内核执行 TLB refill / page fault 处理流程（视情况而定），由操作系统的异常/中断处理例程负责查找该虚拟地址应对应的物理地址、分配物理页、更新 TLB。 当映射关系建立后，CPU 可以“拿到”正确的物理地址并进行实际的内存（或外设寄存器）读写操作。 在这个过程中，所看到的「kuseg、kseg0、kseg1」等地址段的区别，决定了 CPU 是否直接对高地址位清零映射（无缓存/有缓存）或者需要通过 TLB。对于用户态的地址（kuseg，0x00000000~0x7fffffff），一定要通过 TLB。\n在 Lab2 中，当我们调用函数时，背后的硬件过程正是 CPU 发出虚拟地址、经 TLB 查表或异常处理、进而映射到物理地址并访问内存的流程。函数调用是软件层面分配、管理地址空间的逻辑，而 CPU 访存流程是硬件层面真正将指令和数据从内存取出、写入的机制；两者一一对应、紧密耦合。通过把它们结合起来，我们就能全面理解操作系统与用户态程序在地址空间管理上的工作原理。\nThinking 2.7 从下述三个问题中任选其一回答：\n简单了解并叙述X86体系结构中的内存管理机制，比较X86和MIPS 在内存管理上的区别。 简单了解并叙述RISC-V 中的内存管理机制，比较RISC-V 与 MIPS 在内存管理上的区别。 简单了解并叙述LoongArch 中的内存管理机制，比较 LoongArch 与 MIPS 在内存管理上的区别。 X86 与 MIPS 内存管理的主要区别\n分段机制与固定地址区间 X86：\n传统上依靠分段来实现内存保护和地址转换，虽然现代操作系统多采用扁平模型，但分段概念依然存在，并且在保护模式下提供了多级特权和动态调整段基址的能力。 MIPS：\n使用固定的地址区间划分（如kuseg、kseg0、kseg1），没有灵活的分段机制，内核与用户空间的划分由硬件地址范围直接确定，整体设计更加简单。 分页管理方式 X86：\n采用硬件支持的多级页表结构，地址转换过程由硬件直接完成（结合 TLB 缓存），在现代 x86-64 中使用 4 级或更多级页表，同时支持 PAE 和 NX 等扩展特性。 MIPS：\n通常依赖软件管理的 TLB，当发生 TLB miss 时，通过异常处理由操作系统完成页表查找和 TLB 填充，其页表结构也较为灵活，但整体在硬件自动化管理程度上较 X86 要简单。 TLB 设计 X86：\nTLB 作为硬件缓存，通常与分页机制紧密结合，自动维护地址映射缓存，减少页表查找延迟。 MIPS：\nTLB 由软件管理，需要操作系统在 TLB miss 异常处理程序中主动维护，虽然这种设计在一定程度上降低了硬件复杂性，但对操作系统的设计与调度要求更高。 二、难点分析与实验体会 1. 链表宏的理解与使用 链表中大量指针，指针的指针，混杂在一起，较难理解其具体含义。经过struct Page链表的阅读及补全后初步理解链表宏的使用流程与传参细节。\n2. 二级页表的实现 经过实验代码，我们能发现二级页表的页表项其实是u_long类型，由页框号与有效位组成。通过这一类型的实现有一些反直觉，在理解其为字对齐后便理解了一些实现细节。\n三、原创说明 参考资料：\nMIPS32® 4K™ Processor Core Family Software User’s Manual 全网超详细解析！X86/X64处理器体系结构及寻址模式 - 知乎 X86内存管理机制\u0026ndash;分段机制详析_x86 为什么要这么多段寄存器-CSDN博客 ","permalink":"https://oNya685.github.io/posts/buaa/os/lab-2-report/","summary":"\u003ch1 id=\"一思考题\"\u003e一、思考题\u003c/h1\u003e\n\u003ch2 id=\"thinking-21\"\u003eThinking 2.1\u003c/h2\u003e\n\u003cblockquote\u003e\n\u003cp\u003e请根据上述说明，回答问题：在编写的 C 程序中，指针变量中存储的地址被视为虚拟地址，还是物理地址？MIPS 汇编程序中 lw和sw 指令使用的地址被视为虚拟地址，还是物理地址？\u003c/p\u003e","title":"[BUAA-OS] Lab 2 实验报告"},{"content":"点此查看作业源文件 第一题 （1）请问进程整个的地址空间有多少字节？一页有多少字节？ $$ 进程整个的地址空间 = 2^{32}B = 4GB $$$$一页有 2^{12}B = 4KB$$（2）一个进程如果从 0x80000000 开始映射 4MB 大小页表空间，求第一级页表（页目录）的起始逻辑地址，并指出从哪个逻辑地址可以读出第一级页表（页目录）所在的物理页框号。说明理由。（注意 B 代表字节，一个 32 位地址占 4 字节） 进程页表空间映射起始地址为0x80000000，所以页目录的第0x200项指向页表空间，所以第一级页表的起始逻辑地址为0x80200000。\n页目录自映射，访问逻辑地址0x80200800可以读取页目录所在的物理页框号。\n（3）如果当前进程的页目录物理基地址、页目录和相应页表内容如图下所示，请描述访问以下逻辑地址时系统进行地址转换的过程，如可行，给出最终访存读取到的数据。逻辑地址：0x0、0x00803004、0x00402001 访问0x0： | 0000 0000 00 | 00 0000 0000 | 0000 0000 0000 | 找页目录第0项 -\u0026gt; 页表项内容：00000 | 000 缺页异常 访问0x00803004： | 0000 0000 10 | 00 0000 0011 | 0000 0000 0100 | 找页目录第2项 -\u0026gt; 页表项：00005 | 001 页表地址：0x5000，有效 找页表第3项 -\u0026gt; 页表项：00020 | 001 页地址：0x20000 物理地址：0x20000 + 0x004 = 0x20004 读取到的字为0x326001 读取到的数据：0x00（小端序）或0x01（大端序） 访问0x00402001： | 0000 0000 01 | 00 0000 0010 | 0000 0000 0001 | 找页目录第1项 -\u0026gt; 页表项内容：00001 | 001 页表地址：0x1000，有效 找页表第2项 -\u0026gt; 页表项：00005 | 001 页地址：0x5000 物理地址：0x5000 + 0x001 = 0x5001 读取到的字为0x0 读取到的数据：0x00 （4）要想访问物理地址 0x326028，需要使用哪个逻辑地址？ 页内偏移：0x028 页框号：0x326，出现在0x20000 + 1 * 0x4，所以二级页表号：0x1 页框号：0x20，出现在0x1000 + 3 * 0x4，所以一级页表号：0x3 逻辑地址：| 0000 0000 11 | 00 0000 0001 | 0000 0010 1000 | 即：0x00c01028 第二题 （1）Load [0x00001022] 页目录号：0x000 访问0x0020 0000 + 4 * 0x000 = 0x0020 0000：0x0010 0007 二级页表页框号：0x00100 标志位：0x007，Valid, Read/Write 二级页表号：0x001 访问0x0010 0000 + 4 * 0x001 = 0x0010 0004：0x0000 4067 物理页框号：0x00004 标志位：0x067，Valid, Read/Write 页内偏移量：0x022 访问0x0000 4000 + 0x022 = 0x0000 4022：0x20 成功：0x20 （2）Store [0x00C07222] 页目录号：0x003 访问0x0020 0000 + 4 * 0x003 = 0x0020 000C：0x0010 3007 二级页表页框号：0x00103 标志位：0x007，Valid, Read/Write 二级页表号：0x007 访问0x0010 3000 + 4 * 0x007 = 0x0010 301C：0xEEFF 0001 标志位：0x001，Valid, Read Only 页内偏移量：0x222 Error: Read Only （3）Store [0x00C005BF] 页目录号：0x003 访问0x0020 0000 + 4 * 0x003 = 0x0020 000C：0x0010 3007 二级页表页框号：0x00103 标志位：0x007，Valid, Read/Write 二级页表号：0x000 访问0x0010 3000 + 4 * 0x000 = 0x0010 3000：0x1122 0067 物理页框号：0x11220 标志位：0x067，Valid, Read/Write 页内偏移量：0x5BF 写入0x1122 0000 + 0x067 = 0x1122 0067 OK: 0x1122 0067 （4）Load [0x00003013] 页目录号：0x000 访问0x0020 0000 + 4 * 0x000 = 0x0020 0000：0x0010 0007 二级页表页框号：0x00100 标志位：0x007，Valid, Read/Write 二级页表号：0x003 访问0x0010 0000 + 4 * 0x003 = 0x0010 000C：0x0000 4007 物理页框号：0x00004 标志位：0x007，Valid, Read/Write 页内偏移量：0x013 访问0x0000 4000 + 0x013 = 0x0000 4013：0x19 成功：0x19 （5）Load [0xFF80078F] 页目录号：0x3FE 访问0x0020 0000 + 4 * 0x3FE = 0x0020 0FF8：0x001F E007 二级页表页框号：0x001FE 标志位：0x007，Valid, Read/Write 二级页表号：0x000 访问0x001F E000 + 4 * 0x000 = 0x001F E000：0x0415 0000 标志位：0x000，Invalid 页内偏移量：0x78F Error: Invalid （6）Load [0xFFFFF005] 页目录号：0x3FF 访问0x0020 0000 + 4 * 0x3FF = 0x0020 0FFC：0x001F F007 二级页表页框号：0x001FF 标志位：0x007，Valid, Read/Write 二级页表号：0x3FF 访问0x001F F000 + 4 * 0x3FF = 0x001F FFFC：0x0010 3067 物理页框号：0x00103 标志位：0x067，Valid, Read/Write 页内偏移量：0x005 访问0x0010 3000 + 0x005 = 0x0010 3005：0x66 成功：0x66 综上所述：\n指令 结果 Load [0x00001022] 0x20 Store [0x00C07222] Error Store [0x00C005BF] OK Load [0x00003013] 0x19 Load [0xFF80078F] Error Load [0xFFFFF005] 0x66 ","permalink":"https://oNya685.github.io/posts/buaa/os/homework-3/","summary":"\u003cp\u003e\u003cstrong\u003e\u003ca href=\"%e4%bd%9c%e4%b8%9a3.pdf\" target=\"_blank\"\u003e点此查看作业源文件\u003c/a\u003e\n\u003c/strong\u003e\u003c/p\u003e\n\u003ch1 id=\"第一题\"\u003e第一题\u003c/h1\u003e\n\u003ch2 id=\"1请问进程整个的地址空间有多少字节一页有多少字节\"\u003e（1）请问进程整个的地址空间有多少字节？一页有多少字节？\u003c/h2\u003e\n$$ 进程整个的地址空间 = 2^{32}B = 4GB $$$$一页有 2^{12}B = 4KB$$\u003ch2 id=\"2一个进程如果从-0x80000000-开始映射-4mb-大小页表空间求第一级页表页目录的起始逻辑地址并指出从哪个逻辑地址可以读出第一级页表页目录所在的物理页框号说明理由注意-b-代表字节一个-32-位地址占-4-字节\"\u003e（2）一个进程如果从 0x80000000 开始映射 4MB 大小页表空间，求第一级页表（页目录）的起始逻辑地址，并指出从哪个逻辑地址可以读出第一级页表（页目录）所在的物理页框号。说明理由。（注意 B 代表字节，一个 32 位地址占 4 字节）\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e进程页表空间映射起始地址为\u003ccode\u003e0x80000000\u003c/code\u003e，所以页目录的第\u003ccode\u003e0x200\u003c/code\u003e项指向页表空间，所以第一级页表的起始逻辑地址为\u003ccode\u003e0x80200000\u003c/code\u003e。\u003c/p\u003e","title":"[BUAA-OS] 理论作业 3"},{"content":"点此查看作业源文件 1. 动态内存分配需要对内存分区进行管理，一般使用位图和空闲链表两种方法。128MB的内存以n字节为单元分配，对于链表，假设内存中数据段和空闲区交替排列，长度均为64KB。并假设链表中的每个节点需要记录32位的内存地址信息、16位长度信息和16位下一节点域信息。这两种方法分别需要多少字节的存储空间？哪种方法更好？ 若使用位图方法： $$单元数 = \\frac{128MB}{nB} = \\frac{2^{27}}{n}块$$$$所需存储空间 = \\frac{2^{27}}{n}b = \\frac{16}{n}MB$$ 若使用空闲链表方法： $$段数=\\frac{128MB}{64KB+64KB} = 2^{10}段$$$$所需存储空间 = 2^{10} \\times (32 + 16 + 16)b = 8KB$$ 哪种方法更好： 当n\u0026lt;2048时，空闲链表所需存储空间更小，空闲链表方法更好； 当n\u0026gt;2048时，位图所需存储空间更小，位图方法更好。 2. 在一个交换系统中，按内存地址排列的空闲区大小是: 10KB、4KB、20KB、18KB、7KB、9KB、12KB和15KB。对于连续的段请求：12KB、10KB、9KB。使用FirstFit、BestFit、WorstFit和NextFit将找出哪些空闲区？ 段请求 FirstFit BestFit WorstFit NextFit 12KB 20KB 12KB 20KB 20KB 10KB 10KB 10KB 18KB 18KB 9KB 18KB 9KB 15KB 9KB 3. 解释逻辑地址、物理地址、地址映射，并举例说明。 逻辑地址（Logical Address）： 逻辑地址是程序运行时由 CPU 生成的地址，也称为虚拟地址。用户进程只能访问逻辑地址，不能直接访问物理内存。\n例如某程序访问地址 0x1234，但该地址只是进程的逻辑地址空间中的一部分。\n物理地址（Physical Address）：\n物理地址是实际存在于内存（RAM）中的地址，由操作系统和硬件管理。\n例子： 逻辑地址 0x1234 可能被映射到物理内存的 0xABCD1234。\n地址映射（Address Mapping）：\n地址映射是逻辑地址到物理地址的转换过程，通常由MMU通过分页、分段、段页结合等方式完成。 例子： 在分页系统中，逻辑地址 0x1234 可能属于页号2，页内偏移 0x034，MMU 通过页表找到物理页框5，映射后的物理地址为 0x5034。\n4. 解释页式（段式）存储管理中为什么要设置页（段）表和快表，简述页式（段式）地址转换过程。 为什么要设置页（段）表和快表\n页表（段表）：用于记录逻辑地址到物理地址的映射关系，存储完整的映射信息，保证进程可以正确访问物理内存。 快表：是一种高速缓存，用于存储最近访问的页（段）表项，加速地址转换，提高地址转换效率，减少访问内存的开销。 页式存储管理的地址转换过程\nCPU 生成逻辑地址，包含页号和页内偏移。 查询 TLB，如果页号在 TLB 中，则直接获取对应的物理页框号，得到物理地址。 若TLB 未命中（缺页表项），需要访问页表，通过页号查找对应的物理页框号。 组合物理页框号和页内偏移，形成物理地址，访问数据。 更新 TLB（如果 TLB 未命中，则将新查找的页表项加入 TLB）。 段式存储管理的地址转换过程\nCPU 生成逻辑地址，包含段号和段内偏移。 查询 TLB，如果段号在 TLB 中，则直接获取段的基址，计算物理地址。 若TLB 未命中，访问段表，查找段号对应的段基址和段界限。 检查越界，如果段内偏移\u0026gt;段界限，发生段越界异常，否则继续计算。 物理地址 = 段基址 + 段内偏移，然后访问数据。 更新 TLB（如果 TLB 未命中，则将新的段表项加入 TLB）。 5. 叙述缺页中断的处理流程。 缺页中断发生在进程访问的页面不在内存时，系统需要从外存加载该页面到内存。处理流程如下：\n产生缺页中断\n进程访问某个逻辑地址，CPU 通过页表查找对应的物理页框。 如果该页表项无效（页不在内存），则触发缺页中断。 保存进程状态\nCPU 保存当前进程的上下文，包括程序计数器（PC）和寄存器等，确保中断后能恢复执行。 操作系统处理缺页\n查找页表：操作系统检查该页是否有效。 有效但不在内存 → 继续处理。 非法访问 → 触发异常（如段错误），终止进程。 选择物理页框： 若有空闲页框，直接使用。 若内存已满，使用页面置换算法（如 FIFO、LRU）淘汰一个旧页面。 读取页面到内存\n从外存（如磁盘）读取所需页面，拷贝到选定的物理页框。 更新页表和 TLB\n修改页表项，标记该页已在内存，并更新页框号。 若该页表项在 TLB（快表）中，需更新或清除 TLB 旧项，保证地址转换正确。 恢复进程执行\n恢复进程上下文，重新执行触发缺页的指令。 由于该页已加载到内存，不会再次触发缺页中断。 6. 假设一个机器有38位的虚拟地址和32位的物理地址。 (1) 与一级页表相比，多级页表的主要优点是什么？ 空间利用率高。多级页表只在需要时分配低层页表，从而避免为整个虚拟地址空间都预留大量连续的页表空间，节省内存空间。 (2) 如果使用二级页表，页面大小为16KB，每个页表项有4个字节。应该为虚拟地址中的第一级和第二级页表域各分配多少位？ 页面大小为 16KB，即\n$$16\\,\\text{KB} = 16 \\times 1024 = 2^{14}\\,\\text{字节}$$因此页内偏移需要 14 位，虚拟地址结构如下：\n$$\\underbrace{\\text{第一级页表域}}_{x\\,\\text{位}}\\,\\,\\underbrace{\\text{第二级页表域}}_{y\\,\\text{位}}\\,\\,\\underbrace{\\text{页内偏移}}_{14\\,\\text{位}}$$虚拟地址为38位，因此$x + y + 14 = 38位$，所以$x + y = 24,\\text{位}$。\n每个页表项为4B，页表页的大小与页面大小相同，即16KB。一个页表页能容纳的页表项个数为\n$$\\frac{16\\,\\text{KB}}{4\\,\\text{B}} = 4096 = 2^{12}\\,\\text{项}$$因此第二级页表的索引域需要12位，即$y=12$。\n由$x+y=24$可得$x=12$。即：\n$$\\underbrace{\\text{第一级页表域}}_{12\\,\\text{位}}\\,\\,\\underbrace{\\text{第二级页表域}}_{12\\,\\text{位}}\\,\\,\\underbrace{\\text{页内偏移}}_{14\\,\\text{位}}$$7. 假设页面的访问存在一定的周期性循环，但周期之间会随机出现一些页面的访问。例如：0,1,2…,511,431,0,1,2…511,332,0,1,2,…,511等。请思考： (1) LRU、FIFO和Clock算法的效果如何？ 如果物理页框数不足512个，三种算法会发生相同的几乎全部缺页问题。\n(2) 如果有500个页框，能否设计一个优于LRU、FIFO和Clock的算法？ 其中499个页框对应存储0-498页，第500个页框用于置换。\n8. 一个交换系统通过紧缩技术来清理碎片。如果内存碎片和数据区域是随机分配的。而且假设读写32位内存字需要10nsec. 那么如果紧缩128MB的内存需要多久？简单起见，假设第0个字是碎片的一部分而最高位的字包含了有效的数据。 $$128MB=\\frac{128\\times 2^{23}b}{32b/word} = 2^{25}words$$$$T=2^{25}words \\times (10ns/word + 10ns/word) = 6.711\\times 10^8ns = 0.6711s$$需要约$0.6711s$。\n","permalink":"https://oNya685.github.io/posts/buaa/os/homework-2/","summary":"\u003cp\u003e\u003cstrong\u003e\u003ca href=\"%e4%bd%9c%e4%b8%9a2.pdf\" target=\"_blank\"\u003e点此查看作业源文件\u003c/a\u003e\n\u003c/strong\u003e\u003c/p\u003e\n\u003ch1 id=\"1-动态内存分配需要对内存分区进行管理一般使用位图和空闲链表两种方法128mb的内存以n字节为单元分配对于链表假设内存中数据段和空闲区交替排列长度均为64kb并假设链表中的每个节点需要记录32位的内存地址信息16位长度信息和16位下一节点域信息这两种方法分别需要多少字节的存储空间哪种方法更好\"\u003e1. 动态内存分配需要对内存分区进行管理，一般使用位图和空闲链表两种方法。128MB的内存以n字节为单元分配，对于链表，假设内存中数据段和空闲区交替排列，长度均为64KB。并假设链表中的每个节点需要记录32位的内存地址信息、16位长度信息和16位下一节点域信息。这两种方法分别需要多少字节的存储空间？哪种方法更好？\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003e若使用位图方法：\u003c/li\u003e\n\u003c/ul\u003e\n$$单元数 = \\frac{128MB}{nB} = \\frac{2^{27}}{n}块$$$$所需存储空间 = \\frac{2^{27}}{n}b = \\frac{16}{n}MB$$\u003cul\u003e\n\u003cli\u003e若使用空闲链表方法：\u003c/li\u003e\n\u003c/ul\u003e\n$$段数=\\frac{128MB}{64KB+64KB} = 2^{10}段$$$$所需存储空间 = 2^{10} \\times (32 + 16 + 16)b = 8KB$$\u003cul\u003e\n\u003cli\u003e哪种方法更好：\n\u003cul\u003e\n\u003cli\u003e当n\u0026lt;2048时，空闲链表所需存储空间更小，空闲链表方法更好；\u003c/li\u003e\n\u003cli\u003e当n\u0026gt;2048时，位图所需存储空间更小，位图方法更好。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1 id=\"2-在一个交换系统中按内存地址排列的空闲区大小是-10kb4kb20kb18kb7kb9kb12kb和15kb对于连续的段请求12kb10kb9kb使用firstfitbestfitworstfit和nextfit将找出哪些空闲区\"\u003e2. 在一个交换系统中，按内存地址排列的空闲区大小是: 10KB、4KB、20KB、18KB、7KB、9KB、12KB和15KB。对于连续的段请求：12KB、10KB、9KB。使用FirstFit、BestFit、WorstFit和NextFit将找出哪些空闲区？\u003c/h1\u003e\n\u003ctable\u003e\n  \u003cthead\u003e\n      \u003ctr\u003e\n          \u003cth\u003e段请求\u003c/th\u003e\n          \u003cth\u003eFirstFit\u003c/th\u003e\n          \u003cth\u003eBestFit\u003c/th\u003e\n          \u003cth\u003eWorstFit\u003c/th\u003e\n          \u003cth\u003eNextFit\u003c/th\u003e\n      \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e\u003cstrong\u003e12KB\u003c/strong\u003e\u003c/td\u003e\n          \u003ctd\u003e20KB\u003c/td\u003e\n          \u003ctd\u003e12KB\u003c/td\u003e\n          \u003ctd\u003e20KB\u003c/td\u003e\n          \u003ctd\u003e20KB\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e\u003cstrong\u003e10KB\u003c/strong\u003e\u003c/td\u003e\n          \u003ctd\u003e10KB\u003c/td\u003e\n          \u003ctd\u003e10KB\u003c/td\u003e\n          \u003ctd\u003e18KB\u003c/td\u003e\n          \u003ctd\u003e18KB\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e\u003cstrong\u003e9KB\u003c/strong\u003e\u003c/td\u003e\n          \u003ctd\u003e18KB\u003c/td\u003e\n          \u003ctd\u003e9KB\u003c/td\u003e\n          \u003ctd\u003e15KB\u003c/td\u003e\n          \u003ctd\u003e9KB\u003c/td\u003e\n      \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e\n\u003ch1 id=\"3-解释逻辑地址物理地址地址映射并举例说明\"\u003e3. 解释逻辑地址、物理地址、地址映射，并举例说明。\u003c/h1\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e逻辑地址（Logical Address）：\n逻辑地址是程序运行时由 CPU 生成的地址，也称为虚拟地址。用户进程只能访问逻辑地址，不能直接访问物理内存。\u003cbr\u003e\n例如某程序访问地址 \u003ccode\u003e0x1234\u003c/code\u003e，但该地址只是进程的逻辑地址空间中的一部分。\u003c/p\u003e","title":"[BUAA-OS] 理论作业 2"},{"content":"一、思考题 Thinking 1.1 在阅读附录中的编译链接详解以及本章内容后，尝试分别使用实验环境中的原生x86工具链（gcc、ld、readelf、objdump等）和MIPS交叉编译工具链（带有mips-linux-gnu-前缀，如mips-linux-gnu-gcc、mips-linux-gnu-ld），重复其中的编译和解析过程，观察相应的结果，并解释其中向objdump传入的参数的含义。\ngit@23373270:~/test $ gcc -E hello.c \u0026gt; gcc-E.out # gcc-E.out: ...(\u0026lt;stdio.h\u0026gt;的内容) # 2 \u0026#34;hello.c\u0026#34; 2 # 3 \u0026#34;hello.c\u0026#34; int main() { printf(\u0026#34;Hello World!\\n\u0026#34;); return 0; } git@23373270:~/test $ mips-linux-gnu-gcc -E hello.c \u0026gt; mips-gcc-E.out # mips-gcc-E.out: ...(\u0026lt;stdio.h\u0026gt;的内容) # 2 \u0026#34;hello.c\u0026#34; 2 # 3 \u0026#34;hello.c\u0026#34; int main() { printf(\u0026#34;Hello World!\\n\u0026#34;); return 0; } 进行预处理的情况下，两者几乎没有区别。\ngit@23373270:~/test $ gcc -c hello.c git@23373270:~/test $ objdump -DS hello.o \u0026gt; objdump-DS.out # objdump-DS.out: hello.o： 文件格式 elf64-x86-64 Disassembly of section .text: 0000000000000000 \u0026lt;main\u0026gt;: 0: f3 0f 1e fa endbr64 4: 55 push %rbp 5: 48 89 e5 mov %rsp,%rbp 8: 48 8d 05 00 00 00 00 lea 0x0(%rip),%rax # f \u0026lt;main+0xf\u0026gt; f: 48 89 c7 mov %rax,%rdi 12: e8 00 00 00 00 call 17 \u0026lt;main+0x17\u0026gt; 17: b8 00 00 00 00 mov $0x0,%eax 1c: 5d pop %rbp 1d: c3 ret Disassembly of section .rodata: 0000000000000000 \u0026lt;.rodata\u0026gt;: ... Disassembly of section .comment: 0000000000000000 \u0026lt;.comment\u0026gt;: ... Disassembly of section .note.gnu.property: 0000000000000000 \u0026lt;.note.gnu.property\u0026gt;: ... Disassembly of section .eh_frame: 0000000000000000 \u0026lt;.eh_frame\u0026gt;: ... git@23373270:~/test $ mips-linux-gnu-gcc -c hello.c git@23373270:~/test $ mips-linux-gnu-objdump -DS hello.o \u0026gt; mips-objdump-DS.out # mips-objdump-DS.out: hello.o： 文件格式 elf32-tradbigmips Disassembly of section .text: 00000000 \u0026lt;main\u0026gt;: 0: 27bdffe0 addiu sp,sp,-32 4: afbf001c sw ra,28(sp) 8: afbe0018 sw s8,24(sp) c: 03a0f025 move s8,sp 10: 3c1c0000 lui gp,0x0 14: 279c0000 addiu gp,gp,0 18: afbc0010 sw gp,16(sp) 1c: 3c020000 lui v0,0x0 20: 24440000 addiu a0,v0,0 24: 8f820000 lw v0,0(gp) 28: 0040c825 move t9,v0 2c: 0320f809 jalr t9 30: 00000000 nop 34: 8fdc0010 lw gp,16(s8) 38: 00001025 move v0,zero 3c: 03c0e825 move sp,s8 40: 8fbf001c lw ra,28(sp) 44: 8fbe0018 lw s8,24(sp) 48: 27bd0020 addiu sp,sp,32 4c: 03e00008 jr ra 50: 00000000 nop ... Disassembly of section .reginfo: 00000000 \u0026lt;.reginfo\u0026gt;: ... Disassembly of section .MIPS.abiflags: 00000000 \u0026lt;.MIPS.abiflags\u0026gt;: ... Disassembly of section .pdr: 00000000 \u0026lt;.pdr\u0026gt;: ... Disassembly of section .rodata: 00000000 \u0026lt;.rodata\u0026gt;: ... Disassembly of section .comment: 00000000 \u0026lt;.comment\u0026gt;: ... Disassembly of section .gnu.attributes: 00000000 \u0026lt;.gnu.attributes\u0026gt;: ... 只编译不链接，生成目标文件，发现被编译为不同的汇编语言，且分别为64位和32位。\n其中向objdump传入参数-D和-S。\ngit@23373270:~/test $ objdump --help -D, --disassemble-all Display assembler contents of all sections -S, --source Intermix source code with disassembly -D：显示所有段的汇编内容 -S：将源代码与反汇编代码混合显示\nThinking 1.2 思考下述问题：\n尝试使用我们编写的readelf程序，解析之前在target目录下生成的内核ELF文件。 也许你会发现我们编写的readelf程序是不能解析readelf文件本身的，而我们刚才介绍的系统工具readelf则可以解析，这是为什么呢？（提示：尝试使用readelf -h，并阅读tools/readelf目录下的Makefile，观察readelf与hello的不同） git@23373270:~/23373270 (lab1)$ tools/readelf/readelf target/mos 0:0x0 1:0x80020000 2:0x80021930 3:0x80021948 4:0x80021960 5:0x0 6:0x0 7:0x0 8:0x0 9:0x0 10:0x0 11:0x0 12:0x0 13:0x0 14:0x0 15:0x0 16:0x0 17:0x0 18:0x0 git@23373270:~/23373270/tools/readelf (lab1)$ readelf -h readelf ELF 头： Magic： 7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00 类别: ELF64 数据: 2 补码，小端序 (little endian) Version: 1 (current) OS/ABI: UNIX - System V ABI 版本: 0 类型: DYN (Position-Independent Executable file) 系统架构: Advanced Micro Devices X86-64 版本: 0x1 入口点地址： 0x1180 程序头起点： 64 (bytes into file) Start of section headers: 14488 (bytes into file) 标志： 0x0 Size of this header: 64 (bytes) Size of program headers: 56 (bytes) Number of program headers: 13 Size of section headers: 64 (bytes) Number of section headers: 31 Section header string table index: 30 观察tools/readelf/Makefile：\nreadelf: main.o readelf.o $(CC) $^ -o $@ hello: hello.c $(CC) $^ -o $@ -m32 -static -g 区别在于hello为32位程序，readelf是64位程序，且hello的编译有-static修饰，是静态链接的。\nThinking 1.3 在理论课上我们了解到，MIPS体系结构上电时，启动入口地址为0xBFC00000（其实启动入口地址是根据具体型号而定的，由硬件逻辑确定，也有可能不是这个地址，但一定是一个确定的地址），但实验操作系统的内核入口并没有放在上电启动地址，而是按照内存布局图放置。思考为什么这样放置内核还能保证内核入口被正确跳转到？ （提示：思考实验中启动过程的两阶段分别由谁执行。）\n系统能够正确跳转到内核入口在于两阶段启动过程和链接脚本控制：\n启动阶段划分\n阶段一：硬件上电后执行固化在 ROM 中的代码（地址 0xBFC00000） 阶段二：Bootloader 加载操作系统内核到指定内存地址 链接脚本控制（kernel.lds）\n/* * Set the ENTRY point of the program to _start. */ ENTRY(_start) SECTIONS { . = 0x80020000; .text : { *(.text) } ... } 入口地址设置（start.S） #include \u0026lt;asm/asm.h\u0026gt; #include \u0026lt;mmu.h\u0026gt; .text EXPORT(_start) .set at .set reorder /* Lab 1 Key Code \u0026#34;enter-kernel\u0026#34; */ /* clear .bss segment */ la v0, bss_start la v1, bss_end ... j mips_init 实现原理：\nBootloader 将内核镜像加载到链接脚本指定的内存地址（0x80020000） 通过ENTRY(_start)指定内核入口符号 汇编代码中 _start 符号通过绝对跳转指令（j mips_init）转移到内核主函数 二、难点分析与实验体会 1. ELF文件 对ELF文件的概念缺少理解，写完readelf实际使用后才理解其含义。\n三、原创说明 本以为是readelf在运行时无法读取自己，是因为自己正在运行导致的无法读取。在与赵德祥同学讨论后才注意到readelf与hello在64位和32位上的区别，在此致谢。\n","permalink":"https://oNya685.github.io/posts/buaa/os/lab-1-report/","summary":"\u003ch1 id=\"一思考题\"\u003e一、思考题\u003c/h1\u003e\n\u003ch2 id=\"thinking-11\"\u003eThinking 1.1\u003c/h2\u003e\n\u003cblockquote\u003e\n\u003cp\u003e在阅读附录中的编译链接详解以及本章内容后，尝试分别使用实验环境中的原生x86工具链（gcc、ld、readelf、objdump等）和MIPS交叉编译工具链（带有mips-linux-gnu-前缀，如mips-linux-gnu-gcc、mips-linux-gnu-ld），重复其中的编译和解析过程，观察相应的结果，并解释其中向objdump传入的参数的含义。\u003c/p\u003e","title":"[BUAA-OS] Lab 1 实验报告"},{"content":"架构简介 在本单元中，作业要求我们对提供了形式化表述的复杂表达式进行解析和化简，并要求尽可能简短的输出以度量性能分数。\n而经过三次作业迭代（其中包含一次重构），最终架构设计图如下：\n核心处理部分在于递归解析模块的两个递归，在图中具体表现为两个圈。接下来介绍和分析各模块的结构。\n主线处理 本模块是整个项目的主体部分，其中箭头含义表示流程顺序，不代表类的继承关系。主要流程呈现为main方法：\nString input = scanner.nextLine(); // 读入 Lexer lexer = new Lexer(input.replaceAll(\u0026#34; \u0026#34;, \u0026#34;\u0026#34;).replaceAll(\u0026#34;\\t\u0026#34;, \u0026#34;\u0026#34;)); // 词法解析 Parser parser = new Parser(lexer); // 传入Tokens System.out.println(parser .parseExpr() // 语法解析 .assign(null) // 赋值处理函数调用 .toPoly() // 计算化简 .Print() // 构造StringBuilder .toString()); // 输出结果 这样类似流水线的设计的优点是显而易见的，我们只需写好每一模块，封装成黑盒，确保每一部分的程序正确性，就可以完整实现所需功能。\n然而，见上面整体图可以看出，除了实现核心功能的解析模块，其余部分的耦合度其实是偏高的。\n我们会发现，Lexer, Parser, Poly这几个在主线中实现了相当一部分功能的类，因为把大量的重复性功能藏在一个类甚至一个方法内部实现（例如Lexer的大量if-else出现了控制分支数目大的问题），出现了耦合度过高、可读性差的问题。\n举例来说，我们可以分析这个只由两个类实现计算、化简、简化功能的模块：\n计算化简 这个模块内部实现了过多功能，方法个数多，方法规模大，只因它们都涉及到用于存储化简后输出结果的类——Poly（多项式）和Mono（单项式）——这就导致了这一部分难读、难拆、难拓展。\n递归解析 而与之相对的，由于有先导课程的最后一次作业的架构作参考，这个采用递归下降法解析和存储的模块有相当良好的可拓展性和低耦合度。\n这一模块的度量值相当良好，故省略去分析。这一部分的递归主要在于\nExpr - Term - \u0026lt;Factor\u0026gt; ExprFactor - Expr （见橙色箭头）形成的环，该递归改编自先导课程作业代码。 Expr - Term - \u0026lt;Factor\u0026gt; \u0026lt;VarFactor\u0026gt; FuncCall - \u0026lt;FuncDefine.exprs\u0026gt; Expr 。这一递归赋值处理函数调用的思路详见我在第二次作业中的讨论发帖 ，当然，在非校园网环境下，你也可以从此获取 。这一设计有极好的可拓展性，我们将在下一节进一步讨论。 迭代成型 第一次作业 通过采用先导课的递归下降设计，第一次作业的难点就主要在于计算与化简的部分了。此时我们埋下了直接导致需要重构的第一个雷，对于幂函数的处理，我没有完全参照形式化表述的思路，而是单独设计了一个类来表示幂函数，并于计算时再具体展开。\n第二次作业 重构：形式化表述 重构前后的复杂度其实近似，故省去分析，但值得注意的是前后的架构设计：\n其实都很明了，但最主要的区别其实是：重构后的类的设计完全符合了给出的形式化表述。第二次作业的迭代突然把形式化表述内容几乎翻倍不止，如果要沿着原来的架构像打补丁一样加上这大量的迭代内容，很可能最后根本写不完。\n而重构后的迭代体验也大幅提升：我只需要无脑照抄形式化表述，就能写好解析器，设计好各个类，这不仅省下了时间，也直接跳过了大量与形式化表述不统一而可能引发的潜在的bug。\n另一个大任务是递归函数调用的处理 在得知该迭代需求后，我耗费了相当久的时间思考如何以合理、优雅的方式处理递归函数调用，最终设计的一套处理思路 取得了相当好的可拓展性和相对低的耦合度，并结合动态规划和藏在其中的部分简化（例如，若某ExprFactor的Expr有且只有一个Term，该Term有且只有一个Factor，则该ExprFactor的简化方法返回该Factor，否则返回自身），实现了时间和空间上的大幅优化，并顺利解决掉了当f{n}的n过大时易爆栈的问题（事实上，事后发现课程组的Cost限制完全不足以超时或爆栈）。\n第三次作业 虽说在第二次作业的互测里被打了不少次，理应来说，如果有继续迭代开发的需求，我会继续重构，并明确几点：\n对象属性是否可变，会用到返回值的各种方法除了返回值之外应不应该产生副作用，会不会错误得复用某对象。 明确哪些类需要重写hashCode()和equals()，这一点对于优化性能得分至关重要。 耦合度过高的Poly和Mono是肯定要拆的，怎么分解而能继续实现原有功能，怎么设计更适合迭代的架构，怎么给优化性能留位置等。 但我并没有重构——第三次作业的需求很简单：\n一是普通函数调用，我原设计的递归函数调用处理方法有相当的可拓展性，我甚至没有修改函数相关的类就轻松实现了该要求。\n二是求导因子，但课程组给求导因子的限制过大，尤其是出现范围十分限定，因此我们只需在主线的流水线挑一个方便的环节（包括解析，运算，赋值，简化），附带上求导运算，就实现了。\n所以为什么不重构？第二次作业虽然烂了点，但经过强侧和互测的检验，打完补丁就是能保障正确性的代码。重构意味着要重新面对潜在的bug，而在当前这一坨上作简单的迭代并没有显著难度，正确性也更有保障。因此，没有第二次重构。\nBug分析 诡异的HashMap 这一bug并不是被测出来的：不解决这bug程序完全不能跑。这一单元里，大家都或多或少地与HashMap之类的容器或者hashCode等方法斗争了许久。至今我也不知道，除了新建一个容器往里塞，怎么遍历才能做到不报错。如果有下次，我可能选.stream().map().collect()。\n完全符合形式化表述，但符合得不太完全 \u0026lt;递推表达式\u0026gt; → \u0026lt;常数因子\u0026gt; \u0026lt;空白项\u0026gt; \u0026#39;*\u0026#39; \u0026lt;空白项\u0026gt; \u0026lt;自定义递推函数调用n-1\u0026gt; \u0026lt;空白项\u0026gt; \u0026lt;加减\u0026gt; \u0026lt;空白项\u0026gt; \u0026lt;常数因子\u0026gt; \u0026lt;空白项\u0026gt; \u0026#39;*\u0026#39; \u0026lt;空白项\u0026gt; \u0026lt;自定义递推函数调用n-2\u0026gt; [\u0026lt;空白项\u0026gt; \u0026#39;+\u0026#39; \u0026lt;空白项\u0026gt; \u0026lt;函数表达式\u0026gt;] 虽然经过一次完全符合形式化表述的重构，但因为我的设计足以实现对函数调用的解析，所以我本以为递推表达式就是比较特殊的表达式，其实不然。这个[\u0026lt;空白项\u0026gt; '+' \u0026lt;空白项\u0026gt; \u0026lt;函数表达式\u0026gt;]的诡异的加号让... + + + +1这样的表述变成了可能。这一bug着实很坑，但也没有什么经验可总结。\n谁会在sin()里套sin()*sin()？ 本以为第三次作业大家都差不多，互测更是全房 0 Hack，应该不会有bug了……吗？\n啊，输出了sin(sin(...)*sin(...))，但里面是一个表达式而非一个因子，所以应该是sin((sin(...)*sin(...)))。省去了不该省的括号。这个小bug从第二次作业互测测到第三次作业互测，都没有被测出来，第三次强测反倒测出来了，如果侥幸一点没测出来，这个bug可能永远都不会被发现了。\n当然也有喜闻乐见的 最喜欢分析的bug是别人的bug，在此稍加分析有参考意义的两例。\nextraTriangle!!! extraTriangle!!!一位没删用于调试的输出信息的同学如是喊道。\n这一bug值得分析是因为教会了我们设计一个调试开关，例如：\n// MainClass.java public Class MainClass { public static boolean debug() { return true; } ... public static void main(String[] args) { if (MainClass.debug()) { System.out.println(\u0026#34;Debug模式还没关，别看都不看就直接交了\u0026#34;); } ... } } 可能复用的对象，clone()或谨防副作用 我用一个简单的函数，调用了f{5}(x,x^2)，就一次刀穿了三人（不过其中一人其实没错，他只是在喊extraTriangle!!!），仔细看看，竟与之前发现并修掉的bug如出一辙。有的时候，我们需要这个对象本身，有的时候，我们只是需要这个对象的值。\n张三长大了一岁，无论是谁眼中的张三，都长大了一岁。有的时候，我们需要给张三拍照，把他当前的样子保留下来（或者是生成一个和当前的张三长得一样的克隆人）。问题就出在，可能A让张三长大了一岁，而B想给张三拍照时并没考虑到张三长大了一岁，拍下了不符合预期的照片。\n我的解决方案是，A生成张三的克隆人，并把克隆人当成张三，后续让“张三”长大一岁，原来的张三就不会受到影响，B随时都可以给张三拍照拍到正确的样子。\n测试策略 看源代码还是太折磨了，只有第一次作业读代码来设计测试用例了，后来都找不到用正则解析的了，大家处理思路十分趋同，与其看代码，不如直接构造各类极端样例，进行盲测了。\n当然不能直接用互测窗口测，CD太长；也不能开八个IDEA窗口挨个输入，效率太低；首先将八个压缩包编译生成八个jar包，然后用命令行批量处理，用文件实现读写，最后把大家的答案扔进优化得最好最稳定的同学的jar包，就能得到格式统一的输出了。当然这是不够严谨的做法，我们也可以采取python的一些妙妙工具，把输出的字符串里的x直接文本替换成各种刁钻的数值，评判输出的纯数字结果是不是相隔很小即可（理论上结果应该一模一样，但三角函数优化和浮点数带来的误差不可避免）。\n优化策略 前文已经提到了大部分的优化，因为实在无力处理三角函数的各种优化，且保住正确性分比贪性能分更稳妥。\n现介绍前文未提到的两处优化：\n重写equals()以合并同类项 与之对应的，我们也要重写hashCode()以实现在HashMap中能找到该同类项。\n这样我们就可以应对括号内的值存在关联性的三角函数之间的合并了。\n为返回值作顺带简化 例如前文提到的将ExprFactor返回其中仅有的Factor，可以一定程度上省去不必要的括号；又如cos(0)和sin(0)，可以直接返回具体数值。\n心得体会 虽然第三次作业的轻松要求确实减少了我们的工作量，让我直接放弃了第二次的重构，但我仍没能理解普通函数调用为什么会放在递归函数调用之后作为新要求迭代。第二次作业的任务量也着实有些惊悚，不知是传统还是失误。\n总的来说，第一单元在先导课提供了参考架构的基础上还算顺利，也能明显感到有所收获，期待第二单元的灵异电梯。\n","permalink":"https://oNya685.github.io/posts/buaa/oo/unit-1/summary/","summary":"\u003ch1 id=\"架构简介\"\u003e架构简介\u003c/h1\u003e\n\u003cp\u003e在本单元中，作业要求我们对提供了\u003cstrong\u003e形式化表述\u003c/strong\u003e的复杂表达式进行\u003cstrong\u003e解析和化简\u003c/strong\u003e，并要求尽可能简短的输出以度量性能分数。\u003c/p\u003e\n\u003cp\u003e而经过三次作业迭代（其中包含一次重构），最终架构设计图如下：\u003c/p\u003e","title":"[BUAA-OO] Unit 1 总结"},{"content":"synchronized关键字修饰的局部代码块内，我们能通过wait(), notify(), notifyAll()方法来调控线程之间的协作。\nnotify()和notifyAll()是什么？ 我们先定义两个概念，一个是等待池，一个是锁池，它们都是随一个锁而形成的暂存线程的容器。具体来说：\n等待池中的线程只有被通知（notify）时，才会进入锁池；否则什么也不做。\n锁池中的线程会不断尝试抢锁，如果抢到了锁，会进入synchronized，从开头或上次离开的位置（通过wait离开时）继续执行。\n当某线程尝试进入synchronized，即尝试抢锁，但失败了（因为有其他线程在占用这把锁）时，它会进入锁池，持续不断尝试抢锁。\n当某线程抢锁成功，进入了synchronized，它会离开锁池。\n当某线程进入了synchronized，并遵循程序的设计，执行了wait()方法，它会进入等待池。\n当某线程在synchronized中执行了notify()方法，会从等待池中随机选取一个线程让其移动到锁池。\n当某线程在synchronized中执行了notifyAll()方法，会将等待池中的所有线程移动到锁池。\n什么时候用notify()，什么时候用notifyAll？ 考虑某多线程任务 假设我们有一个资源池，生产者线程向其中添加资源，消费者线程从中获取资源。我们需要确保生产者在资源池满时等待，消费者在资源池空时等待。\nimport java.util.LinkedList; import java.util.Queue; public class ResourcePool { private Queue\u0026lt;Object\u0026gt; resources = new LinkedList\u0026lt;\u0026gt;(); private int capacity; private final Object lock = new Object(); public ResourcePool(int capacity) { this.capacity = capacity; } public void rent(Object resource) { synchronized (lock) { while (resources.size() \u0026gt;= capacity) { try { System.out.println(\u0026#34;生产者进入等待\u0026#34;); lock.wait(); // 如果资源池已满，生产者等待 } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(\u0026#34;生产者被唤醒\u0026#34;); } resources.add(resource); System.out.println(\u0026#34;生产者: 生产了一个资源, 当前资源数: \u0026#34; + resources.size()); lock.notify(); // 唤醒等待的消费者线程 } } public Object consume() { synchronized (lock) { while (resources.isEmpty()) { try { System.out.println(\u0026#34;消费者进入等待\u0026#34;); lock.wait(); // 如果资源池为空，消费者等待 } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(\u0026#34;消费者被唤醒\u0026#34;); } Object resource = resources.remove(); System.out.println(\u0026#34;消费者: 消费了一个资源, 当前资源数: \u0026#34; + resources.size()); lock.notify(); // 唤醒等待的生产者线程 return resource; } } } public class Main { public static void main(String[] args) { ResourcePool pool = new ResourcePool(1); // 借用者1 Thread renter = new Thread(() -\u0026gt; { for (int i = 0; i \u0026lt; 5; i++) { pool.rent(); try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } } }); producer.start(); consumer.start(); } } 在本例中，只有一个生产者线程和一个消费者线程，它们notify()时，只会唤醒彼此，它们被唤醒并继续运行的条件均为resources暂时没被其他人访问。\n考虑生产者-消费者多线程任务 在生产者-消费者模型中，生产者和消费者线程需要协调工作。生产者在资源池满时等待，消费者在资源池空时等待。当资源池有空间或有资源时，相应的线程被唤醒。\nimport java.util.LinkedList; import java.util.Queue; public class ResourcePool { private Queue\u0026lt;Object\u0026gt; resources = new LinkedList\u0026lt;\u0026gt;(); private int capacity; private final Object lock = new Object(); public ResourcePool(int capacity) { this.capacity = capacity; } public void produce(Object resource) { synchronized (lock) { while (resources.size() \u0026gt;= capacity) { try { System.out.println(\u0026#34;生产者进入等待\u0026#34;); lock.wait(); // 如果资源池已满，生产者等待 } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(\u0026#34;生产者被唤醒\u0026#34;); } resources.add(resource); System.out.println(\u0026#34;生产者: 生产了一个资源, 当前资源数: \u0026#34; + resources.size()); lock.notifyAll(); // 唤醒所有等待的消费者线程 } } public Object consume() { synchronized (lock) { while (resources.isEmpty()) { try { System.out.println(\u0026#34;消费者进入等待\u0026#34;); lock.wait(); // 如果资源池为空，消费者等待 } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(\u0026#34;消费者被唤醒\u0026#34;); } Object resource = resources.remove(); System.out.println(\u0026#34;消费者: 消费了一个资源, 当前资源数: \u0026#34; + resources.size()); lock.notifyAll(); // 唤醒所有等待的生产者线程 return resource; } } } public class Main { public static void main(String[] args) { ResourcePool pool = new ResourcePool(3); // 生产者线程 Thread producer = new Thread(() -\u0026gt; { for (int i = 0; i \u0026lt; 5; i++) { pool.produce(new Object()); try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } } }); // 消费者线程1 Thread consumer1 = new Thread(() -\u0026gt; { for (int i = 0; i \u0026lt; 5; i++) { pool.consume(); try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } } }); // 消费者线程2 Thread consumer2 = new Thread(() -\u0026gt; { for (int i = 0; i \u0026lt; 5; i++) { pool.consume(); try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } } }); producer.start(); consumer1.start(); consumer2.start(); } } 为什么要用notifyAll()？用notify()会怎么样？ 使用notifyAll()会唤醒所有等待的线程，确保它们都能重新评估条件。而使用notify()只唤醒一个线程，可能会导致该锁假死：有线程在等待，但没有线程在占用或竞争该锁。\n如果使用notify()：\n如果当前资源数为1，且消费者1消耗了一个资源并执行notify()，此时资源数为0； 如果消费者1恰好notify()了生产者，正常运行； 如果不巧，消费者1notify()了消费者2，消费者2会因为没有可用资源而重新wait()； 此时三者都处于等待池，锁池为空，程序陷入假死。 如果使用notifyAll()：\n所有等待的线程都会被唤醒，重新评估条件。 即使某些线程发现条件不满足并继续等待，其他线程仍然有机会执行。 如何判断用notify()还是notifyAll()？ 判断使用notify()还是notifyAll()的关键在于线程等待的条件（condition）是否相同。\n如果所有等待的线程都在等待同一个条件，使用notify()可能足够。 如果线程等待的条件不同，或者需要确保所有线程都能重新评估条件，使用notifyAll()更安全。 要是我们能给不同的线程设置不同的等待条件该多好。生产者生产后只唤醒条件为资源不为空的消费者，消费者消费后只唤醒条件为资源不为满的生产者们，那就肯定不会假死了！\n用synchronized的代码怎么改造成用ReentrantLock和Condition 什么是ReentrantLock ReentrantLock是一个可重入的互斥锁，它提供了与synchronized类似的功能，但更加灵活。它允许更细粒度的锁控制，并且可以配合Condition对象使用。\nCondition有什么优势 Condition接口提供了类似于wait()、notify()和notifyAll()的方法，但更加灵活。它允许一个锁对象有多个Condition实例，每个实例可以用于不同的条件等待和通知。\n代码改造 将上述代码改造成使用ReentrantLock和Condition：\nimport java.util.LinkedList; import java.util.Queue; import java.util.concurrent.locks.Condition; import java.util.concurrent.locks.Lock; import java.util.concurrent.locks.ReentrantLock; public class ResourcePool { private Queue\u0026lt;Object\u0026gt; resources = new LinkedList\u0026lt;\u0026gt;(); private int capacity; private final Lock lock = new ReentrantLock(); private final Condition notFull = lock.newCondition(); private final Condition notEmpty = lock.newCondition(); public ResourcePool(int capacity) { this.capacity = capacity; } public void produce(Object resource) { lock.lock(); try { while (resources.size() \u0026gt;= capacity) { notFull.await(); // 如果资源池已满，生产者等待 } resources.add(resource); System.out.println(\u0026#34;生产者: 生产了一个资源, 当前资源数: \u0026#34; + resources.size()); notEmpty.signal(); // 唤醒单个等待的消费者线程 } catch (InterruptedException e) { e.printStackTrace(); } finally { lock.unlock(); } } public Object consume() { lock.lock(); try { while (resources.isEmpty()) { notEmpty.await(); // 如果资源池为空，消费者等待 } Object resource = resources.remove(); System.out.println(\u0026#34;消费者: 消费了一个资源, 当前资源数: \u0026#34; + resources.size()); notFull.signal(); // 唤醒单个等待的生产者线程 return resource; } catch (InterruptedException e) { e.printStackTrace(); } finally { lock.unlock(); } } } public class Main { public static void main(String[] args) { ResourcePool pool = new ResourcePool(3); // 生产者线程 Thread producer = new Thread(() -\u0026gt; { for (int i = 0; i \u0026lt; 5; i++) { pool.produce(new Object()); try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } } }); // 消费者线程1 Thread consumer1 = new Thread(() -\u0026gt; { for (int i = 0; i \u0026lt; 5; i++) { pool.consume(); try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } } }); // 消费者线程2 Thread consumer2 = new Thread(() -\u0026gt; { for (int i = 0; i \u0026lt; 5; i++) { pool.consume(); try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } } }); producer.start(); consumer1.start(); consumer2.start(); } } 改造后的代码解释 锁的初始化：\n使用ReentrantLock代替synchronized，提供更灵活的锁控制。 条件的初始化：\n为生产者和消费者分别创建两个Condition实例notFull和notEmpty，分别用于等待资源池满和空的条件。 生产者方法：\n在资源池满时，生产者线程调用notFull.await()进入等待。 当资源池有空间时，调用notEmpty.signal()唤醒单个消费者线程。 消费者方法：\n在资源池空时，消费者线程调用notEmpty.await()进入等待。 当资源池有资源时，调用notFull.signal()唤醒单个生产者线程。 通过这种改造，我们使用ReentrantLock和Condition实现了更灵活的线程同步，避免了synchronized的一些限制。\n","permalink":"https://oNya685.github.io/posts/buaa/oo/unit-2/condition/","summary":"\u003cp\u003e\u003ccode\u003esynchronized\u003c/code\u003e关键字修饰的局部代码块内，我们能通过\u003ccode\u003ewait()\u003c/code\u003e, \u003ccode\u003enotify()\u003c/code\u003e, \u003ccode\u003enotifyAll()\u003c/code\u003e方法来调控线程之间的协作。\u003c/p\u003e\n\u003ch1 id=\"notify和notifyall是什么\"\u003e\u003ccode\u003enotify()\u003c/code\u003e和\u003ccode\u003enotifyAll()\u003c/code\u003e是什么？\u003c/h1\u003e\n\u003cp\u003e我们先定义两个概念，一个是\u003cstrong\u003e等待池\u003c/strong\u003e，一个是\u003cstrong\u003e锁池\u003c/strong\u003e，它们都是随一个锁而形成的\u003cstrong\u003e暂存线程\u003c/strong\u003e的容器。具体来说：\u003c/p\u003e","title":"用Condition干掉notifyAll"},{"content":"一、思考题 Thinking 0.1 思考下列有关Git的问题：\n在前述已初始化的~/learnGit 目录下，创建一个名为README.txt的文件。执行命令git status \u0026gt; Untracked.txt（其中的 \u0026gt; 为输出重定向，我们将在0.6.3中详细介绍）。 在README.txt 文件中添加任意文件内容，然后使用add命令，再执行命令git status \u0026gt; Stage.txt。 提交README.txt，并在提交说明里写入自己的学号。 执行命令cat Untracked.txt 和cat Stage.txt，对比两次运行的结果，体会README.txt两次所处位置的不同。 修改README.txt 文件，再执行命令git status \u0026gt; Modified.txt。 执行命令cat Modified.txt，观察其结果和第一次执行add命令之前的status是否一样，并思考原因。 1. Untracked.txt $ cat Untracked.txt 位于分支 master 未跟踪的文件: （使用 \u0026#34;git add \u0026lt;文件\u0026gt;...\u0026#34; 以包含要提交的内容） README.txt Untracked.txt 提交为空，但是存在尚未跟踪的文件（使用 \u0026#34;git add\u0026#34; 建立跟踪） 新建了README.txt文件，处于Untracked状态。\n2. Staged.txt $ cat Staged.txt 位于分支 master 要提交的变更： （使用 \u0026#34;git restore --staged \u0026lt;文件\u0026gt;...\u0026#34; 以取消暂存） 新文件： README.txt 未跟踪的文件: （使用 \u0026#34;git add \u0026lt;文件\u0026gt;...\u0026#34; 以包含要提交的内容） Staged.txt Untracked.txt 修改了README.txt的文件内容，并跟踪和暂存该文件，处于Staged状态。\n3. Modified.txt $ cat Modified.txt 位于分支 master 尚未暂存以备提交的变更： （使用 \u0026#34;git add \u0026lt;文件\u0026gt;...\u0026#34; 更新要提交的内容） （使用 \u0026#34;git restore \u0026lt;文件\u0026gt;...\u0026#34; 丢弃工作区的改动） 修改： README.txt 未跟踪的文件: （使用 \u0026#34;git add \u0026lt;文件\u0026gt;...\u0026#34; 以包含要提交的内容） Modified.txt Staged.txt Untracked.txt 修改尚未加入提交（使用 \u0026#34;git add\u0026#34; 和/或 \u0026#34;git commit -a\u0026#34;） README.txt经暂存和提交后处于Unmodified状态，修改文件内容使其进入Modified状态等待暂存。\nThinking 0.2 仔细看看0.10 ，思考一下箭头中的add the file、stage the file和commit分别对应的是Git里的哪些命令呢？\n1. add the file add the file 对应的是git add。\n2. stage the file stage the file 对应的是git add。\n3. commit commit 对应的是git commit。\nThinking 0.3 思考下列问题：\n代码文件print.c被错误删除时，应当使用什么命令将其恢复？ 代码文件print.c被错误删除后，执行了git rm print.c命令，此时应当使用什么命令将其恢复？ 无关文件hello.txt已经被添加到暂存区时，如何在不删除此文件的前提下将其移出暂存区？ 1. 代码文件 print.c 被错误删除时，应当使用什么命令将其恢复？ git restore print.c print.c 尚未执行git add，故可以从暂存区将print.c恢复到工作区中。\n2. 代码文件 print.c 被错误删除后，执行了 git rm print.c 命令，此时应当使用什么命令将其恢复？ git reset HEAD print.c git restore print.c 首先撤销暂存区的修改（删除了print.c），然后将print.c从暂存区恢复到工作区。\n3. 无关文件 hello.txt 已经被添加到暂存区时，如何在不删除此文件的前提下将其移出暂存区？ git reset HEAD hello.txt 撤销暂存区的修改，把暂存区恢复到执行git add之前的状态。\nThinking 0.4 思考下列有关 Git 的问题：\n找到在 /home/22xxxxxx/learnGit 下刚刚创建的 README.txt 文件，若不存在则新建该文件。 在文件里加入 Testing 1，git add，git commit，提交说明记为 1。 模仿上述做法，把 1 分别改为 2 和 3，再提交两次。 使用 git log 命令查看提交日志，看是否已经有三次提交，记下提交说明为 3 的哈希值1。 进行版本回退。执行命令 git reset \u0026ndash;hard HEAD^ 后，再执行 git log，观察其变化。 找到提交说明为 1 的哈希值，执行命令 git reset \u0026ndash;hard \u0026lt;hash\u0026gt; 后，再执行 git log，观察其变化。 现在已经回到了旧版本，为了再次回到新版本，执行 git reset \u0026ndash;hard \u0026lt;hash\u0026gt;，再执行 git log，观察其变化。 $ git log commit a6ebe244272dd6bcb1f57ba9af3c957f3e7235b3 (HEAD -\u0026gt; master) Author: 姜宇墨 \u0026lt;YumoJiang@buaa.edu.cn\u0026gt; Date: Tue Mar 11 19:08:41 2025 +0800 3 commit 1d11df1461528ce8e2b67151384d4b24bdfec571 Author: 姜宇墨 \u0026lt;YumoJiang@buaa.edu.cn\u0026gt; Date: Tue Mar 11 19:08:33 2025 +0800 2 commit 3f8eb4043efae29bbb9eb626444f955a825f3535 Author: 姜宇墨 \u0026lt;YumoJiang@buaa.edu.cn\u0026gt; Date: Tue Mar 11 19:08:12 2025 +0800 1 提交说明为3的哈希值为a6ebe244272dd6bcb1f57ba9af3c957f3e7235b3。\n$ git reset --hard HEAD^ HEAD 现在位于 1d11df1 2 $ git log commit 1d11df1461528ce8e2b67151384d4b24bdfec571 (HEAD -\u0026gt; master) Author: 姜宇墨 \u0026lt;YumoJiang@buaa.edu.cn\u0026gt; Date: Tue Mar 11 19:08:33 2025 +0800 2 commit 3f8eb4043efae29bbb9eb626444f955a825f3535 Author: 姜宇墨 \u0026lt;YumoJiang@buaa.edu.cn\u0026gt; Date: Tue Mar 11 19:08:12 2025 +0800 1 变化：当前Git仓库的状态回到了2。\n$ git reset --hard 3f8eb4043efae29bbb9eb626444f955a825f3535 HEAD 现在位于 3f8eb40 1 $ git log commit 3f8eb4043efae29bbb9eb626444f955a825f3535 (HEAD -\u0026gt; master) Author: 姜宇墨 \u0026lt;YumoJiang@buaa.edu.cn\u0026gt; Date: Tue Mar 11 19:08:12 2025 +0800 1 变化：当前Git仓库的状态回到了1。\n$ git reset --hard a6ebe244272dd6bcb1f57ba9af3c957f3e7235b3 HEAD 现在位于 a6ebe24 3 $ git log commit a6ebe244272dd6bcb1f57ba9af3c957f3e7235b3 (HEAD -\u0026gt; master) Author: 姜宇墨 \u0026lt;YumoJiang@buaa.edu.cn\u0026gt; Date: Tue Mar 11 19:08:41 2025 +0800 3 commit 1d11df1461528ce8e2b67151384d4b24bdfec571 Author: 姜宇墨 \u0026lt;YumoJiang@buaa.edu.cn\u0026gt; Date: Tue Mar 11 19:08:33 2025 +0800 2 commit 3f8eb4043efae29bbb9eb626444f955a825f3535 Author: 姜宇墨 \u0026lt;YumoJiang@buaa.edu.cn\u0026gt; Date: Tue Mar 11 19:08:12 2025 +0800 1 变化：当前Git仓库的状态回到了3。\nThinking 0.5 执行如下命令, 并查看结果\necho first echo second \u0026gt; output.txt echo third \u0026gt; output.txt echo forth \u0026raquo; output.txt $ echo first first $ echo second \u0026gt; output.txt \u0026amp;\u0026amp; cat output.txt second $ echo third \u0026gt; output.txt \u0026amp;\u0026amp; cat output.txt third $ echo forth \u0026gt;\u0026gt; output.txt \u0026amp;\u0026amp; cat output.txt third forth Thinking 0.6 使用你知道的方法（包括重定向）创建下图内容的文件（文件命名为 test），将创建该文件的命令序列保存在command文件中，并将test文件作为批处理文件运行，将运行结果输出至result文件中。给出command文件和result文件的内容，并对最后的结果进行解释说明（可以从test文件的内容入手）。具体实现的过程中思考下列问题: echo echo Shell Start 与 echo `echo Shell Start` 效果是否有区别; echo echo $c\u0026gt;file1 与 echo `echo $c\u0026gt;file1` 效果是否有区别.\n# command echo \u0026#39;echo Shell Start...\u0026#39; \u0026gt; test echo \u0026#39;echo set a = 1\u0026#39; \u0026gt;\u0026gt; test echo \u0026#39;a=1\u0026#39; \u0026gt;\u0026gt; test echo \u0026#39;echo set b = 2\u0026#39; \u0026gt;\u0026gt; test echo \u0026#39;b=2\u0026#39; \u0026gt;\u0026gt; test echo \u0026#39;echo set c = a+b\u0026#39; \u0026gt;\u0026gt; test echo \u0026#39;c=$[$a+$b]\u0026#39; \u0026gt;\u0026gt; test echo \u0026#39;echo c = $c\u0026#39; \u0026gt;\u0026gt; test echo \u0026#39;echo save c to ./file1\u0026#39; \u0026gt;\u0026gt; test echo \u0026#39;echo $c\u0026gt;file1\u0026#39; \u0026gt;\u0026gt; test echo \u0026#39;echo save b to ./file2\u0026#39; \u0026gt;\u0026gt; test echo \u0026#39;echo $b\u0026gt;file2\u0026#39; \u0026gt;\u0026gt; test echo \u0026#39;echo save a to ./file3\u0026#39; \u0026gt;\u0026gt; test echo \u0026#39;echo $a\u0026gt;file3\u0026#39; \u0026gt;\u0026gt; test echo \u0026#39;echo save file1 file2 file3 to file4\u0026#39; \u0026gt;\u0026gt; test echo \u0026#39;cat file1\u0026gt;file4\u0026#39; \u0026gt;\u0026gt; test echo \u0026#39;cat file2\u0026gt;\u0026gt;file4\u0026#39; \u0026gt;\u0026gt; test echo \u0026#39;cat file3\u0026gt;\u0026gt;file4\u0026#39; \u0026gt;\u0026gt; test echo \u0026#39;echo save file4 to ./result\u0026#39; \u0026gt;\u0026gt; test echo \u0026#39;cat file4\u0026gt;\u0026gt;result\u0026#39; \u0026gt;\u0026gt; test # test echo Shell Start... # 输出初始化提示 echo set a = 1 a=1 # 设置变量a=1 echo set b = 2 b=2 # 设置变量b=2 echo set c = a+b c=$[$a+$b] # 执行算术运算c=a+b=1+2=3 echo c = $c # 输出计算结果 echo save c to ./file1 echo $c\u0026gt;file1 # 将c的值写入file1 echo save b to ./file2 echo $b\u0026gt;file2 # 将b的值写入file2 echo save a to ./file3 echo $a\u0026gt;file3 # 将a的值写入file3 echo save file1 file2 file3 to file4 cat file1\u0026gt;file4 # 创建file4并写入file1内容 cat file2\u0026gt;\u0026gt;file4 # 追加file2内容 cat file3\u0026gt;\u0026gt;file4 # 追加file3内容 echo save file4 to ./result cat file4\u0026gt;\u0026gt;result # 最终结果是c,b,a的值 $ ./test Shell Start... set a = 1 set b = 2 set c = a+b c = 3 save c to ./file1 save b to ./file2 save a to ./file3 save file1 file2 file3 to file4 save file4 to ./result $ cat result 3 2 1 反引号会先执行命令替换，改变重定向行为。\necho echo Shell Start echo `echo Shell Start` 输出字符串echo Shell Start 先执行命令echo Shell Start再输出该命令的执行结果Shell Start echo echo $c\u0026gt;file1 echo `echo $c\u0026gt;file1` 将字符串echo 3写入file1 先将3写入file1，再输出写入的执行结果（为空），即终端无输出 二、难点分析与实验体会 本次实验的主要难点在于工具链的命令行参数和shell编程掌握不够熟练。\n难点1：sed的用法 为实现在 hello_os.sh 所处的目录新建一个名为BBB的文件，其内容为 AAA文件的第8、32、128、512、1024行的内容提取，构造sed命令\nsed -n \u0026#39;8p;32p;128p;512p;1024p\u0026#39; \u0026#34;$1\u0026#34; \u0026gt; \u0026#34;$2\u0026#34; 难点2：awk行号提取 grep -n \u0026#34;$2\u0026#34; ./\u0026#34;$1\u0026#34; | awk -F \u0026#39;:\u0026#39; \u0026#39;{print $1}\u0026#39; \u0026gt; ./\u0026#34;$3\u0026#34; 难点3：GCC与Make的特殊用法 # 多目录编译示例 gcc -I ../include -c fibo.c -o fibo.o # 调用子目录make命令示例 make -C code fibo.o 三、原创说明 在本次实验中，对工具链的使用参考了官方manual和--help参数。\n在Neovim和LazyVim的安装与配置中，参考了如何在Ubuntu上安装最新版本的Neovim并快速配置_ubuntu安装neovim-CSDN博客 使用 git log 命令时，在 commit 标识符后的一长串数字和字母组成的字符串\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","permalink":"https://oNya685.github.io/posts/buaa/os/lab-0-report/","summary":"\u003ch1 id=\"一思考题\"\u003e一、思考题\u003c/h1\u003e\n\u003ch2 id=\"thinking-01\"\u003eThinking 0.1\u003c/h2\u003e\n\u003cblockquote\u003e\n\u003cp\u003e思考下列有关Git的问题：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e在前述已初始化的~/learnGit 目录下，创建一个名为README.txt的文件。执行命令git status \u0026gt; Untracked.txt（其中的 \u0026gt; 为输出重定向，我们将在0.6.3中详细介绍）。\u003c/li\u003e\n\u003cli\u003e在README.txt 文件中添加任意文件内容，然后使用add命令，再执行命令git status \u0026gt; Stage.txt。\u003c/li\u003e\n\u003cli\u003e提交README.txt，并在提交说明里写入自己的学号。\u003c/li\u003e\n\u003cli\u003e执行命令cat Untracked.txt 和cat Stage.txt，对比两次运行的结果，体会README.txt两次所处位置的不同。\u003c/li\u003e\n\u003cli\u003e修改README.txt 文件，再执行命令git status \u0026gt; Modified.txt。\u003c/li\u003e\n\u003cli\u003e执行命令cat Modified.txt，观察其结果和第一次执行add命令之前的status是否一样，并思考原因。\u003c/li\u003e\n\u003c/ul\u003e\u003c/blockquote\u003e\n\u003chr\u003e\n\u003ch3 id=\"1-untrackedtxt\"\u003e1. Untracked.txt\u003c/h3\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e$  cat Untracked.txt\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e位于分支 master\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e未跟踪的文件:\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  （使用 \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;git add \u0026lt;文件\u0026gt;...\u0026#34;\u003c/span\u003e 以包含要提交的内容）\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        README.txt\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        Untracked.txt\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e提交为空，但是存在尚未跟踪的文件（使用 \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;git add\u0026#34;\u003c/span\u003e 建立跟踪）\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e新建了\u003ccode\u003eREADME.txt\u003c/code\u003e文件，处于Untracked状态。\u003c/p\u003e","title":"[BUAA-OS] Lab 0 实验报告"},{"content":"点此查看作业源文件 1.什么是多道程序设计？多道程序设计与分时系统的区别是什么？ 多道程序设计技术，是指允许多个程序同时进⼊内存并运⾏。即同时把多个程序放⼊内存中，并允许它们交替在CPU中运⾏，共享系统中的各种硬、软件资源，当⼀道程序因I/O请求⽽暂停运⾏时，CPU便⽴即转去运⾏另⼀道程序。多道程序设计技术提⾼了CPU、I/O设备和内存的利⽤率，从⽽提⾼了整个系统的资源利⽤率和系统吞吐量，最终提⾼了整个系统的效率。\n多道程序设计与分时系统的区别在于：多道程序设计主要关注的是如何让多个程序在内存中同时存在并交替执⾏，以提⾼资源利⽤率。分时系统则是在多道程序设计的基础上进⼀步发展，它不仅允许多个程序并发执⾏，还通过时间⽚轮转的⽅式为每个⽤户分配CPU时间，使得多个⽤户可以⼏乎同时使⽤计算机，提供交互式服务。\n2.什么原因推动了操作系统从批处理发展到多道程序，进而发展到分时系统？ 批处理系统的运⾏效率被低速I/O设备限制，CPU空闲时间多，利⽤率低，因此发展出多道程序系统；\n多道程序系统平均周转时间⻓，不能提供交互作⽤能⼒，因此发展出允许多个⽤户共享计算机，多个程序分时共享硬、软件资源的分时系统。\n3.什么是陷阱？与中断的区别是什么？什么是系统调用？ 陷阱是⼀种同步异常，是程序内部有意设置的某⼀特定指令执⾏的结果，例如系统调⽤。陷阱是程序执⾏过程中预期的⾏为，可以复现，⽤于请求操作系统提供服务等。\n中断是⼀种异步异常，通常由外部事件（I/O设备、处理器时钟或定时器）触发，与处理器正在执⾏的内容⽆关。中断是不可预测的，⽤于处理外部事件。\n系统调⽤是⽤户程序与操作系统内核之间的接⼝，允许⽤户程序请求操作系统提供的服务。系统调⽤本质上是⼀种同步异常，或陷阱，⽤于安全地进⼊内核模式并执⾏特权操作。\n4.判断：可移植的操作系统可以从一个系统架构移植到另外一个系统架构而无需修改。 错误。不同系统架构之间存在指令集差异、内存管理方式不同、硬件寄存器配置不一致等根本性区别，操作系统必须针对这些硬件特性进行调整。\n(1)请解释为什么构建完全可移植的OS是不可能的？ 不同硬件架构的指令集、总线设计和CPU字长等存在差异，操作系统必须依赖硬件相关代码，⽆法完全通⽤。\n(2)如果需要你设计一个高度可移植的OS，那么请描述你需要设计的两个层次？ 高度可移植的操作系统由机器相关层和机器无关层组成。机器无关层只需实现一次即可。\n机器相关层处理硬件的具体特性，必须针对每个架构单独实现。该层为机器无关层提供统一的接口。为实现高度可移植性，机器相关层的规模应尽可能最小化。\n5.在设计操作系统时，一些设计指标是相互矛盾的，例如资源利用率、吞吐量、处理时间、健壮性等。请给出一对相互矛盾的设计实例。 资源利⽤率与响应时间。\n资源利⽤率⾼意味着尽可能多地利⽤系统资源，但可能导致频繁的切换和复杂的调度策略，从⽽增加响应时间。响应时间短要求操作系统能够快速响应⽤户请求，可能保留更多的资源⽤于即时响应，导致资源利⽤率下降。\n6.一个计算机系统有输入机一台、打印机两台，现有二道程序同时投入运行，且程序A先开始运行，程序B后运行。程序A的运行轨迹为：计算50ms，打印信息100ms，再计算50ms，打印信息100ms，结束。程序B运行的轨迹为：计算50ms，输入数据80ms，再计算100ms，结束。要求： (1)用图画出这二道程序并发执行时的工作情况。 (2)说明在二道程序运行时，CPU有无空闲等待？若有，在哪段时间内等待？为什么会空闲等待？ 有。在100ms~150ms，程序A在打印信息，程序B在输入数据，故CPU处于空闲等待。\n(3)程序A、B运行时有无等待现象？在什么时候会发生等待现象？ 程序A没有，程序B有。\n在180ms~200ms，程序B完成了输入数据，在等待CPU空闲，而程序A占用了处理器，正在进行计算，故程序B等待了20ms。\n","permalink":"https://oNya685.github.io/posts/buaa/os/homework-1/","summary":"\u003cp\u003e\u003cstrong\u003e\u003ca href=\"%e4%bd%9c%e4%b8%9a1.pdf\" target=\"_blank\"\u003e点此查看作业源文件\u003c/a\u003e\n\u003c/strong\u003e\u003c/p\u003e\n\u003ch1 id=\"1什么是多道程序设计多道程序设计与分时系统的区别是什么\"\u003e1.什么是多道程序设计？多道程序设计与分时系统的区别是什么？\u003c/h1\u003e\n\u003cp\u003e多道程序设计技术，是指允许多个程序同时进⼊内存并运⾏。即同时把多个程序放⼊内存中，并允许它们交替在CPU中运⾏，共享系统中的各种硬、软件资源，当⼀道程序因I/O请求⽽暂停运⾏时，CPU便⽴即转去运⾏另⼀道程序。多道程序设计技术提⾼了CPU、I/O设备和内存的利⽤率，从⽽提⾼了整个系统的资源利⽤率和系统吞吐量，最终提⾼了整个系统的效率。\u003c/p\u003e","title":"[BUAA-OS] 理论作业 1"},{"content":"函数调用处理机制 核心思路 实参与形参分离：通过assignment哈希表实现参数映射，实现形参（函数定义时的参数名）与相对实参（调用时传入的具体因子）的对应关系。 递归替换：通过assign方法逐层展开函数调用 终止条件：当递归到初始定义表达式时完成解析 关键实现步骤 数据结构 为函数调用因子引入通过HashMap\u0026lt;String, Factor\u0026gt;实现的新成员变量assignment，并在为语素实现的assign方法中作为传入参数。\n对于FuncCall因子，引入Integer index，FuncDefine，ArrayList\u0026lt;Factor\u0026gt;，用于实现对Expr中的FuncCall因子的完全解析。\npublic class FuncCall extends VarFactor { private final ConstantFactor index; private final FuncDefine define; private final HashMap\u0026lt;BaseVar, Factor\u0026gt; assignment; // 实际参数列表 } 处理流程 通过expr = expr.assign(null)中调用funcCall.define.get(index).assign(assignment).assign(null)，因除FuncCall以外的其他语素有其assign方法，所以将不断递归下降直到funcCall.define.get(1)和funcCall.define.get(0)。此时再递归向下将不再出现FuncCall类，递归结束并逐级返回。从而实现的Expr的去FuncCall流程，以便进行toPoly和simplify。\n初始化调用\nexpr = expr.assign(null); // 通过expr.assign(null)启动替换链条，null参数表示要解析的最上层表达式中的参数为绝对实参 参数替换机制\n// FuncCall.java ExprFactor assign(HashMap\u0026lt;String, Factor\u0026gt; assignment) { return this.define.get(this.index) .assign(this.assignment) // 先应用this.assignment当前层的参数绑定 .assign(assignment); // 再应用外层传入的assignment参数，实现参数作用域的嵌套覆盖 } 递归展开过程\n// 高层调用 → 中间层展开 → 基础层解析 funcCall.assign(null) → funcCall.define.get(index).assign(assignment).assign(null) → ... → funcCall\u0026#39;.define.get(index\u0026#39;).assign(assignment\u0026#39;).assign(assignment).assign(null) → ... → funcCall\u0026#39;\u0026#39;.define.get(index\u0026#39;\u0026#39;).assign(assignment\u0026#39;\u0026#39;).assign(assignment\u0026#39;).assign(assignment).assign(null) → ... → funcCall.define.get(0 | 1).assign... // 初始定义表达式 类方法实现 经assign方法，BaseVar.assign(assignment)返回Factor，PowerFunc.assign(assignment)返回ExprFactor，FuncCall递归调用(Expr)define.get(this.index).assign(this.assignment).assign(assignment)返回ExprFactor，其他语素的assign方法返回同类对象。最终递归返回不含FuncCall的纯Expr，即可施之toPoly方法。\n类名 assign方法行为 返回类型 BaseVar 直接返回对应的含相对实参的Factor Factor PowerFunc 返回参数赋值的ExprFactor ExprFactor FuncCall 递归调用下层定义进行参数替换 ExprFactor 其他因子 返回由自身组成语素.assign()构造的同类对象 同类对象 处理终点 当递归到define.get(0 | 1)时：\n不再包含FuncCall对象，函数调用结构完全消解 所有形参已被实际参数替换 表达式完全展开为基本元素 可安全调用toPoly()进行多项式转换 可进行最终化简simplify() ","permalink":"https://oNya685.github.io/posts/buaa/oo/unit-1/homework-2-function/","summary":"\u003ch1 id=\"函数调用处理机制\"\u003e函数调用处理机制\u003c/h1\u003e\n\u003ch2 id=\"核心思路\"\u003e核心思路\u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003e实参与形参分离\u003c/strong\u003e：通过\u003ccode\u003eassignment\u003c/code\u003e哈希表实现参数映射，实现\u003cstrong\u003e形参\u003c/strong\u003e（函数定义时的参数名）与\u003cstrong\u003e相对实参\u003c/strong\u003e（调用时传入的具体因子）的对应关系。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e递归替换\u003c/strong\u003e：通过\u003ccode\u003eassign\u003c/code\u003e方法逐层展开函数调用\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e终止条件\u003c/strong\u003e：当递归到\u003cstrong\u003e初始定义\u003c/strong\u003e表达式时完成解析\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2 id=\"关键实现步骤\"\u003e关键实现步骤\u003c/h2\u003e\n\u003ch3 id=\"数据结构\"\u003e数据结构\u003c/h3\u003e\n\u003cp\u003e为函数调用因子引入通过\u003ccode\u003eHashMap\u0026lt;String, Factor\u0026gt;\u003c/code\u003e实现的新成员变量\u003ccode\u003eassignment\u003c/code\u003e，并在为语素实现的\u003ccode\u003eassign\u003c/code\u003e方法中作为传入参数。\u003c/p\u003e","title":"[BUAA-OO] Unit 1 递归函数调用的解析与计算"}]