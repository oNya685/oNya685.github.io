<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>oNya&#39;s Blog</title>
    <link>https://oNya685.github.io/</link>
    <description>Recent content on oNya&#39;s Blog</description>
    <generator>Hugo -- 0.145.0</generator>
    <language>zh-cn</language>
    <lastBuildDate>Sat, 22 Mar 2025 14:16:55 +0800</lastBuildDate>
    <atom:link href="https://oNya685.github.io/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>[BUAA-OO] Unit 1 总结</title>
      <link>https://oNya685.github.io/posts/buaa/oo/unit-1/summary/</link>
      <pubDate>Sat, 22 Mar 2025 14:16:55 +0800</pubDate>
      <guid>https://oNya685.github.io/posts/buaa/oo/unit-1/summary/</guid>
      <description>第一单元博客作业</description>
      <content:encoded><![CDATA[<h1 id="架构简介">架构简介</h1>
<p>在本单元中，作业要求我们对提供了<strong>形式化表述</strong>的复杂表达式进行<strong>解析和化简</strong>，并要求尽可能简短的输出以度量性能分数。</p>
<p>而经过三次作业迭代（其中包含一次重构），最终架构设计图如下：</p>
<p><div class="post-img-view">
    <a data-fancybox="gallery"
         href="UML.png">
        <img loading="lazy" src="/posts/buaa/oo/unit-1/summary/UML_hu_c7d81f24e8d7bd9b.webp">
    </a>
</div></p>
<p>核心处理部分在于递归解析模块的两个递归，在图中具体表现为两个圈。接下来介绍和分析各模块的结构。</p>
<h2 id="主线处理">主线处理</h2>
<p><div class="post-img-view">
    <a data-fancybox="gallery"
         href="%E4%B8%BB%E7%BA%BF%E6%B5%81%E7%A8%8B.png">
        <img alt="主线处理" loading="lazy" src="/posts/buaa/oo/unit-1/summary/%E4%B8%BB%E7%BA%BF%E6%B5%81%E7%A8%8B_hu_50ee1355f57dc9d.webp">
    </a>
</div></p>
<p>本模块是整个项目的主体部分，其中箭头含义表示流程顺序，不代表类的继承关系。主要流程呈现为main方法：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>String input <span style="color:#f92672">=</span> scanner.<span style="color:#a6e22e">nextLine</span>();  <span style="color:#75715e">// 读入</span>
</span></span><span style="display:flex;"><span>Lexer lexer <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Lexer(input.<span style="color:#a6e22e">replaceAll</span>(<span style="color:#e6db74">&#34; &#34;</span>, <span style="color:#e6db74">&#34;&#34;</span>).<span style="color:#a6e22e">replaceAll</span>(<span style="color:#e6db74">&#34;\t&#34;</span>, <span style="color:#e6db74">&#34;&#34;</span>));          <span style="color:#75715e">// 词法解析</span>
</span></span><span style="display:flex;"><span>Parser parser <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Parser(lexer);  <span style="color:#75715e">// 传入Tokens</span>
</span></span><span style="display:flex;"><span>System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(parser  
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">parseExpr</span>()                    <span style="color:#75715e">// 语法解析</span>
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">assign</span>(<span style="color:#66d9ef">null</span>)                   <span style="color:#75715e">// 赋值处理函数调用</span>
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">toPoly</span>()                       <span style="color:#75715e">// 计算化简</span>
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">Print</span>()                        <span style="color:#75715e">// 构造StringBuilder</span>
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">toString</span>());                   <span style="color:#75715e">// 输出结果</span>
</span></span></code></pre></div><p>这样类似<strong>流水线</strong>的设计的优点是显而易见的，我们只需写好每一模块，封装成<strong>黑盒</strong>，确保每一部分的程序正确性，就可以完整实现所需功能。</p>
<p>然而，见上面整体图可以看出，除了实现核心功能的解析模块，其余部分的<strong>耦合度</strong>其实是偏高的。</p>
<p><div class="post-img-view">
    <a data-fancybox="gallery"
         href="Pasted%20image%2020250321102634.png">
        <img alt="Method Metrics" loading="lazy" src="/posts/buaa/oo/unit-1/summary/Pasted%20image%2020250321102634_hu_e1b1a3fedae6e702.webp">
    </a>
</div></p>
<p><div class="post-img-view">
    <a data-fancybox="gallery"
         href="Pasted%20image%2020250321102951.png">
        <img alt="Class Metrics" loading="lazy" src="/posts/buaa/oo/unit-1/summary/Pasted%20image%2020250321102951_hu_12bd78d8e3f53682.webp">
    </a>
</div></p>
<p>我们会发现，<code>Lexer</code>, <code>Parser</code>, <code>Poly</code>这几个在主线中实现了相当一部分功能的类，因为把大量的<strong>重复性</strong>功能藏在一个类甚至一个方法内部实现（例如Lexer的大量if-else出现了控制分支数目大的问题），出现了耦合度过高、可读性差的问题。</p>
<p>举例来说，我们可以分析这个只由两个类实现计算、化简、简化功能的模块：</p>
<h2 id="计算化简">计算化简</h2>
<p><div class="post-img-view">
    <a data-fancybox="gallery"
         href="%E8%AE%A1%E7%AE%97%E5%8C%96%E7%AE%80%E6%A8%A1%E5%9D%97.png">
        <img alt="计算化简" loading="lazy" src="/posts/buaa/oo/unit-1/summary/%E8%AE%A1%E7%AE%97%E5%8C%96%E7%AE%80%E6%A8%A1%E5%9D%97_hu_9a0ff4d29315da4b.webp">
    </a>
</div></p>
<p>这个模块内部实现了过多功能，方法个数多，方法规模大，只因它们都涉及到用于存储化简后输出结果的类——<code>Poly</code>（多项式）和<code>Mono</code>（单项式）——这就导致了这一部分难读、难拆、难拓展。</p>
<h2 id="递归解析">递归解析</h2>
<p>而与之相对的，由于有先导课程的最后一次作业的架构作参考，这个采用递归下降法解析和存储的模块有相当良好的可拓展性和低耦合度。</p>
<p><div class="post-img-view">
    <a data-fancybox="gallery"
         href="%E9%80%92%E5%BD%92%E8%A7%A3%E6%9E%90%E6%A8%A1%E5%9D%97.png">
        <img alt="递归解析" loading="lazy" src="/posts/buaa/oo/unit-1/summary/%E9%80%92%E5%BD%92%E8%A7%A3%E6%9E%90%E6%A8%A1%E5%9D%97_hu_94324e327feaacb4.webp">
    </a>
</div></p>
<p>这一模块的度量值相当良好，故省略去分析。这一部分的递归主要在于</p>
<ol>
<li><code>Expr</code> - <code>Term</code> - <code>&lt;Factor&gt; ExprFactor</code> - <code>Expr</code> （见橙色箭头）形成的环，该递归改编自先导课程作业代码。</li>
<li><code>Expr</code> - <code>Term</code> - <code>&lt;Factor&gt; &lt;VarFactor&gt; FuncCall</code> - <code>&lt;FuncDefine.exprs&gt; Expr</code> 。这一递归赋值处理函数调用的思路详见我在第二次作业中的<a href="http://oo.buaa.edu.cn/assignment/608/discussion/1656" target="_blank">讨论发帖</a>
，当然，在非校园网环境下，你也可以<a href="https://oNya685.github.io/posts/BUAA/OO/Unit-1/homework-2-function/" target="_blank">从此获取</a>
。这一设计有极好的可拓展性，我们将在下一节进一步讨论。</li>
</ol>
<h1 id="迭代成型">迭代成型</h1>
<h2 id="第一次作业">第一次作业</h2>
<p>通过采用先导课的递归下降设计，第一次作业的难点就主要在于计算与化简的部分了。此时我们埋下了直接导致需要重构的第一个雷，对于幂函数的处理，我没有完全参照形式化表述的思路，而是单独设计了一个类来表示幂函数，并于计算时再具体展开。</p>
<h2 id="第二次作业">第二次作业</h2>
<h3 id="重构形式化表述">重构：形式化表述</h3>
<p>重构前后的复杂度其实近似，故省去分析，但值得注意的是前后的架构设计：</p>
<p><div class="post-img-view">
    <a data-fancybox="gallery"
         href="%E9%87%8D%E6%9E%84%E5%AF%B9%E6%AF%94.png">
        <img loading="lazy" src="/posts/buaa/oo/unit-1/summary/%E9%87%8D%E6%9E%84%E5%AF%B9%E6%AF%94_hu_538427942ba17d30.webp">
    </a>
</div></p>
<p>其实都很明了，但最主要的区别其实是：<strong>重构后的类的设计完全符合了给出的形式化表述</strong>。第二次作业的迭代突然把形式化表述内容几乎翻倍不止，如果要沿着原来的架构像打补丁一样加上这大量的迭代内容，很可能最后根本写不完。</p>
<p>而重构后的迭代体验也大幅提升：我只需要无脑照抄形式化表述，就能写好解析器，设计好各个类，这不仅省下了时间，也直接跳过了大量与形式化表述不统一而可能引发的潜在的bug。</p>
<h3 id="另一个大任务是递归函数调用的处理">另一个大任务是递归函数调用的处理</h3>
<p>在得知该迭代需求后，我耗费了相当久的时间思考如何以合理、优雅的方式处理递归函数调用，最终设计的一套<a href="https://oNya685.github.io/posts/BUAA/OO/Unit-1/homework-2-function/" target="_blank">处理思路</a>
取得了相当好的<strong>可拓展性</strong>和相对低的耦合度，并结合<strong>动态规划</strong>和藏在其中的部分简化（例如，若某<code>ExprFactor</code>的<code>Expr</code>有且只有一个<code>Term</code>，该<code>Term</code>有且只有一个<code>Factor</code>，则该<code>ExprFactor</code>的简化方法返回该<code>Factor</code>，否则返回自身），实现了时间和空间上的大幅优化，并顺利解决掉了当<code>f{n}</code>的<code>n</code>过大时易爆栈的问题（事实上，事后发现课程组的Cost限制完全不足以超时或爆栈）。</p>
<h2 id="第三次作业">第三次作业</h2>
<p>虽说在第二次作业的互测里被打了不少次，理应来说，如果有继续迭代开发的需求，我会继续重构，并明确几点：</p>
<ul>
<li>对象属性是否<strong>可变</strong>，会用到返回值的各种方法除了返回值之外应不应该产生<strong>副作用</strong>，会不会错误得<strong>复用</strong>某对象。</li>
<li>明确哪些类需要重写<code>hashCode()</code>和<code>equals()</code>，这一点对于优化性能得分至关重要。</li>
<li>耦合度过高的<code>Poly</code>和<code>Mono</code>是肯定要拆的，怎么<strong>分解</strong>而能继续实现原有功能，怎么设计更适合迭代的<strong>架构</strong>，怎么给优化性能留位置等。</li>
</ul>
<p>但我并没有重构——第三次作业的需求很简单：</p>
<p>一是普通函数调用，我原设计的递归函数调用处理方法有相当的可拓展性，我甚至<strong>没有修改函数相关的类</strong>就轻松实现了该要求。</p>
<p>二是求导因子，但课程组给求导因子的限制过大，尤其是出现范围十分限定，因此我们只需在主线的流水线挑一个方便的环节（包括解析，运算，赋值，简化），附带上求导运算，就实现了。</p>
<p>所以为什么不重构？第二次作业虽然烂了点，但经过强侧和互测的检验，打完补丁就是能<strong>保障正确性</strong>的代码。重构意味着要重新面对潜在的bug，而在当前这一坨上作简单的迭代并没有显著难度，正确性也更有保障。因此，没有第二次重构。</p>
<h1 id="bug分析">Bug分析</h1>
<h2 id="诡异的hashmap">诡异的<code>HashMap</code></h2>
<p>这一bug并不是被测出来的：不解决这bug程序完全不能跑。这一单元里，大家都或多或少地与HashMap之类的容器或者hashCode等方法斗争了许久。至今我也不知道，除了新建一个容器往里塞，怎么遍历才能做到不报错。如果有下次，我可能选<code>.stream().map().collect()</code>。</p>
<h2 id="完全符合形式化表述但符合得不太完全">完全符合形式化表述，但符合得不太完全</h2>
<pre tabindex="0"><code>&lt;递推表达式&gt; → &lt;常数因子&gt; &lt;空白项&gt; &#39;*&#39; &lt;空白项&gt; &lt;自定义递推函数调用n-1&gt; &lt;空白项&gt; &lt;加减&gt; &lt;空白项&gt; &lt;常数因子&gt; &lt;空白项&gt; &#39;*&#39; &lt;空白项&gt; &lt;自定义递推函数调用n-2&gt; [&lt;空白项&gt; &#39;+&#39; &lt;空白项&gt; &lt;函数表达式&gt;]
</code></pre><p>虽然经过一次完全符合形式化表述的重构，但因为我的设计足以实现对函数调用的解析，所以我本以为递推表达式就是比较特殊的表达式，其实不然。这个<code>[&lt;空白项&gt; '+' &lt;空白项&gt; &lt;函数表达式&gt;]</code>的诡异的加号让<code>... + + + +1</code>这样的表述变成了可能。这一bug着实很坑，但也没有什么经验可总结。</p>
<h2 id="谁会在sin里套sinsin">谁会在<code>sin()</code>里套<code>sin()*sin()</code>？</h2>
<p>本以为第三次作业大家都差不多，互测更是全房 0 Hack，应该不会有bug了……吗？</p>
<p><div class="post-img-view">
    <a data-fancybox="gallery"
         href="Pasted%20image%2020250321193556.png">
        <img alt="Bug修复：最后一次Commit" loading="lazy" src="/posts/buaa/oo/unit-1/summary/Pasted%20image%2020250321193556_hu_28ecd893e0e44ae4.webp">
    </a>
</div></p>
<p>啊，输出了<code>sin(sin(...)*sin(...))</code>，但里面是一个表达式而非一个因子，所以应该是<code>sin((sin(...)*sin(...)))</code>。省去了不该省的括号。这个小bug从第二次作业互测测到第三次作业互测，都没有被测出来，第三次强测反倒测出来了，如果侥幸一点没测出来，这个bug可能永远都不会被发现了。</p>
<h2 id="当然也有喜闻乐见的">当然也有喜闻乐见的</h2>
<p>最喜欢分析的bug是别人的bug，在此稍加分析有参考意义的两例。</p>
<h3 id="extratriangle">extraTriangle!!!</h3>
<p><div class="post-img-view">
    <a data-fancybox="gallery"
         href="2007db7b678091ac411a41f40a2e1d2.jpg">
        <img loading="lazy" src="/posts/buaa/oo/unit-1/summary/2007db7b678091ac411a41f40a2e1d2_hu_7d7b277097085463.webp">
    </a>
</div></p>
<p><code>extraTriangle!!!</code>一位没删用于调试的输出信息的同学如是喊道。</p>
<p>这一bug值得分析是因为教会了我们设计一个调试开关，例如：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">// MainClass.java</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> Class MainClass {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">debug</span>() { <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">true</span>; }
</span></span><span style="display:flex;"><span>	...
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span>(String<span style="color:#f92672">[]</span> args) {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (MainClass.<span style="color:#a6e22e">debug</span>()) {
</span></span><span style="display:flex;"><span>			System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(<span style="color:#e6db74">&#34;Debug模式还没关，别看都不看就直接交了&#34;</span>);
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		...
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="可能复用的对象clone或谨防副作用">可能复用的对象，<code>clone()</code>或谨防副作用</h3>
<p>我用一个简单的函数，调用了<code>f{5}(x,x^2)</code>，就一次刀穿了三人（不过其中一人其实没错，他只是在喊<code>extraTriangle!!!</code>），仔细看看，竟与之前发现并修掉的bug如出一辙。有的时候，我们需要这个对象本身，有的时候，我们只是需要这个对象的值。</p>
<p>张三长大了一岁，无论是谁眼中的张三，都长大了一岁。有的时候，我们需要给张三拍照，把他当前的样子保留下来（或者是生成一个和当前的张三长得一样的克隆人）。问题就出在，可能A让张三长大了一岁，而B想给张三拍照时并没考虑到张三长大了一岁，拍下了不符合预期的照片。</p>
<p>我的解决方案是，A生成张三的克隆人，并把克隆人当成张三，后续让“张三”长大一岁，原来的张三就不会受到影响，B随时都可以给张三拍照拍到正确的样子。</p>
<h1 id="测试策略">测试策略</h1>
<p>看源代码还是太折磨了，只有第一次作业读代码来设计测试用例了，后来都找不到用正则解析的了，大家处理思路十分趋同，与其看代码，不如直接构造各类极端样例，进行盲测了。</p>
<p>当然不能直接用互测窗口测，CD太长；也不能开八个IDEA窗口挨个输入，效率太低；首先将八个压缩包编译生成八个jar包，然后用命令行批量处理，用文件实现读写，最后把大家的答案扔进优化得最好最稳定的同学的jar包，就能得到格式统一的输出了。当然这是不够严谨的做法，我们也可以采取python的一些妙妙工具，把输出的字符串里的x直接文本替换成各种刁钻的数值，评判输出的纯数字结果是不是相隔很小即可（理论上结果应该一模一样，但三角函数优化和浮点数带来的误差不可避免）。</p>
<h1 id="优化策略">优化策略</h1>
<p>前文已经提到了大部分的优化，因为实在无力处理三角函数的各种优化，且保住正确性分比贪性能分更稳妥。</p>
<p>现介绍前文未提到的两处优化：</p>
<h2 id="重写equals以合并同类项">重写<code>equals()</code>以合并同类项</h2>
<p>与之对应的，我们也要重写<code>hashCode()</code>以实现在HashMap中能找到该同类项。</p>
<p>这样我们就可以应对括号内的值<strong>存在关联性</strong>的三角函数之间的合并了。</p>
<h2 id="为返回值作顺带简化">为返回值作顺带简化</h2>
<p>例如前文提到的将<code>ExprFactor</code>返回其中仅有的<code>Factor</code>，可以一定程度上省去不必要的括号；又如<code>cos(0)</code>和<code>sin(0)</code>，可以直接返回具体数值。</p>
<h1 id="心得体会">心得体会</h1>
<p>虽然第三次作业的轻松要求确实减少了我们的工作量，让我直接放弃了第二次的重构，但我仍没能理解普通函数调用为什么会放在递归函数调用之后作为新要求迭代。第二次作业的任务量也着实有些惊悚，不知是传统还是失误。</p>
<p>总的来说，第一单元在先导课提供了参考架构的基础上还算顺利，也能明显感到有所收获，期待第二单元的灵异电梯。</p>
]]></content:encoded>
    </item>
    <item>
      <title>[BUAA-OS] Lab 0 实验报告</title>
      <link>https://oNya685.github.io/posts/buaa/os/lab-0-report/</link>
      <pubDate>Sun, 16 Mar 2025 11:27:33 +0800</pubDate>
      <guid>https://oNya685.github.io/posts/buaa/os/lab-0-report/</guid>
      <description>&lt;h1 id=&#34;一思考题&#34;&gt;一、思考题&lt;/h1&gt;
&lt;h2 id=&#34;thinking-01&#34;&gt;Thinking 0.1&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;思考下列有关Git的问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在前述已初始化的~/learnGit 目录下，创建一个名为README.txt的文件。执行命令git status &amp;gt; Untracked.txt（其中的 &amp;gt; 为输出重定向，我们将在0.6.3中详细介绍）。&lt;/li&gt;
&lt;li&gt;在README.txt 文件中添加任意文件内容，然后使用add命令，再执行命令git status &amp;gt; Stage.txt。&lt;/li&gt;
&lt;li&gt;提交README.txt，并在提交说明里写入自己的学号。&lt;/li&gt;
&lt;li&gt;执行命令cat Untracked.txt 和cat Stage.txt，对比两次运行的结果，体会README.txt两次所处位置的不同。&lt;/li&gt;
&lt;li&gt;修改README.txt 文件，再执行命令git status &amp;gt; Modified.txt。&lt;/li&gt;
&lt;li&gt;执行命令cat Modified.txt，观察其结果和第一次执行add命令之前的status是否一样，并思考原因。&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h3 id=&#34;1-untrackedtxt&#34;&gt;1. Untracked.txt&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$  cat Untracked.txt
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;位于分支 master
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;未跟踪的文件:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  （使用 &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;git add &amp;lt;文件&amp;gt;...&amp;#34;&lt;/span&gt; 以包含要提交的内容）
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        README.txt
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        Untracked.txt
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;提交为空，但是存在尚未跟踪的文件（使用 &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;git add&amp;#34;&lt;/span&gt; 建立跟踪）
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;新建了&lt;code&gt;README.txt&lt;/code&gt;文件，处于Untracked状态。&lt;/p&gt;</description>
      <content:encoded><![CDATA[<h1 id="一思考题">一、思考题</h1>
<h2 id="thinking-01">Thinking 0.1</h2>
<blockquote>
<p>思考下列有关Git的问题：</p>
<ul>
<li>在前述已初始化的~/learnGit 目录下，创建一个名为README.txt的文件。执行命令git status &gt; Untracked.txt（其中的 &gt; 为输出重定向，我们将在0.6.3中详细介绍）。</li>
<li>在README.txt 文件中添加任意文件内容，然后使用add命令，再执行命令git status &gt; Stage.txt。</li>
<li>提交README.txt，并在提交说明里写入自己的学号。</li>
<li>执行命令cat Untracked.txt 和cat Stage.txt，对比两次运行的结果，体会README.txt两次所处位置的不同。</li>
<li>修改README.txt 文件，再执行命令git status &gt; Modified.txt。</li>
<li>执行命令cat Modified.txt，观察其结果和第一次执行add命令之前的status是否一样，并思考原因。</li>
</ul></blockquote>
<hr>
<h3 id="1-untrackedtxt">1. Untracked.txt</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>$  cat Untracked.txt
</span></span><span style="display:flex;"><span>位于分支 master
</span></span><span style="display:flex;"><span>未跟踪的文件:
</span></span><span style="display:flex;"><span>  （使用 <span style="color:#e6db74">&#34;git add &lt;文件&gt;...&#34;</span> 以包含要提交的内容）
</span></span><span style="display:flex;"><span>        README.txt
</span></span><span style="display:flex;"><span>        Untracked.txt
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>提交为空，但是存在尚未跟踪的文件（使用 <span style="color:#e6db74">&#34;git add&#34;</span> 建立跟踪）
</span></span></code></pre></div><p>新建了<code>README.txt</code>文件，处于Untracked状态。</p>
<h3 id="2-stagedtxt">2. Staged.txt</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>$  cat Staged.txt
</span></span><span style="display:flex;"><span>位于分支 master
</span></span><span style="display:flex;"><span>要提交的变更：
</span></span><span style="display:flex;"><span>  （使用 <span style="color:#e6db74">&#34;git restore --staged &lt;文件&gt;...&#34;</span> 以取消暂存）
</span></span><span style="display:flex;"><span>        新文件：   README.txt
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>未跟踪的文件:
</span></span><span style="display:flex;"><span>  （使用 <span style="color:#e6db74">&#34;git add &lt;文件&gt;...&#34;</span> 以包含要提交的内容）
</span></span><span style="display:flex;"><span>        Staged.txt
</span></span><span style="display:flex;"><span>        Untracked.txt
</span></span></code></pre></div><p>修改了<code>README.txt</code>的文件内容，并跟踪和暂存该文件，处于Staged状态。</p>
<h3 id="3-modifiedtxt">3. Modified.txt</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>$  cat Modified.txt
</span></span><span style="display:flex;"><span>位于分支 master
</span></span><span style="display:flex;"><span>尚未暂存以备提交的变更：
</span></span><span style="display:flex;"><span>  （使用 <span style="color:#e6db74">&#34;git add &lt;文件&gt;...&#34;</span> 更新要提交的内容）
</span></span><span style="display:flex;"><span>  （使用 <span style="color:#e6db74">&#34;git restore &lt;文件&gt;...&#34;</span> 丢弃工作区的改动）
</span></span><span style="display:flex;"><span>        修改：     README.txt
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>未跟踪的文件:
</span></span><span style="display:flex;"><span>  （使用 <span style="color:#e6db74">&#34;git add &lt;文件&gt;...&#34;</span> 以包含要提交的内容）
</span></span><span style="display:flex;"><span>        Modified.txt
</span></span><span style="display:flex;"><span>        Staged.txt
</span></span><span style="display:flex;"><span>        Untracked.txt
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>修改尚未加入提交（使用 <span style="color:#e6db74">&#34;git add&#34;</span> 和/或 <span style="color:#e6db74">&#34;git commit -a&#34;</span>）
</span></span></code></pre></div><p><code>README.txt</code>经暂存和提交后处于Unmodified状态，修改文件内容使其进入Modified状态等待暂存。</p>
<h2 id="thinking-02">Thinking 0.2</h2>
<blockquote>
<p>仔细看看<a href="%e5%9b%be%200.10%20-%20Git%20%e4%b8%ad%e7%9a%84%e5%9b%9b%e7%a7%8d%e7%8a%b6%e6%80%81%e8%bd%ac%e6%8d%a2%e5%85%b3%e7%b3%bb.png" target="_blank">0.10</a>
，思考一下箭头中的add the file、stage the file和commit分别对应的是Git里的哪些命令呢？</p>
<p><div class="post-img-view">
    <a data-fancybox="gallery"
         href="%E5%9B%BE%200.10%20-%20Git%20%E4%B8%AD%E7%9A%84%E5%9B%9B%E7%A7%8D%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2%E5%85%B3%E7%B3%BB.png">
        <img alt="图 0.10 - Git 中的四种状态转换关系" loading="lazy" src="/posts/buaa/os/lab-0-report/%E5%9B%BE%200.10%20-%20Git%20%E4%B8%AD%E7%9A%84%E5%9B%9B%E7%A7%8D%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2%E5%85%B3%E7%B3%BB_hu_85b07da4fcfbe74e.webp">
    </a>
</div></p></blockquote>
<hr>
<h3 id="1-add-the-file">1. add the file</h3>
<p>add the file 对应的是<code>git add</code>。</p>
<h3 id="2-stage-the-file">2. stage the file</h3>
<p>stage the file 对应的是<code>git add</code>。</p>
<h3 id="3-commit">3. commit</h3>
<p>commit 对应的是<code>git commit</code>。</p>
<h2 id="thinking-03">Thinking 0.3</h2>
<blockquote>
<p>思考下列问题：</p>
<ol>
<li>代码文件print.c被错误删除时，应当使用什么命令将其恢复？</li>
<li>代码文件print.c被错误删除后，执行了git rm print.c命令，此时应当使用什么命令将其恢复？</li>
<li>无关文件hello.txt已经被添加到暂存区时，如何在不删除此文件的前提下将其移出暂存区？</li>
</ol></blockquote>
<h3 id="1-代码文件-printc-被错误删除时应当使用什么命令将其恢复">1. 代码文件 print.c 被错误删除时，应当使用什么命令将其恢复？</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>git restore print.c
</span></span></code></pre></div><p>print.c 尚未执行<code>git add</code>，故可以从暂存区将print.c恢复到工作区中。</p>
<h3 id="2-代码文件-printc-被错误删除后执行了-git-rm-printc-命令此时应当使用什么命令将其恢复">2. 代码文件 print.c 被错误删除后，执行了 git rm print.c 命令，此时应当使用什么命令将其恢复？</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>git reset HEAD print.c
</span></span><span style="display:flex;"><span>git restore print.c
</span></span></code></pre></div><p>首先撤销暂存区的修改（删除了print.c），然后将print.c从暂存区恢复到工作区。</p>
<h3 id="3-无关文件-hellotxt-已经被添加到暂存区时如何在不删除此文件的前提下将其移出暂存区">3. 无关文件 hello.txt 已经被添加到暂存区时，如何在不删除此文件的前提下将其移出暂存区？</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>git reset HEAD hello.txt
</span></span></code></pre></div><p>撤销暂存区的修改，把暂存区恢复到执行<code>git add</code>之前的状态。</p>
<h2 id="thinking-04">Thinking 0.4</h2>
<blockquote>
<p>思考下列有关 Git 的问题：</p>
<ul>
<li>找到在 /home/22xxxxxx/learnGit 下刚刚创建的 README.txt 文件，若不存在则新建该文件。</li>
<li>在文件里加入 Testing 1，git add，git commit，提交说明记为 1。</li>
<li>模仿上述做法，把 1 分别改为 2 和 3，再提交两次。</li>
<li>使用 git log 命令查看提交日志，看是否已经有三次提交，记下提交说明为 3 的哈希值<sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup>。</li>
<li>进行版本回退。执行命令 git reset &ndash;hard HEAD^ 后，再执行 git log，观察其变化。</li>
<li>找到提交说明为 1 的哈希值，执行命令 git reset &ndash;hard &lt;hash&gt; 后，再执行 git log，观察其变化。</li>
<li>现在已经回到了旧版本，为了再次回到新版本，执行 git reset &ndash;hard &lt;hash&gt;，再执行 git log，观察其变化。</li>
</ul></blockquote>
<hr>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>$  git log
</span></span><span style="display:flex;"><span>commit a6ebe244272dd6bcb1f57ba9af3c957f3e7235b3 <span style="color:#f92672">(</span>HEAD -&gt; master<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>Author: 姜宇墨 &lt;YumoJiang@buaa.edu.cn&gt;
</span></span><span style="display:flex;"><span>Date:   Tue Mar <span style="color:#ae81ff">11</span> 19:08:41 <span style="color:#ae81ff">2025</span> +0800
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#ae81ff">3</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>commit 1d11df1461528ce8e2b67151384d4b24bdfec571
</span></span><span style="display:flex;"><span>Author: 姜宇墨 &lt;YumoJiang@buaa.edu.cn&gt;
</span></span><span style="display:flex;"><span>Date:   Tue Mar <span style="color:#ae81ff">11</span> 19:08:33 <span style="color:#ae81ff">2025</span> +0800
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#ae81ff">2</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>commit 3f8eb4043efae29bbb9eb626444f955a825f3535
</span></span><span style="display:flex;"><span>Author: 姜宇墨 &lt;YumoJiang@buaa.edu.cn&gt;
</span></span><span style="display:flex;"><span>Date:   Tue Mar <span style="color:#ae81ff">11</span> 19:08:12 <span style="color:#ae81ff">2025</span> +0800
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#ae81ff">1</span>
</span></span></code></pre></div><p>提交说明为<code>3</code>的哈希值为<code>a6ebe244272dd6bcb1f57ba9af3c957f3e7235b3</code>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>$  git reset --hard HEAD^
</span></span><span style="display:flex;"><span>HEAD 现在位于 1d11df1 <span style="color:#ae81ff">2</span>
</span></span><span style="display:flex;"><span>$  git log
</span></span><span style="display:flex;"><span>commit 1d11df1461528ce8e2b67151384d4b24bdfec571 <span style="color:#f92672">(</span>HEAD -&gt; master<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>Author: 姜宇墨 &lt;YumoJiang@buaa.edu.cn&gt;
</span></span><span style="display:flex;"><span>Date:   Tue Mar <span style="color:#ae81ff">11</span> 19:08:33 <span style="color:#ae81ff">2025</span> +0800
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#ae81ff">2</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>commit 3f8eb4043efae29bbb9eb626444f955a825f3535
</span></span><span style="display:flex;"><span>Author: 姜宇墨 &lt;YumoJiang@buaa.edu.cn&gt;
</span></span><span style="display:flex;"><span>Date:   Tue Mar <span style="color:#ae81ff">11</span> 19:08:12 <span style="color:#ae81ff">2025</span> +0800
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#ae81ff">1</span>
</span></span></code></pre></div><p>变化：当前Git仓库的状态回到了<code>2</code>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>$  git reset --hard 3f8eb4043efae29bbb9eb626444f955a825f3535
</span></span><span style="display:flex;"><span>HEAD 现在位于 3f8eb40 <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>$  git log
</span></span><span style="display:flex;"><span>commit 3f8eb4043efae29bbb9eb626444f955a825f3535 <span style="color:#f92672">(</span>HEAD -&gt; master<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>Author: 姜宇墨 &lt;YumoJiang@buaa.edu.cn&gt;
</span></span><span style="display:flex;"><span>Date:   Tue Mar <span style="color:#ae81ff">11</span> 19:08:12 <span style="color:#ae81ff">2025</span> +0800
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#ae81ff">1</span>
</span></span></code></pre></div><p>变化：当前Git仓库的状态回到了<code>1</code>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>$  git reset --hard a6ebe244272dd6bcb1f57ba9af3c957f3e7235b3
</span></span><span style="display:flex;"><span>HEAD 现在位于 a6ebe24 <span style="color:#ae81ff">3</span>
</span></span><span style="display:flex;"><span>$  git log
</span></span><span style="display:flex;"><span>commit a6ebe244272dd6bcb1f57ba9af3c957f3e7235b3 <span style="color:#f92672">(</span>HEAD -&gt; master<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>Author: 姜宇墨 &lt;YumoJiang@buaa.edu.cn&gt;
</span></span><span style="display:flex;"><span>Date:   Tue Mar <span style="color:#ae81ff">11</span> 19:08:41 <span style="color:#ae81ff">2025</span> +0800
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#ae81ff">3</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>commit 1d11df1461528ce8e2b67151384d4b24bdfec571
</span></span><span style="display:flex;"><span>Author: 姜宇墨 &lt;YumoJiang@buaa.edu.cn&gt;
</span></span><span style="display:flex;"><span>Date:   Tue Mar <span style="color:#ae81ff">11</span> 19:08:33 <span style="color:#ae81ff">2025</span> +0800
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#ae81ff">2</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>commit 3f8eb4043efae29bbb9eb626444f955a825f3535
</span></span><span style="display:flex;"><span>Author: 姜宇墨 &lt;YumoJiang@buaa.edu.cn&gt;
</span></span><span style="display:flex;"><span>Date:   Tue Mar <span style="color:#ae81ff">11</span> 19:08:12 <span style="color:#ae81ff">2025</span> +0800
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#ae81ff">1</span>
</span></span></code></pre></div><p>变化：当前Git仓库的状态回到了<code>3</code>。</p>
<h2 id="thinking-05">Thinking 0.5</h2>
<blockquote>
<p>执行如下命令, 并查看结果</p>
<ul>
<li>echo first</li>
<li>echo second &gt; output.txt</li>
<li>echo third &gt; output.txt</li>
<li>echo forth &raquo; output.txt</li>
</ul></blockquote>
<hr>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>$  echo first
</span></span><span style="display:flex;"><span>first
</span></span><span style="display:flex;"><span>$  echo second &gt; output.txt <span style="color:#f92672">&amp;&amp;</span> cat output.txt
</span></span><span style="display:flex;"><span>second
</span></span><span style="display:flex;"><span>$  echo third &gt; output.txt <span style="color:#f92672">&amp;&amp;</span> cat output.txt
</span></span><span style="display:flex;"><span>third
</span></span><span style="display:flex;"><span>$  echo forth &gt;&gt; output.txt <span style="color:#f92672">&amp;&amp;</span> cat output.txt
</span></span><span style="display:flex;"><span>third
</span></span><span style="display:flex;"><span>forth
</span></span></code></pre></div><h2 id="thinking-06">Thinking 0.6</h2>
<blockquote>
<p>使用你知道的方法（包括重定向）创建下图内容的文件（文件命名为 test），将创建该文件的命令序列保存在command文件中，并将test文件作为批处理文件运行，将运行结果输出至result文件中。给出command文件和result文件的内容，并对最后的结果进行解释说明（可以从test文件的内容入手）。具体实现的过程中思考下列问题: echo echo Shell Start 与 echo `echo Shell Start` 效果是否有区别; echo echo $c&gt;file1 与 echo `echo $c&gt;file1` 效果是否有区别.</p></blockquote>
<hr>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#75715e"># command</span>
</span></span><span style="display:flex;"><span>echo <span style="color:#e6db74">&#39;echo Shell Start...&#39;</span> &gt; test
</span></span><span style="display:flex;"><span>echo <span style="color:#e6db74">&#39;echo set a = 1&#39;</span> &gt;&gt; test
</span></span><span style="display:flex;"><span>echo <span style="color:#e6db74">&#39;a=1&#39;</span> &gt;&gt; test
</span></span><span style="display:flex;"><span>echo <span style="color:#e6db74">&#39;echo set b = 2&#39;</span> &gt;&gt; test
</span></span><span style="display:flex;"><span>echo <span style="color:#e6db74">&#39;b=2&#39;</span> &gt;&gt; test
</span></span><span style="display:flex;"><span>echo <span style="color:#e6db74">&#39;echo set c = a+b&#39;</span> &gt;&gt; test
</span></span><span style="display:flex;"><span>echo <span style="color:#e6db74">&#39;c=$[$a+$b]&#39;</span> &gt;&gt; test
</span></span><span style="display:flex;"><span>echo <span style="color:#e6db74">&#39;echo c = $c&#39;</span> &gt;&gt; test
</span></span><span style="display:flex;"><span>echo <span style="color:#e6db74">&#39;echo save c to ./file1&#39;</span> &gt;&gt; test
</span></span><span style="display:flex;"><span>echo <span style="color:#e6db74">&#39;echo $c&gt;file1&#39;</span> &gt;&gt; test
</span></span><span style="display:flex;"><span>echo <span style="color:#e6db74">&#39;echo save b to ./file2&#39;</span> &gt;&gt; test
</span></span><span style="display:flex;"><span>echo <span style="color:#e6db74">&#39;echo $b&gt;file2&#39;</span> &gt;&gt; test
</span></span><span style="display:flex;"><span>echo <span style="color:#e6db74">&#39;echo save a to ./file3&#39;</span> &gt;&gt; test
</span></span><span style="display:flex;"><span>echo <span style="color:#e6db74">&#39;echo $a&gt;file3&#39;</span> &gt;&gt; test
</span></span><span style="display:flex;"><span>echo <span style="color:#e6db74">&#39;echo save file1 file2 file3 to file4&#39;</span> &gt;&gt; test
</span></span><span style="display:flex;"><span>echo <span style="color:#e6db74">&#39;cat file1&gt;file4&#39;</span> &gt;&gt; test
</span></span><span style="display:flex;"><span>echo <span style="color:#e6db74">&#39;cat file2&gt;&gt;file4&#39;</span> &gt;&gt; test
</span></span><span style="display:flex;"><span>echo <span style="color:#e6db74">&#39;cat file3&gt;&gt;file4&#39;</span> &gt;&gt; test
</span></span><span style="display:flex;"><span>echo <span style="color:#e6db74">&#39;echo save file4 to ./result&#39;</span> &gt;&gt; test
</span></span><span style="display:flex;"><span>echo <span style="color:#e6db74">&#39;cat file4&gt;&gt;result&#39;</span> &gt;&gt; test
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#75715e"># test</span>
</span></span><span style="display:flex;"><span>echo Shell Start...        <span style="color:#75715e"># 输出初始化提示</span>
</span></span><span style="display:flex;"><span>echo set a <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>a<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>                        <span style="color:#75715e"># 设置变量a=1</span>
</span></span><span style="display:flex;"><span>echo set b <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>
</span></span><span style="display:flex;"><span>b<span style="color:#f92672">=</span><span style="color:#ae81ff">2</span>                        <span style="color:#75715e"># 设置变量b=2</span>
</span></span><span style="display:flex;"><span>echo set c <span style="color:#f92672">=</span> a+b
</span></span><span style="display:flex;"><span>c<span style="color:#f92672">=</span>$<span style="color:#f92672">[</span>$a+$b<span style="color:#f92672">]</span>                 <span style="color:#75715e"># 执行算术运算c=a+b=1+2=3</span>
</span></span><span style="display:flex;"><span>echo c <span style="color:#f92672">=</span> $c                <span style="color:#75715e"># 输出计算结果</span>
</span></span><span style="display:flex;"><span>echo save c to ./file1
</span></span><span style="display:flex;"><span>echo $c&gt;file1              <span style="color:#75715e"># 将c的值写入file1</span>
</span></span><span style="display:flex;"><span>echo save b to ./file2
</span></span><span style="display:flex;"><span>echo $b&gt;file2              <span style="color:#75715e"># 将b的值写入file2</span>
</span></span><span style="display:flex;"><span>echo save a to ./file3
</span></span><span style="display:flex;"><span>echo $a&gt;file3              <span style="color:#75715e"># 将a的值写入file3</span>
</span></span><span style="display:flex;"><span>echo save file1 file2 file3 to file4
</span></span><span style="display:flex;"><span>cat file1&gt;file4            <span style="color:#75715e"># 创建file4并写入file1内容</span>
</span></span><span style="display:flex;"><span>cat file2&gt;&gt;file4           <span style="color:#75715e"># 追加file2内容</span>
</span></span><span style="display:flex;"><span>cat file3&gt;&gt;file4           <span style="color:#75715e"># 追加file3内容</span>
</span></span><span style="display:flex;"><span>echo save file4 to ./result
</span></span><span style="display:flex;"><span>cat file4&gt;&gt;result          <span style="color:#75715e"># 最终结果是c,b,a的值</span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>$  ./test
</span></span><span style="display:flex;"><span>Shell Start...
</span></span><span style="display:flex;"><span>set a <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>set b <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>
</span></span><span style="display:flex;"><span>set c <span style="color:#f92672">=</span> a+b
</span></span><span style="display:flex;"><span>c <span style="color:#f92672">=</span> <span style="color:#ae81ff">3</span>
</span></span><span style="display:flex;"><span>save c to ./file1
</span></span><span style="display:flex;"><span>save b to ./file2
</span></span><span style="display:flex;"><span>save a to ./file3
</span></span><span style="display:flex;"><span>save file1 file2 file3 to file4
</span></span><span style="display:flex;"><span>save file4 to ./result
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>$  cat result
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">3</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">2</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">1</span>
</span></span></code></pre></div><p>反引号会先执行命令替换，改变重定向行为。</p>
<table>
  <thead>
      <tr>
          <th>echo echo Shell Start</th>
          <th>echo `echo Shell Start`</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>输出字符串<code>echo Shell Start</code></td>
          <td>先执行命令<code>echo Shell Start</code>再输出该命令的执行结果<code>Shell Start</code></td>
      </tr>
  </tbody>
</table>
<table>
  <thead>
      <tr>
          <th>echo echo $c&gt;file1</th>
          <th>echo `echo $c&gt;file1`</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>将字符串<code>echo 3</code>写入file1</td>
          <td>先将<code>3</code>写入file1，再输出写入的执行结果（为空），即终端无输出</td>
      </tr>
  </tbody>
</table>
<h1 id="二难点分析与实验体会">二、难点分析与实验体会</h1>
<p>本次实验的主要难点在于<strong>工具链的命令行参数</strong>和<strong>shell编程</strong>掌握不够熟练。</p>
<h3 id="难点1sed的用法">难点1：<code>sed</code>的用法</h3>
<p>为实现在 hello_os.sh 所处的目录新建一个名为BBB的文件，其内容为 AAA文件的第8、32、128、512、1024行的内容提取，构造<code>sed</code>命令</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sed -n <span style="color:#e6db74">&#39;8p;32p;128p;512p;1024p&#39;</span> <span style="color:#e6db74">&#34;</span>$1<span style="color:#e6db74">&#34;</span> &gt; <span style="color:#e6db74">&#34;</span>$2<span style="color:#e6db74">&#34;</span>
</span></span></code></pre></div><h3 id="难点2awk行号提取">难点2：<code>awk</code>行号提取</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>grep -n <span style="color:#e6db74">&#34;</span>$2<span style="color:#e6db74">&#34;</span> ./<span style="color:#e6db74">&#34;</span>$1<span style="color:#e6db74">&#34;</span> | awk -F <span style="color:#e6db74">&#39;:&#39;</span> <span style="color:#e6db74">&#39;{print $1}&#39;</span> &gt; ./<span style="color:#e6db74">&#34;</span>$3<span style="color:#e6db74">&#34;</span>
</span></span></code></pre></div><h3 id="难点3gcc与make的特殊用法">难点3：GCC与Make的特殊用法</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#75715e"># 多目录编译示例</span>
</span></span><span style="display:flex;"><span>gcc -I ../include -c fibo.c -o fibo.o
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 调用子目录make命令示例</span>
</span></span><span style="display:flex;"><span>make -C code fibo.o
</span></span></code></pre></div><hr>
<h1 id="三原创说明">三、原创说明</h1>
<p>在本次实验中，对工具链的使用参考了官方manual和<code>--help</code>参数。</p>
<p>在Neovim和LazyVim的安装与配置中，参考了<a href="https://blog.csdn.net/m0_60670525/article/details/136329707" target="_blank">如何在Ubuntu上安装最新版本的Neovim并快速配置_ubuntu安装neovim-CSDN博客</a>
</p>
<div class="footnotes" role="doc-endnotes">
<hr>
<ol>
<li id="fn:1">
<p>使用 git log 命令时，在 commit 标识符后的一长串数字和字母组成的字符串&#160;<a href="#fnref:1" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
</ol>
</div>
]]></content:encoded>
    </item>
    <item>
      <title>[BUAA-OS] 理论作业 1</title>
      <link>https://oNya685.github.io/posts/buaa/os/homework-1/</link>
      <pubDate>Sun, 16 Mar 2025 11:19:17 +0800</pubDate>
      <guid>https://oNya685.github.io/posts/buaa/os/homework-1/</guid>
      <description>&lt;p&gt;&lt;strong&gt;&lt;a href=&#34;%e4%bd%9c%e4%b8%9a1.pdf&#34; target=&#34;_blank&#34;&gt;点此查看作业源文件&lt;/a&gt;
&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&#34;1什么是多道程序设计多道程序设计与分时系统的区别是什么&#34;&gt;1.什么是多道程序设计？多道程序设计与分时系统的区别是什么？&lt;/h1&gt;
&lt;p&gt;多道程序设计技术，是指允许多个程序同时进⼊内存并运⾏。即同时把多个程序放⼊内存中，并允许它们交替在CPU中运⾏，共享系统中的各种硬、软件资源，当⼀道程序因I/O请求⽽暂停运⾏时，CPU便⽴即转去运⾏另⼀道程序。多道程序设计技术提⾼了CPU、I/O设备和内存的利⽤率，从⽽提⾼了整个系统的资源利⽤率和系统吞吐量，最终提⾼了整个系统的效率。&lt;/p&gt;</description>
      <content:encoded><![CDATA[<p><strong><a href="%e4%bd%9c%e4%b8%9a1.pdf" target="_blank">点此查看作业源文件</a>
</strong></p>
<h1 id="1什么是多道程序设计多道程序设计与分时系统的区别是什么">1.什么是多道程序设计？多道程序设计与分时系统的区别是什么？</h1>
<p>多道程序设计技术，是指允许多个程序同时进⼊内存并运⾏。即同时把多个程序放⼊内存中，并允许它们交替在CPU中运⾏，共享系统中的各种硬、软件资源，当⼀道程序因I/O请求⽽暂停运⾏时，CPU便⽴即转去运⾏另⼀道程序。多道程序设计技术提⾼了CPU、I/O设备和内存的利⽤率，从⽽提⾼了整个系统的资源利⽤率和系统吞吐量，最终提⾼了整个系统的效率。</p>
<p>多道程序设计与分时系统的区别在于：多道程序设计主要关注的是如何让多个程序在内存中同时存在并交替执⾏，以提⾼资源利⽤率。分时系统则是在多道程序设计的基础上进⼀步发展，它不仅允许多个程序并发执⾏，还通过时间⽚轮转的⽅式为每个⽤户分配CPU时间，使得多个⽤户可以⼏乎同时使⽤计算机，提供交互式服务。</p>
<h1 id="2什么原因推动了操作系统从批处理发展到多道程序进而发展到分时系统">2.什么原因推动了操作系统从批处理发展到多道程序，进而发展到分时系统？</h1>
<p>批处理系统的运⾏效率被低速I/O设备限制，CPU空闲时间多，利⽤率低，因此发展出多道程序系统；</p>
<p>多道程序系统平均周转时间⻓，不能提供交互作⽤能⼒，因此发展出允许多个⽤户共享计算机，多个程序分时共享硬、软件资源的分时系统。</p>
<h1 id="3什么是陷阱与中断的区别是什么什么是系统调用">3.什么是陷阱？与中断的区别是什么？什么是系统调用？</h1>
<p>陷阱是⼀种同步异常，是程序内部有意设置的某⼀特定指令执⾏的结果，例如系统调⽤。陷阱是程序执⾏过程中预期的⾏为，可以复现，⽤于请求操作系统提供服务等。</p>
<p>中断是⼀种异步异常，通常由外部事件（I/O设备、处理器时钟或定时器）触发，与处理器正在执⾏的内容⽆关。中断是不可预测的，⽤于处理外部事件。</p>
<p>系统调⽤是⽤户程序与操作系统内核之间的接⼝，允许⽤户程序请求操作系统提供的服务。系统调⽤本质上是⼀种同步异常，或陷阱，⽤于安全地进⼊内核模式并执⾏特权操作。</p>
<h1 id="4判断可移植的操作系统可以从一个系统架构移植到另外一个系统架构而无需修改">4.判断：可移植的操作系统可以从一个系统架构移植到另外一个系统架构而无需修改。</h1>
<p>错误。不同系统架构之间存在指令集差异、内存管理方式不同、硬件寄存器配置不一致等根本性区别，操作系统必须针对这些硬件特性进行调整。</p>
<h2 id="1请解释为什么构建完全可移植的os是不可能的">(1)请解释为什么构建完全可移植的OS是不可能的？</h2>
<p>不同硬件架构的指令集、总线设计和CPU字长等存在差异，操作系统必须依赖硬件相关代码，⽆法完全通⽤。</p>
<h2 id="2如果需要你设计一个高度可移植的os那么请描述你需要设计的两个层次">(2)如果需要你设计一个高度可移植的OS，那么请描述你需要设计的两个层次？</h2>
<p>高度可移植的操作系统由机器相关层和机器无关层组成。机器无关层只需实现一次即可。</p>
<p>机器相关层处理硬件的具体特性，必须针对每个架构单独实现。该层为机器无关层提供统一的接口。为实现高度可移植性，机器相关层的规模应尽可能最小化。</p>
<h1 id="5在设计操作系统时一些设计指标是相互矛盾的例如资源利用率吞吐量处理时间健壮性等请给出一对相互矛盾的设计实例">5.在设计操作系统时，一些设计指标是相互矛盾的，例如资源利用率、吞吐量、处理时间、健壮性等。请给出一对相互矛盾的设计实例。</h1>
<p>资源利⽤率与响应时间。</p>
<p>资源利⽤率⾼意味着尽可能多地利⽤系统资源，但可能导致频繁的切换和复杂的调度策略，从⽽增加响应时间。响应时间短要求操作系统能够快速响应⽤户请求，可能保留更多的资源⽤于即时响应，导致资源利⽤率下降。</p>
<h1 id="6一个计算机系统有输入机一台打印机两台现有二道程序同时投入运行且程序a先开始运行程序b后运行程序a的运行轨迹为计算50ms打印信息100ms再计算50ms打印信息100ms结束程序b运行的轨迹为计算50ms输入数据80ms再计算100ms结束要求">6.一个计算机系统有输入机一台、打印机两台，现有二道程序同时投入运行，且程序A先开始运行，程序B后运行。程序A的运行轨迹为：计算50ms，打印信息100ms，再计算50ms，打印信息100ms，结束。程序B运行的轨迹为：计算50ms，输入数据80ms，再计算100ms，结束。要求：</h1>
<h2 id="1用图画出这二道程序并发执行时的工作情况">(1)用图画出这二道程序并发执行时的工作情况。</h2>
<p><div class="post-img-view">
    <a data-fancybox="gallery"
         href="Pasted%20image%2020250316112252.png">
        <img loading="lazy" src="/posts/buaa/os/homework-1/Pasted%20image%2020250316112252_hu_714830f66a53f33c.webp">
    </a>
</div></p>
<h2 id="2说明在二道程序运行时cpu有无空闲等待若有在哪段时间内等待为什么会空闲等待">(2)说明在二道程序运行时，CPU有无空闲等待？若有，在哪段时间内等待？为什么会空闲等待？</h2>
<p>有。在100ms~150ms，程序A在打印信息，程序B在输入数据，故CPU处于空闲等待。</p>
<h2 id="3程序ab运行时有无等待现象在什么时候会发生等待现象">(3)程序A、B运行时有无等待现象？在什么时候会发生等待现象？</h2>
<p>程序A没有，程序B有。</p>
<p>在180ms~200ms，程序B完成了输入数据，在等待CPU空闲，而程序A占用了处理器，正在进行计算，故程序B等待了20ms。</p>
]]></content:encoded>
    </item>
    <item>
      <title>[BUAA-OO] Unit 1 递归函数调用的解析与计算</title>
      <link>https://oNya685.github.io/posts/buaa/oo/unit-1/homework-2-function/</link>
      <pubDate>Wed, 05 Mar 2025 20:48:35 +0000</pubDate>
      <guid>https://oNya685.github.io/posts/buaa/oo/unit-1/homework-2-function/</guid>
      <description>&lt;h1 id=&#34;函数调用处理机制&#34;&gt;函数调用处理机制&lt;/h1&gt;
&lt;h2 id=&#34;核心思路&#34;&gt;核心思路&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;实参与形参分离&lt;/strong&gt;：通过&lt;code&gt;assignment&lt;/code&gt;哈希表实现参数映射，实现&lt;strong&gt;形参&lt;/strong&gt;（函数定义时的参数名）与&lt;strong&gt;相对实参&lt;/strong&gt;（调用时传入的具体因子）的对应关系。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;递归替换&lt;/strong&gt;：通过&lt;code&gt;assign&lt;/code&gt;方法逐层展开函数调用&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;终止条件&lt;/strong&gt;：当递归到&lt;strong&gt;初始定义&lt;/strong&gt;表达式时完成解析&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;关键实现步骤&#34;&gt;关键实现步骤&lt;/h2&gt;
&lt;h3 id=&#34;数据结构&#34;&gt;数据结构&lt;/h3&gt;
&lt;p&gt;为函数调用因子引入通过&lt;code&gt;HashMap&amp;lt;String, Factor&amp;gt;&lt;/code&gt;实现的新成员变量&lt;code&gt;assignment&lt;/code&gt;，并在为语素实现的&lt;code&gt;assign&lt;/code&gt;方法中作为传入参数。&lt;/p&gt;</description>
      <content:encoded><![CDATA[<h1 id="函数调用处理机制">函数调用处理机制</h1>
<h2 id="核心思路">核心思路</h2>
<ol>
<li><strong>实参与形参分离</strong>：通过<code>assignment</code>哈希表实现参数映射，实现<strong>形参</strong>（函数定义时的参数名）与<strong>相对实参</strong>（调用时传入的具体因子）的对应关系。</li>
<li><strong>递归替换</strong>：通过<code>assign</code>方法逐层展开函数调用</li>
<li><strong>终止条件</strong>：当递归到<strong>初始定义</strong>表达式时完成解析</li>
</ol>
<h2 id="关键实现步骤">关键实现步骤</h2>
<h3 id="数据结构">数据结构</h3>
<p>为函数调用因子引入通过<code>HashMap&lt;String, Factor&gt;</code>实现的新成员变量<code>assignment</code>，并在为语素实现的<code>assign</code>方法中作为传入参数。</p>
<p>对于<code>FuncCall</code>因子，引入<code>Integer index</code>，<code>FuncDefine</code>，<code>ArrayList&lt;Factor&gt;</code>，用于实现对Expr中的FuncCall因子的完全解析。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">FuncCall</span> <span style="color:#66d9ef">extends</span> VarFactor {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">final</span> ConstantFactor index;  
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">final</span> FuncDefine define;  
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">final</span> HashMap<span style="color:#f92672">&lt;</span>BaseVar, Factor<span style="color:#f92672">&gt;</span> assignment; <span style="color:#75715e">// 实际参数列表</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="处理流程">处理流程</h3>
<p>通过<code>expr = expr.assign(null)</code>中调用<code>funcCall.define.get(index).assign(assignment).assign(null)</code>，因除<code>FuncCall</code>以外的其他语素有其<code>assign</code>方法，所以将不断递归下降直到<code>funcCall.define.get(1)</code>和<code>funcCall.define.get(0)</code>。此时再递归向下将不再出现<code>FuncCall</code>类，递归结束并逐级返回。从而实现的<code>Expr</code>的去<code>FuncCall</code>流程，以便进行<code>toPoly</code>和<code>simplify</code>。</p>
<ol>
<li>
<p><strong>初始化调用</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>expr <span style="color:#f92672">=</span> expr.<span style="color:#a6e22e">assign</span>(<span style="color:#66d9ef">null</span>);
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 通过expr.assign(null)启动替换链条，null参数表示要解析的最上层表达式中的参数为绝对实参</span>
</span></span></code></pre></div></li>
<li>
<p><strong>参数替换机制</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">// FuncCall.java</span>
</span></span><span style="display:flex;"><span>ExprFactor <span style="color:#a6e22e">assign</span>(HashMap<span style="color:#f92672">&lt;</span>String, Factor<span style="color:#f92672">&gt;</span> assignment) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">define</span>.<span style="color:#a6e22e">get</span>(<span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">index</span>)
</span></span><span style="display:flex;"><span>        .<span style="color:#a6e22e">assign</span>(<span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">assignment</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 先应用this.assignment当前层的参数绑定</span>
</span></span><span style="display:flex;"><span>        .<span style="color:#a6e22e">assign</span>(assignment);
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 再应用外层传入的assignment参数，实现参数作用域的嵌套覆盖</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div></li>
<li>
<p><strong>递归展开过程</strong></p>
<pre tabindex="0"><code>// 高层调用 → 中间层展开 → 基础层解析
funcCall.assign(null)
→ funcCall.define.get(index).assign(assignment).assign(null)
→ ...
→ funcCall&#39;.define.get(index&#39;).assign(assignment&#39;).assign(assignment).assign(null)
→ ...
→ funcCall&#39;&#39;.define.get(index&#39;&#39;).assign(assignment&#39;&#39;).assign(assignment&#39;).assign(assignment).assign(null)
→ ...
→ funcCall.define.get(0 | 1).assign... // 初始定义表达式
</code></pre></li>
</ol>
<h3 id="类方法实现">类方法实现</h3>
<p>经<code>assign</code>方法，<code>BaseVar.assign(assignment)</code>返回<code>Factor</code>，<code>PowerFunc.assign(assignment)</code>返回<code>ExprFactor</code>，<code>FuncCall</code>递归调用<code>(Expr)define.get(this.index).assign(this.assignment).assign(assignment)</code>返回<code>ExprFactor</code>，其他语素的<code>assign</code>方法返回同类对象。最终递归返回不含<code>FuncCall</code>的纯<code>Expr</code>，即可施之<code>toPoly</code>方法。</p>
<table>
  <thead>
      <tr>
          <th>类名</th>
          <th>assign方法行为</th>
          <th>返回类型</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>BaseVar</td>
          <td>直接返回对应的含相对实参的Factor</td>
          <td>Factor</td>
      </tr>
      <tr>
          <td>PowerFunc</td>
          <td>返回参数赋值的ExprFactor</td>
          <td>ExprFactor</td>
      </tr>
      <tr>
          <td>FuncCall</td>
          <td>递归调用下层定义进行参数替换</td>
          <td>ExprFactor</td>
      </tr>
      <tr>
          <td>其他因子</td>
          <td>返回由自身组成语素.assign()构造的同类对象</td>
          <td>同类对象</td>
      </tr>
  </tbody>
</table>
<h2 id="处理终点">处理终点</h2>
<p>当递归到<code>define.get(0 | 1)</code>时：</p>
<ol>
<li>不再包含FuncCall对象，函数调用结构完全消解</li>
<li>所有形参已被实际参数替换</li>
<li>表达式完全展开为基本元素</li>
<li>可安全调用<code>toPoly()</code>进行多项式转换</li>
<li>可进行最终化简<code>simplify()</code></li>
</ol>
]]></content:encoded>
    </item>
  </channel>
</rss>
