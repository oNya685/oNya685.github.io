<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>oNya&#39;s Blog</title>
    <link>https://oNya685.github.io/</link>
    <description>Recent content on oNya&#39;s Blog</description>
    <generator>Hugo -- 0.147.0</generator>
    <language>zh-cn</language>
    <lastBuildDate>Sun, 04 May 2025 14:49:00 +0800</lastBuildDate>
    <atom:link href="https://oNya685.github.io/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>[BUAA-OS] 理论作业 5</title>
      <link>https://oNya685.github.io/posts/buaa/os/homework-5/</link>
      <pubDate>Sun, 04 May 2025 14:49:00 +0800</pubDate>
      <guid>https://oNya685.github.io/posts/buaa/os/homework-5/</guid>
      <description>&lt;p&gt;&lt;strong&gt;&lt;a href=&#34;%e4%bd%9c%e4%b8%9a5.pdf&#34; target=&#34;_blank&#34;&gt;点此查看作业源文件&lt;/a&gt;
&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&#34;1-有五个进程p1p2p3p4p5它们同时依次进入就绪队列它们的优先数和需要的处理器时间如下表&#34;&gt;1. 有五个进程P1、P2、P3、P4、P5，它们同时依次进入就绪队列，它们的优先数和需要的处理器时间如下表&lt;/h1&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th style=&#34;text-align: center&#34;&gt;进程&lt;/th&gt;
          &lt;th style=&#34;text-align: center&#34;&gt;处理器时间&lt;/th&gt;
          &lt;th style=&#34;text-align: center&#34;&gt;优先级&lt;!-- raw HTML omitted --&gt;（数小优先级高）&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;P1&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;$10$&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;$3$&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;P2&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;$1$&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;$1$&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;P3&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;$2$&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;$3$&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;P4&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;$1$&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;$4$&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;P5&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;$5$&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;$2$&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;忽略进行调度等所花费的时间，回答下列问题：&lt;/p&gt;</description>
      <content:encoded><![CDATA[<p><strong><a href="%e4%bd%9c%e4%b8%9a5.pdf" target="_blank">点此查看作业源文件</a>
</strong></p>
<h1 id="1-有五个进程p1p2p3p4p5它们同时依次进入就绪队列它们的优先数和需要的处理器时间如下表">1. 有五个进程P1、P2、P3、P4、P5，它们同时依次进入就绪队列，它们的优先数和需要的处理器时间如下表</h1>
<table>
  <thead>
      <tr>
          <th style="text-align: center">进程</th>
          <th style="text-align: center">处理器时间</th>
          <th style="text-align: center">优先级<!-- raw HTML omitted -->（数小优先级高）</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td style="text-align: center">P1</td>
          <td style="text-align: center">$10$</td>
          <td style="text-align: center">$3$</td>
      </tr>
      <tr>
          <td style="text-align: center">P2</td>
          <td style="text-align: center">$1$</td>
          <td style="text-align: center">$1$</td>
      </tr>
      <tr>
          <td style="text-align: center">P3</td>
          <td style="text-align: center">$2$</td>
          <td style="text-align: center">$3$</td>
      </tr>
      <tr>
          <td style="text-align: center">P4</td>
          <td style="text-align: center">$1$</td>
          <td style="text-align: center">$4$</td>
      </tr>
      <tr>
          <td style="text-align: center">P5</td>
          <td style="text-align: center">$5$</td>
          <td style="text-align: center">$2$</td>
      </tr>
  </tbody>
</table>
<p>忽略进行调度等所花费的时间，回答下列问题：</p>
<h2 id="1-写出采用先来先服务短作业进程优先非抢占式的优先数和轮转法等调度算法进程执行的次序其中轮转法的时间片为2">(1) 写出采用“先来先服务”、“短作业（进程）优先”、“非抢占式的优先数”和“轮转法”等调度算法，进程执行的次序。（其中轮转法的时间片为2）</h2>
<table>
  <thead>
      <tr>
          <th style="text-align: center">调度算法</th>
          <th style="text-align: center"></th>
          <th style="text-align: center"></th>
          <th style="text-align: center"></th>
          <th style="text-align: center"></th>
          <th style="text-align: center"></th>
          <th style="text-align: center"></th>
          <th style="text-align: center"></th>
          <th style="text-align: center"></th>
          <th style="text-align: center"></th>
          <th style="text-align: center"></th>
          <th style="text-align: center"></th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td style="text-align: center">先来先服务</td>
          <td style="text-align: center">P1</td>
          <td style="text-align: center">P2</td>
          <td style="text-align: center">P3</td>
          <td style="text-align: center">P4</td>
          <td style="text-align: center">P5</td>
          <td style="text-align: center"></td>
          <td style="text-align: center"></td>
          <td style="text-align: center"></td>
          <td style="text-align: center"></td>
          <td style="text-align: center"></td>
          <td style="text-align: center"></td>
      </tr>
      <tr>
          <td style="text-align: center">短作业（进程）优先</td>
          <td style="text-align: center">P2</td>
          <td style="text-align: center">P4</td>
          <td style="text-align: center">P3</td>
          <td style="text-align: center">P5</td>
          <td style="text-align: center">P1</td>
          <td style="text-align: center"></td>
          <td style="text-align: center"></td>
          <td style="text-align: center"></td>
          <td style="text-align: center"></td>
          <td style="text-align: center"></td>
          <td style="text-align: center"></td>
      </tr>
      <tr>
          <td style="text-align: center">非抢占式的优先数</td>
          <td style="text-align: center">P2</td>
          <td style="text-align: center">P5</td>
          <td style="text-align: center">P1</td>
          <td style="text-align: center">P3</td>
          <td style="text-align: center">P4</td>
          <td style="text-align: center"></td>
          <td style="text-align: center"></td>
          <td style="text-align: center"></td>
          <td style="text-align: center"></td>
          <td style="text-align: center"></td>
          <td style="text-align: center"></td>
      </tr>
      <tr>
          <td style="text-align: center">轮转法</td>
          <td style="text-align: center">P1: 2</td>
          <td style="text-align: center">P2: 3</td>
          <td style="text-align: center">P3: 5</td>
          <td style="text-align: center">P4: 6</td>
          <td style="text-align: center">P5: 8</td>
          <td style="text-align: center">P1: 10</td>
          <td style="text-align: center">P5: 12</td>
          <td style="text-align: center">P1: 14</td>
          <td style="text-align: center">P5: 15</td>
          <td style="text-align: center">P1: 17</td>
          <td style="text-align: center">P1: 19</td>
      </tr>
  </tbody>
</table>
<h2 id="2-分别计算上述算法中各进程的周转时间和等待时间以及平均周转时间">(2) 分别计算上述算法中各进程的周转时间和等待时间，以及平均周转时间。</h2>
<table>
  <thead>
      <tr>
          <th style="text-align: center">调度算法</th>
          <th style="text-align: center">P1等待时间</th>
          <th style="text-align: center">P2等待时间</th>
          <th style="text-align: center">P3等待时间</th>
          <th style="text-align: center">P4等待时间</th>
          <th style="text-align: center">P5等待时间</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td style="text-align: center">先来先服务</td>
          <td style="text-align: center">$0$</td>
          <td style="text-align: center">$10$</td>
          <td style="text-align: center">$11$</td>
          <td style="text-align: center">$13$</td>
          <td style="text-align: center">$14$</td>
      </tr>
      <tr>
          <td style="text-align: center">短作业（进程）优先</td>
          <td style="text-align: center">$9$</td>
          <td style="text-align: center">$0$</td>
          <td style="text-align: center">$2$</td>
          <td style="text-align: center">$1$</td>
          <td style="text-align: center">$4$</td>
      </tr>
      <tr>
          <td style="text-align: center">非抢占式的优先数</td>
          <td style="text-align: center">$6$</td>
          <td style="text-align: center">$0$</td>
          <td style="text-align: center">$16$</td>
          <td style="text-align: center">$18$</td>
          <td style="text-align: center">$1$</td>
      </tr>
      <tr>
          <td style="text-align: center">轮转法</td>
          <td style="text-align: center">$0$</td>
          <td style="text-align: center">$2$</td>
          <td style="text-align: center">$3$</td>
          <td style="text-align: center">$5$</td>
          <td style="text-align: center">$6$</td>
      </tr>
  </tbody>
</table>
<table>
  <thead>
      <tr>
          <th style="text-align: center">调度算法</th>
          <th style="text-align: center">P1周转时间</th>
          <th style="text-align: center">P2周转时间</th>
          <th style="text-align: center">P3周转时间</th>
          <th style="text-align: center">P4周转时间</th>
          <th style="text-align: center">P5周转时间</th>
          <th style="text-align: center">平均周转时间$T$</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td style="text-align: center">先来先服务</td>
          <td style="text-align: center">$10$</td>
          <td style="text-align: center">$11$</td>
          <td style="text-align: center">$13$</td>
          <td style="text-align: center">$14$</td>
          <td style="text-align: center">$19$</td>
          <td style="text-align: center">$13.4$</td>
      </tr>
      <tr>
          <td style="text-align: center">短作业（进程）优先</td>
          <td style="text-align: center">$19$</td>
          <td style="text-align: center">$1$</td>
          <td style="text-align: center">$4$</td>
          <td style="text-align: center">$2$</td>
          <td style="text-align: center">$9$</td>
          <td style="text-align: center">$7$</td>
      </tr>
      <tr>
          <td style="text-align: center">非抢占式的优先数</td>
          <td style="text-align: center">$16$</td>
          <td style="text-align: center">$1$</td>
          <td style="text-align: center">$18$</td>
          <td style="text-align: center">$19$</td>
          <td style="text-align: center">$6$</td>
          <td style="text-align: center">$12$</td>
      </tr>
      <tr>
          <td style="text-align: center">轮转法</td>
          <td style="text-align: center">$19$</td>
          <td style="text-align: center">$3$</td>
          <td style="text-align: center">$5$</td>
          <td style="text-align: center">$6$</td>
          <td style="text-align: center">$15$</td>
          <td style="text-align: center">$9.6$</td>
      </tr>
  </tbody>
</table>
<h1 id="2-假设某系统使用时间片轮转调度算法进行cpu调度时间片大小为5ms系统共10个进程初始时均处于就绪队列执行结束前仅处于执行态或就绪态若队尾的进程p所需的cpu时间最短时间为25ms不考虑系统开销则进程p的周转时间为">2. 假设某系统使用时间片轮转调度算法进行CPU调度，时间片大小为5ms，系统共10个进程，初始时均处于就绪队列，执行结束前仅处于执行态或就绪态。若队尾的进程P所需的CPU时间最短，时间为25ms，不考虑系统开销，则进程P的周转时间为？</h1>
<p>0-45ms在依次执行其他进程，45-50ms首次执行进程P，P剩余所需CPU时间20ms。</p>
<p>由于进程P所需的CPU时间最短，所以每周期执行进程P前都需要45ms依次执行其他进程，50ms为一周期。</p>
<p>以此类推，第195-200ms第四次执行进程P，P剩余所需CPU时间5ms。第200-245ms依次执行其他进程，第245-250ms第五次执行进程P，250ms时进程P执行结束。</p>
<p>故进程P的周转时间为250ms。</p>
<h1 id="3-某个进程调度程序采用基于优先数priority的调度策略即选择优先数最小的进程运行运行创建时由用户指定一个nice作为静态优先数为了动态调整优先数引入运行时间cputime和等待时间waittime初值为0进程处于执行态时cputime定时加1且waittime置0进程处于就绪态时cputime置0waittime定时加1">3. 某个进程调度程序采用基于优先数(priority)的调度策略，即选择优先数最小的进程运行，运行创建时由用户指定一个nice作为静态优先数。为了动态调整优先数，引入运行时间cpuTime和等待时间waitTime，初值为0。进程处于执行态时，cpuTime定时加1，且waitTime置0；进程处于就绪态时，cpuTime置0，waitTime定时加1。</h1>
<h2 id="1-若调度程序只将nice的值作为进程优先级即priority--nice则可能出现饥饿现象为什么">(1) 若调度程序只将nice的值作为进程优先级，即priority = nice，则可能出现饥饿现象。为什么？</h2>
<p>当调度程序仅将用户指定的静态优先数 <code>nice</code> 作为进程优先级时，静态优先级无法动态调整。</p>
<p>若系统中持续有低 <code>nice</code> 值（高优先级）的进程到达，高 <code>nice</code> 值（低优先级）的进程可能因无法获得 CPU 时间而长期处于就绪队列，导致饥饿。低 <code>nice</code> 值的进程可能因优先级高而持续占用 CPU，即使其实际运行时间较长或资源需求不合理，也会挤压其他进程的执行机会。</p>
<h2 id="2-使用nicecputimewaittime设计一种动态优先数计算方法以避免产生饥饿现象并说明waittime的作用">(2) 使用nice，cpuTime，waitTime设计一种动态优先数计算方法，以避免产生饥饿现象，并说明waitTime的作用</h2>
<p>设计动态优先数公式：</p>
$$\text{priority} = \text{nice} + k_1 \times \text{cpuTime} - k_2 \times \text{waitTime}, k_1 > 0, k_2 > 0$$<p>• <code>k1 &gt; 0</code>：惩罚 CPU 占用时间长的进程（防止 CPU 霸占）。</p>
<p>• <code>k2 &gt; 0</code>：补偿等待时间长的进程（避免饥饿）。</p>
<p>• <code>cpuTime</code> 的作用：进程运行时，<code>cpuTime</code> 定时增加。若进程长期占用 CPU，其优先级会因 <code>cpuTime</code> 增大而降低，从而让出 CPU 给其他进程。</p>
<p>• <code>waitTime</code> 的作用：进程就绪时，<code>waitTime</code> 定时增加。其值越大，优先级提升越多，确保长时间等待的进程能被及时调度，通过补偿等待时间，确保低优先级进程最终能被调度，避免饥饿。</p>
<h1 id="4-死锁">4. 死锁</h1>
<h2 id="1-有m个同类资源供n个进程共享若每个进程最多申请k个资源k1采用银行家算法分配资源为保证系统不发生死锁则各进程的最大需求量之和为并说明理由">(1) 有m个同类资源供n个进程共享，若每个进程最多申请k个资源（k&gt;=1），采用银行家算法分配资源，为保证系统不发生死锁，则各进程的最大需求量之和为？并说明理由</h2>
<p>最坏情况下，每个进程均已分配$k-1$个资源，此时要保证存在至少一个安全序列。则剩余资源$m-n\times (k-1) \geq 1$，即需求量之和$nk\leq m+n-1$。</p>
<p>因此，各进程的最大需求量之和为$m+n-1$。</p>
<h2 id="2-有8台打印机由k个进程竞争使用每个进程最多使用3台打印机求k的最大值使系统可能发生死锁">(2) 有8台打印机，由K个进程竞争使用，每个进程最多使用3台打印机。求K的最大值，使系统可能发生死锁。</h2>
<p>为使系统发生死锁，$3\times K \geq 8 + K$，即$K \geq 4$。所以：</p>
<p>使系统不发生死锁的K的最大值为3；</p>
<p>使系统可能发生死锁的K的最小值为4。</p>
<h2 id="3-某系统有n台互斥使用的同类设备三个并发进程分别需要345台设备求n的最小值使系统不发生死锁">(3) 某系统有n台互斥使用的同类设备，三个并发进程分别需要3，4，5台设备。求n的最小值，使系统不发生死锁。</h2>
<p>假设给三个并发进程已经分别发配了2，3，4台设备，则剩余资源$n-2-3-4\geq 1$，即$n \geq 10$。</p>
<p>故使系统不发生死锁的最小值为10。</p>
<h1 id="5-什么是进程之间的同步关系什么是进程之间的互斥关系">5. 什么是进程之间的同步关系？什么是进程之间的互斥关系？</h1>
<ul>
<li>互斥：某一资源同时只允许一个访问者对其进行访问，具有唯一性和排它性</li>
<li>同步：是指在互斥的基础上（大多数情况），通过其它机制实现访问者对资源的有序访问</li>
</ul>
<h1 id="6-假设具有5个进程的进程集合p-p0p1p2p3p4系统中有三类资源abc假设在某时刻有如下状态">6. 假设具有5个进程的进程集合P= {P0,P1,P2,P3,P4}，系统中有三类资源A,B,C，假设在某时刻有如下状态：</h1>
<table>
  <thead>
      <tr>
          <th style="text-align: center">进程</th>
          <th style="text-align: center">Allocation</th>
          <th style="text-align: center">Max</th>
          <th style="text-align: center">Available</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td style="text-align: center"></td>
          <td style="text-align: center">$\left(\begin{matrix} A &amp;&amp; B &amp;&amp; C \end{matrix}\right)$</td>
          <td style="text-align: center">$\left(\begin{matrix} A &amp;&amp; B &amp;&amp; C \end{matrix}\right)$</td>
          <td style="text-align: center">$\left(\begin{matrix} A &amp;&amp; B &amp;&amp; C \end{matrix}\right)$</td>
      </tr>
      <tr>
          <td style="text-align: center">P0</td>
          <td style="text-align: center">$\left(\begin{matrix} 0 &amp;&amp; 0 &amp;&amp; 3 \end{matrix}\right)$</td>
          <td style="text-align: center">$\left(\begin{matrix} 0 &amp;&amp; 0 &amp;&amp; 4 \end{matrix}\right)$</td>
          <td style="text-align: center">$\left(\begin{matrix} 1 &amp;&amp; 4 &amp;&amp; 0 \end{matrix}\right)$</td>
      </tr>
      <tr>
          <td style="text-align: center">P1</td>
          <td style="text-align: center">$\left(\begin{matrix} 1 &amp;&amp; 0 &amp;&amp; 0 \end{matrix}\right)$</td>
          <td style="text-align: center">$\left(\begin{matrix} 1 &amp;&amp; 7 &amp;&amp; 5 \end{matrix}\right)$</td>
          <td style="text-align: center"></td>
      </tr>
      <tr>
          <td style="text-align: center">P2</td>
          <td style="text-align: center">$\left(\begin{matrix} 1 &amp;&amp; 3 &amp;&amp; 5 \end{matrix}\right)$</td>
          <td style="text-align: center">$\left(\begin{matrix} 2 &amp;&amp; 3 &amp;&amp; 5 \end{matrix}\right)$</td>
          <td style="text-align: center"></td>
      </tr>
      <tr>
          <td style="text-align: center">P3</td>
          <td style="text-align: center">$\left(\begin{matrix} 0 &amp;&amp; 0 &amp;&amp; 2 \end{matrix}\right)$</td>
          <td style="text-align: center">$\left(\begin{matrix} 0 &amp;&amp; 6 &amp;&amp; 4 \end{matrix}\right)$</td>
          <td style="text-align: center"></td>
      </tr>
      <tr>
          <td style="text-align: center">P4</td>
          <td style="text-align: center">$\left(\begin{matrix} 0 &amp;&amp; 0 &amp;&amp; 1 \end{matrix}\right)$</td>
          <td style="text-align: center">$\left(\begin{matrix} 0 &amp;&amp; 6 &amp;&amp; 5 \end{matrix}\right)$</td>
          <td style="text-align: center"></td>
      </tr>
  </tbody>
</table>
<h2 id="1-根据上表内容当前系统是否处于安全状态">(1) 根据上表内容，当前系统是否处于安全状态？</h2>
<table>
  <thead>
      <tr>
          <th style="text-align: center">Work</th>
          <th style="text-align: center">进程</th>
          <th style="text-align: center">Need</th>
          <th style="text-align: center">Allocation</th>
          <th style="text-align: center">Work+Allocation</th>
          <th>Finish</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td style="text-align: center">$\left(\begin{matrix} A &amp;&amp; B &amp;&amp; C \end{matrix}\right)$</td>
          <td style="text-align: center"></td>
          <td style="text-align: center">$\left(\begin{matrix} A &amp;&amp; B &amp;&amp; C \end{matrix}\right)$</td>
          <td style="text-align: center">$\left(\begin{matrix} A &amp;&amp; B &amp;&amp; C \end{matrix}\right)$</td>
          <td style="text-align: center">$\left(\begin{matrix} A &amp;&amp; B &amp;&amp; C \end{matrix}\right)$</td>
          <td></td>
      </tr>
      <tr>
          <td style="text-align: center">$\left(\begin{matrix} 1 &amp;&amp; 4 &amp;&amp; 0 \end{matrix}\right)$</td>
          <td style="text-align: center">P2</td>
          <td style="text-align: center">$\left(\begin{matrix} 1 &amp;&amp; 0 &amp;&amp; 0 \end{matrix}\right)$</td>
          <td style="text-align: center">$\left(\begin{matrix} 1 &amp;&amp; 3 &amp;&amp; 5 \end{matrix}\right)$</td>
          <td style="text-align: center">$\left(\begin{matrix} 2 &amp;&amp; 7 &amp;&amp; 5 \end{matrix}\right)$</td>
          <td><code>true</code></td>
      </tr>
      <tr>
          <td style="text-align: center">$\left(\begin{matrix} 2 &amp;&amp; 7 &amp;&amp; 5 \end{matrix}\right)$</td>
          <td style="text-align: center">P0</td>
          <td style="text-align: center">$\left(\begin{matrix} 0 &amp;&amp; 0 &amp;&amp; 1 \end{matrix}\right)$</td>
          <td style="text-align: center">$\left(\begin{matrix} 0 &amp;&amp; 0 &amp;&amp; 3 \end{matrix}\right)$</td>
          <td style="text-align: center">$\left(\begin{matrix} 2 &amp;&amp; 7 &amp;&amp; 8 \end{matrix}\right)$</td>
          <td><code>true</code></td>
      </tr>
      <tr>
          <td style="text-align: center">$\left(\begin{matrix} 2 &amp;&amp; 7 &amp;&amp; 8 \end{matrix}\right)$</td>
          <td style="text-align: center">P1</td>
          <td style="text-align: center">$\left(\begin{matrix} 0 &amp;&amp; 7 &amp;&amp; 5 \end{matrix}\right)$</td>
          <td style="text-align: center">$\left(\begin{matrix} 1 &amp;&amp; 0 &amp;&amp; 0 \end{matrix}\right)$</td>
          <td style="text-align: center">$\left(\begin{matrix} 3 &amp;&amp; 7 &amp;&amp; 8 \end{matrix}\right)$</td>
          <td><code>true</code></td>
      </tr>
      <tr>
          <td style="text-align: center">$\left(\begin{matrix} 3 &amp;&amp; 7 &amp;&amp; 8 \end{matrix}\right)$</td>
          <td style="text-align: center">P3</td>
          <td style="text-align: center">$\left(\begin{matrix} 0 &amp;&amp; 6 &amp;&amp; 2 \end{matrix}\right)$</td>
          <td style="text-align: center">$\left(\begin{matrix} 0 &amp;&amp; 0 &amp;&amp; 2 \end{matrix}\right)$</td>
          <td style="text-align: center">$\left(\begin{matrix} 3 &amp;&amp; 7 &amp;&amp; 10 \end{matrix}\right)$</td>
          <td><code>true</code></td>
      </tr>
      <tr>
          <td style="text-align: center">$\left(\begin{matrix} 3 &amp;&amp; 7 &amp;&amp; 10 \end{matrix}\right)$</td>
          <td style="text-align: center">P4</td>
          <td style="text-align: center">$\left(\begin{matrix} 0 &amp;&amp; 6 &amp;&amp; 4 \end{matrix}\right)$</td>
          <td style="text-align: center">$\left(\begin{matrix} 0 &amp;&amp; 0 &amp;&amp; 1 \end{matrix}\right)$</td>
          <td style="text-align: center">$\left(\begin{matrix} 3 &amp;&amp; 7 &amp;&amp; 11 \end{matrix}\right)$</td>
          <td><code>true</code></td>
      </tr>
  </tbody>
</table>
<p>当前系统处于安全状态，存在安全序列：$\text{P2} \to \text{P0} \to \text{P1} \to \text{P3} \to \text{P4}$</p>
<h2 id="2-若系统中的可利用资源-available-为062系统是否安全若系统处在安全状态请给出安全序列若系统处在非安全状态简要说明原因">(2) 若系统中的可利用资源 Available 为（0,6,2），系统是否安全？若系统处在安全状态，请给出安全序列；若系统处在非安全状态，简要说明原因。</h2>
<table>
  <thead>
      <tr>
          <th style="text-align: center">Work</th>
          <th style="text-align: center">进程</th>
          <th style="text-align: center">Need</th>
          <th style="text-align: center">Allocation</th>
          <th style="text-align: center">Work+Allocation</th>
          <th>Finish</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td style="text-align: center">$\left(\begin{matrix} A &amp;&amp; B &amp;&amp; C \end{matrix}\right)$</td>
          <td style="text-align: center"></td>
          <td style="text-align: center">$\left(\begin{matrix} A &amp;&amp; B &amp;&amp; C \end{matrix}\right)$</td>
          <td style="text-align: center">$\left(\begin{matrix} A &amp;&amp; B &amp;&amp; C \end{matrix}\right)$</td>
          <td style="text-align: center">$\left(\begin{matrix} A &amp;&amp; B &amp;&amp; C \end{matrix}\right)$</td>
          <td></td>
      </tr>
      <tr>
          <td style="text-align: center">$\left(\begin{matrix} 0 &amp;&amp; 6 &amp;&amp; 2 \end{matrix}\right)$</td>
          <td style="text-align: center">P0</td>
          <td style="text-align: center">$\left(\begin{matrix} 0 &amp;&amp; 0 &amp;&amp; 1 \end{matrix}\right)$</td>
          <td style="text-align: center">$\left(\begin{matrix} 0 &amp;&amp; 0 &amp;&amp; 3 \end{matrix}\right)$</td>
          <td style="text-align: center">$\left(\begin{matrix} 0 &amp;&amp; 6 &amp;&amp; 5 \end{matrix}\right)$</td>
          <td><code>true</code></td>
      </tr>
      <tr>
          <td style="text-align: center">$\left(\begin{matrix} 0 &amp;&amp; 6 &amp;&amp; 5 \end{matrix}\right)$</td>
          <td style="text-align: center">P3</td>
          <td style="text-align: center">$\left(\begin{matrix} 0 &amp;&amp; 6 &amp;&amp; 2 \end{matrix}\right)$</td>
          <td style="text-align: center">$\left(\begin{matrix} 0 &amp;&amp; 0 &amp;&amp; 2 \end{matrix}\right)$</td>
          <td style="text-align: center">$\left(\begin{matrix} 0 &amp;&amp; 6 &amp;&amp; 7 \end{matrix}\right)$</td>
          <td><code>true</code></td>
      </tr>
      <tr>
          <td style="text-align: center">$\left(\begin{matrix} 0 &amp;&amp; 6 &amp;&amp; 7 \end{matrix}\right)$</td>
          <td style="text-align: center">P4</td>
          <td style="text-align: center">$\left(\begin{matrix} 0 &amp;&amp; 6 &amp;&amp; 4 \end{matrix}\right)$</td>
          <td style="text-align: center">$\left(\begin{matrix} 0 &amp;&amp; 0 &amp;&amp; 1 \end{matrix}\right)$</td>
          <td style="text-align: center">$\left(\begin{matrix} 0 &amp;&amp; 6 &amp;&amp; 8 \end{matrix}\right)$</td>
          <td><code>true</code></td>
      </tr>
      <tr>
          <td style="text-align: center">$\left(\begin{matrix} 0 &amp;&amp; 6 &amp;&amp; 8 \end{matrix}\right)$</td>
          <td style="text-align: center">P1</td>
          <td style="text-align: center">$\left(\begin{matrix} 0 &amp;&amp; 7 &amp;&amp; 5 \end{matrix}\right)$</td>
          <td style="text-align: center">$\left(\begin{matrix} 1 &amp;&amp; 0 &amp;&amp; 0 \end{matrix}\right)$</td>
          <td style="text-align: center">——</td>
          <td><code>false</code></td>
      </tr>
      <tr>
          <td style="text-align: center">$\left(\begin{matrix} 0 &amp;&amp; 6 &amp;&amp; 8 \end{matrix}\right)$</td>
          <td style="text-align: center">P2</td>
          <td style="text-align: center">$\left(\begin{matrix} 1 &amp;&amp; 0 &amp;&amp; 0 \end{matrix}\right)$</td>
          <td style="text-align: center">$\left(\begin{matrix} 1 &amp;&amp; 3 &amp;&amp; 5 \end{matrix}\right)$</td>
          <td style="text-align: center">——</td>
          <td><code>false</code></td>
      </tr>
  </tbody>
</table>
<p>因此，系统处于非安全状态。</p>
<ol>
<li>部分进程可执行：
<ul>
<li>初始可用资源 <code>(0,6,2)</code> 可满足 P0（Need <code>(0,0,1)</code>），执行后释放资源，可用资源更新为 <code>(0,6,5)</code>。</li>
<li>资源 <code>(0,6,5)</code> 可满足 P3（Need <code>(0,6,2)</code>），执行后可用资源更新为 <code>(0,6,7)</code>。</li>
<li>资源 <code>(0,6,7)</code> 可满足 P4（Need <code>(0,6,4)</code>），执行后可用资源更新为 <code>(0,6,8)</code>。</li>
</ul>
</li>
<li>剩余进程无法执行：
<ul>
<li>P1 需要 <code>B=7</code>，但当前可用 <code>B=6</code>，资源不足。</li>
<li>P2 需要 <code>A=1</code>，但当前可用 <code>A=0</code>，资源不足。</li>
</ul>
</li>
<li>无法形成完整安全序列：
<ul>
<li><code>P0 → P3 → P4</code> 可执行，但剩余进程 P1 和 P2 的资源需求无法满足，无法形成完整安全序列。</li>
</ul>
</li>
</ol>
]]></content:encoded>
    </item>
    <item>
      <title>[BUAA-ML] 第一次实验报告</title>
      <link>https://oNya685.github.io/posts/buaa/ml/report-1/</link>
      <pubDate>Sun, 27 Apr 2025 21:42:13 +0800</pubDate>
      <guid>https://oNya685.github.io/posts/buaa/ml/report-1/</guid>
      <description>Linear Regression</description>
      <content:encoded><![CDATA[<p>机器学习实验报告</p>
<hr>
<p>一、数据预处理：归一化与标准化处理<br>
（一）实验中的预处理方法</p>
<ol>
<li>
<p>是否进行归一化/标准化<br>
实验中使用了 标准化（Standardization） 处理，具体代码为：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>scaler <span style="color:#f92672">=</span> StandardScaler()
</span></span><span style="display:flex;"><span>X_train <span style="color:#f92672">=</span> scaler<span style="color:#f92672">.</span>fit_transform(X_train)
</span></span><span style="display:flex;"><span>X_test <span style="color:#f92672">=</span> scaler<span style="color:#f92672">.</span>transform(X_test)
</span></span></code></pre></div><p>• <code>fit_transform</code> 对训练集计算均值和标准差并应用转换。</p>
<p>• <code>transform</code> 对测试集直接使用训练集的参数进行转换。</p>
</li>
<li>
<p>归一化与标准化的区别<br>
• 归一化（Normalization）：</p>
<p>将数据缩放到固定范围（如[0,1]），公式为：<br>
</p>
\[
     x_{\text{norm}} = \frac{x - x_{\min}}{x_{\max} - x_{\min}}
     \]<p><br>
• 标准化（Standardization）：</p>
<p>将数据调整为均值为0、标准差为1的分布，公式为：<br>
</p>
\[
     x_{\text{std}} = \frac{x - \mu}{\sigma}
     \]</li>
<li>
<p>线性回归对特征尺度敏感的原因<br>
• 解析解稳定性：参数解析解 \( w = (X^T X)^{-1} X^T y \) 中，若特征尺度差异大，矩阵 \( X^T X \) 的条件数增大，导致求逆不稳定。</p>
<p>• 梯度下降效率：不同尺度的特征需不同的学习率，尺度差异大会导致收敛速度慢。</p>
</li>
</ol>
<hr>
<p>二、线性回归目标函数与参数求解<br>
（一）目标函数与解析解推导</p>
<ol>
<li>
<p>目标函数：<br>
</p>
\[
   J(w) = \sum_{i=1}^N (w^T x_i - y_i)^2
   \]</li>
<li>
<p>解析解推导：<br>
• 矩阵形式：\( J(w) = (Xw - y)^T (Xw - y) \)</p>
<p>• 对 \( w \) 求导并令导数为零：</p>
\[
     \frac{\partial J(w)}{\partial w} = 2X^T (Xw - y) = 0
     \]<p><br>
• 解得：</p>
\[
     w = (X^T X)^{-1} X^T y
     \]</li>
</ol>
<p>（二）标准方程组法与梯度下降法的对比</p>
<ol>
<li>
<p>优势：<br>
• 精确解：直接得到全局最优解，无需迭代调参。</p>
<p>• 效率高：当特征数 \( d \) 较小时（实验数据集特征数 \( d=8 \)），计算复杂度 \( O(d^3) \) 可接受。</p>
</li>
<li>
<p>劣势：<br>
• 计算复杂度：若 \( d > 10^4 \)，矩阵求逆计算不可行。</p>
<p>• 内存限制：存储 \( X^T X \) 需要 \( O(d^2) \) 内存。</p>
</li>
</ol>
<hr>
<p>三、模型评估指标分析<br>
（一）指标定义与意义</p>
<ol>
<li>
<p>均方误差（MSE）：<br>
</p>
\[
   \text{MSE} = \frac{1}{N} \sum_{i=1}^N (y_i - \hat{y}_i)^2
   \]<p><br>
• 反映预测值与真实值的平均平方误差，值越小越好。</p>
</li>
<li>
<p>均方根误差（RMSE）：<br>
</p>
\[
   \text{RMSE} = \sqrt{\text{MSE}}
   \]<p><br>
• 与目标变量单位一致，更易解释误差的实际影响。</p>
</li>
<li>
<p>决定系数（R²）：<br>
</p>
\[
   R^2 = 1 - \frac{\sum_{i=1}^N (y_i - \hat{y}_i)^2}{\sum_{i=1}^N (y_i - \bar{y})^2}
   \]<p><br>
• 表示模型解释的方差比例，范围 \( (-\infty, 1] \)，越接近1越好。</p>
</li>
</ol>
<p>（二）R²为负的原因<br>
• 模型性能极差：当 \( \sum (y_i - \hat{y}_i)^2 > \sum (y_i - \bar{y})^2 \)，即模型预测比直接取均值更差。</p>
<p>• 可能原因：</p>
<ol>
<li>数据存在严重噪声或非线性关系未被捕捉。</li>
<li>特征与目标变量无关，模型欠拟合。</li>
</ol>
<hr>
<p>四、非线性关系的拟合方法<br>
（一）问题分析<br>
直接使用线性回归无法捕捉特征与目标变量之间的非线性关系（如二次函数），导致预测性能下降。</p>
<p>（二）改进方法</p>
<ol>
<li>
<p>多项式特征扩展：<br>
• 添加特征的高次项（如 \( x^2, x^3 \)）或交互项（如 \( x_1 x_2 \)）。</p>
<p>• 代码示例：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>poly <span style="color:#f92672">=</span> PolynomialFeatures(degree<span style="color:#f92672">=</span><span style="color:#ae81ff">2</span>)
</span></span><span style="display:flex;"><span>X_poly <span style="color:#f92672">=</span> poly<span style="color:#f92672">.</span>fit_transform(X)
</span></span></code></pre></div></li>
<li>
<p>核方法（Kernel Trick）：<br>
• 将特征映射到高维空间，间接实现非线性拟合。</p>
</li>
<li>
<p>树模型（如决策树、随机森林）：<br>
• 直接处理非线性关系，但需牺牲模型可解释性。</p>
</li>
</ol>
<p>（三）实验中的应用建议<br>
• 在步骤二中引入 <code>PolynomialFeatures</code> 生成多项式特征，再使用线性回归拟合。</p>
<hr>
<p>结论<br>
实验通过标准化处理提升模型稳定性，利用线性回归解析解高效求解参数，并通过评估指标验证模型性能。针对非线性关系，可通过特征工程扩展模型表达能力。</p>
]]></content:encoded>
    </item>
    <item>
      <title>[BUAA-OS] Lab 3 实验报告</title>
      <link>https://oNya685.github.io/posts/buaa/os/lab-3-report/</link>
      <pubDate>Mon, 21 Apr 2025 09:26:00 +0800</pubDate>
      <guid>https://oNya685.github.io/posts/buaa/os/lab-3-report/</guid>
      <description>&lt;h1 id=&#34;一思考题&#34;&gt;一、思考题&lt;/h1&gt;
&lt;h2 id=&#34;thinking-31&#34;&gt;Thinking 3.1&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;请结合MOS中的页目录自映射应用解释代码中 &lt;code&gt;e-&amp;gt;env_pgdir[PDX(UVPT)] = PADDR(e-&amp;gt;env_pgdir) | PTE_V&lt;/code&gt; 的含义。&lt;/p&gt;&lt;/blockquote&gt;
&lt;hr&gt;
&lt;p&gt;&lt;code&gt;UVPT&lt;/code&gt;是用户页表的起始虚拟地址，所以&lt;code&gt;e-&amp;gt;env_pgdir[PDX(UVPT)]&lt;/code&gt;是当前进程的虚拟内存中，&lt;code&gt;UVPT&lt;/code&gt;地址所在的页目录项。而&lt;code&gt;e-&amp;gt;env_pgdir&lt;/code&gt;是当前进程页目录的虚拟地址，&lt;code&gt;PADDR(e-&amp;gt;env_pgdir)&lt;/code&gt;则是其物理地址，&lt;code&gt;| PTE_V&lt;/code&gt;是附上权限位。&lt;/p&gt;</description>
      <content:encoded><![CDATA[<h1 id="一思考题">一、思考题</h1>
<h2 id="thinking-31">Thinking 3.1</h2>
<blockquote>
<p>请结合MOS中的页目录自映射应用解释代码中 <code>e-&gt;env_pgdir[PDX(UVPT)] = PADDR(e-&gt;env_pgdir) | PTE_V</code> 的含义。</p></blockquote>
<hr>
<p><code>UVPT</code>是用户页表的起始虚拟地址，所以<code>e-&gt;env_pgdir[PDX(UVPT)]</code>是当前进程的虚拟内存中，<code>UVPT</code>地址所在的页目录项。而<code>e-&gt;env_pgdir</code>是当前进程页目录的虚拟地址，<code>PADDR(e-&gt;env_pgdir)</code>则是其物理地址，<code>| PTE_V</code>是附上权限位。</p>
<p>这句赋值语句的含义是，将访问<code>UVPT</code>时解析的页目录项映射到的页框号设置为页目录的物理地址所在页的页框号，并附上权限位。</p>
<h2 id="thinking-32">Thinking 3.2</h2>
<blockquote>
<p>elf_load_seg 以函数指针的形式，接受外部自定义的回调函数 map_page。请你找到与之相关的data这一参数在此处的来源，并思考它的作用。没有这个参数可不可以？为什么？</p></blockquote>
<hr>
<p>data 是传入<code>load_icode</code>函数的参数中的指向一个进程控制块的指针(<code>struct Env *</code>)。</p>
<p>不能没有这个参数。它的作用是传入<code>load_icode_mapper</code>类型转换为进程控制块指针，获取其<code>env_pgdir</code>并对其进程空间执行<code>page_insert</code>。缺少该参数则无法正常运行<code>load_icode_mapper</code>。</p>
<h2 id="thinking-33">Thinking 3.3</h2>
<blockquote>
<p>结合 elf_load_seg 的参数和实现，考虑该函数需要处理哪些页面加载的情况。</p></blockquote>
<hr>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">elf_load_seg</span>(Elf32_Phdr <span style="color:#f92672">*</span>ph, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>bin, <span style="color:#66d9ef">elf_mapper_t</span> map_page, <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>data) {
</span></span><span style="display:flex;"><span>	u_long va <span style="color:#f92672">=</span> ph<span style="color:#f92672">-&gt;</span>p_vaddr;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">size_t</span> bin_size <span style="color:#f92672">=</span> ph<span style="color:#f92672">-&gt;</span>p_filesz;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">size_t</span> sgsize <span style="color:#f92672">=</span> ph<span style="color:#f92672">-&gt;</span>p_memsz;
</span></span><span style="display:flex;"><span>	u_int perm <span style="color:#f92672">=</span> PTE_V;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (ph<span style="color:#f92672">-&gt;</span>p_flags <span style="color:#f92672">&amp;</span> PF_W) {
</span></span><span style="display:flex;"><span>		perm <span style="color:#f92672">|=</span> PTE_D;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> r;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">size_t</span> i;
</span></span><span style="display:flex;"><span>	u_long offset <span style="color:#f92672">=</span> va <span style="color:#f92672">-</span> <span style="color:#a6e22e">ROUNDDOWN</span>(va, PAGE_SIZE);
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 1.非页对齐的段起始地址  
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// 当段的虚拟地址va不是页对齐的（offset != 0），函数会先映射一个不完整的页，加载文件中对应的部分数据到该页的偏移位置。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> (offset <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> ((r <span style="color:#f92672">=</span> <span style="color:#a6e22e">map_page</span>(data, va, offset, perm, bin,
</span></span><span style="display:flex;"><span>				  <span style="color:#a6e22e">MIN</span>(bin_size, PAGE_SIZE <span style="color:#f92672">-</span> offset))) <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">return</span> r;
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 2.逐页加载文件数据
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// 对于段中包含文件数据的部分（bin_size范围内），函数分页处理，每页调用map_page，将文件数据加载到对应虚拟地址。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">/* Step 1: load all content of bin into memory. */</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> (i <span style="color:#f92672">=</span> offset <span style="color:#f92672">?</span> <span style="color:#a6e22e">MIN</span>(bin_size, PAGE_SIZE <span style="color:#f92672">-</span> offset) <span style="color:#f92672">:</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> bin_size; i <span style="color:#f92672">+=</span> PAGE_SIZE) {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> ((r <span style="color:#f92672">=</span> <span style="color:#a6e22e">map_page</span>(data, va <span style="color:#f92672">+</span> i, <span style="color:#ae81ff">0</span>, perm, bin <span style="color:#f92672">+</span> i, <span style="color:#a6e22e">MIN</span>(bin_size <span style="color:#f92672">-</span> i, PAGE_SIZE))) <span style="color:#f92672">!=</span>
</span></span><span style="display:flex;"><span>		    <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">return</span> r;
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 3.内存扩展分配与零初始化
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// 当段的内存大小sgsize大于文件大小bin_size时，函数继续分配页并初始化为零，确保段在内存中完整分配。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">/* Step 2: alloc pages to reach `sgsize` when `bin_size` &lt; `sgsize`. */</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">while</span> (i <span style="color:#f92672">&lt;</span> sgsize) {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> ((r <span style="color:#f92672">=</span> <span style="color:#a6e22e">map_page</span>(data, va <span style="color:#f92672">+</span> i, <span style="color:#ae81ff">0</span>, perm, NULL, <span style="color:#a6e22e">MIN</span>(sgsize <span style="color:#f92672">-</span> i, PAGE_SIZE))) <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">return</span> r;
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		i <span style="color:#f92672">+=</span> PAGE_SIZE;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="thinking-34">Thinking 3.4</h2>
<blockquote>
<p>思考上面这一段话，并根据自己在Lab2中的理解，回答：</p>
<ul>
<li>你认为这里的env_tf.cp0_epc存储的是物理地址还是虚拟地址?</li>
</ul></blockquote>
<hr>
<p><code>epc</code>存储的是<strong>虚拟地址</strong>。</p>
<h2 id="thinking-35">Thinking 3.5</h2>
<blockquote>
<p>试找出0、1、2、3号异常处理函数的具体实现位置。8号异常（系统调用）涉及的do_syscall()函数将在Lab4中实现。</p></blockquote>
<hr>
<p>0、1、2、3号异常处理函数的具体实现在<code>genex.S</code>中。</p>
<h2 id="thinking-36">Thinking 3.6</h2>
<blockquote>
<p>阅读entry.S、genex.S和env_asm.S这几个文件，并尝试说出时钟中断在哪些时候开启，在哪些时候关闭。</p></blockquote>
<hr>
<p>在<code>entry.S</code>中关闭时钟中断；
在<code>env_asm.S</code>中重置时钟；
在<code>genex.S</code>中开启时钟中断。</p>
<h2 id="thinking-37">Thinking 3.7</h2>
<blockquote>
<p>阅读相关代码，思考操作系统是怎么根据时钟中断切换进程的。</p></blockquote>
<hr>
<p>在进程运行时触发时钟中断，跳转<code>exc_gen_entry</code>，进入<code>hande_int</code>，从而通过<code>schedule</code>进行调度切换进程。</p>
<h1 id="二难点分析与实验体会">二、难点分析与实验体会</h1>
<h2 id="1-进程的内存空间分布">1. 进程的内存空间分布</h2>
<ul>
<li>进程的内存空间由页目录和页表进行管理，页目录项自映射使得页目录本身的物理地址能够被映射到虚拟地址空间（如<code>UVPT</code>）。这为内核提供了直接访问进程页目录的能力，方便进行页表操作和内存空间的管理。</li>
<li>进程的用户态页面（如代码段、数据段、堆栈等）通过页目录和页表进行映射，系统调用<code>elf_load_seg</code>等函数时，会根据 ELF 文件的程序头部信息，将文件中的代码和数据段加载到相应的虚拟地址，并设置正确的页权限。</li>
</ul>
<h2 id="2-中断的处理流程">2. 中断的处理流程</h2>
<ul>
<li>中断处理从硬件触发开始，CPU在检测到中断信号后，会暂停当前进程的执行，保存当前的执行上下文（如<code>cp0_epc</code>寄存器保存中断发生时的指令指针），并将控制权转移到中断处理程序。</li>
<li>时钟中断通过<code>genex.S</code>中的异常处理入口<code>exc_gen_entry</code>进行处理。内核会根据中断类型调用相应的处理函数，如时钟中断主要用于进程调度，通过调用<code>schedule</code>函数实现进程的切换。</li>
<li>中断处理需要考虑中断源的多样性，包括时钟中断、外部设备中断、软件异常等，并执行相应的处理逻辑。</li>
</ul>
<h1 id="三原创说明">三、原创说明</h1>
<p>无参考资料。</p>
]]></content:encoded>
    </item>
    <item>
      <title>[BUAA-OO] Unit 2 总结</title>
      <link>https://oNya685.github.io/posts/buaa/oo/unit-2/summary/</link>
      <pubDate>Fri, 18 Apr 2025 10:43:00 +0000</pubDate>
      <guid>https://oNya685.github.io/posts/buaa/oo/unit-2/summary/</guid>
      <description>第二单元博客作业</description>
      <content:encoded><![CDATA[<blockquote>
<p>几千字的流水账真的会有人从头看到尾吗（？</p>
<p>不按作业的要求顺序来了，有意思的放最前，重要的放其次，其余的往后排。</p></blockquote>
<h1 id="我们真的需要一台电梯么">我们真的需要一台电梯么？</h1>
<p>首先，回顾一下作业要求：我们要<strong>模拟</strong>六台电梯的运行、调度，和其开关门、移动、对乘客的接、送行为，其中大部分行为需要等待一定的<strong>现实时间</strong>。而评测要求我们在每一<strong>状态转移完成</strong>时输出一条信息，以供测评<strong>评测机中模拟的电梯状态机</strong>是否在<strong>符合正确性规范</strong>的前提下<strong>完成功能</strong>，并<strong>评测性能</strong>。</p>
<h2 id="为什么是状态机">为什么是状态机</h2>
<blockquote>
<p><strong>Everything is a state machine.</strong></p></blockquote>
<p>经常上OS的同学都知道，状态机是一种表示可数个（我想表达的意思是，可以依据规律枚举、列举出，即使有无限种）状态以及在这些状态之间的转移和动作等行为的数学模型。</p>
<p>我们看该单元的电梯系统的架构设计：绝大部分同学（不如说难道还有用其他架构的吗）采取的是这样一种“<strong>三段式架构</strong>”：</p>
$$输入线程 \rightarrow 请求队列 \rightarrow 分配器线程 \rightarrow 等待队列 \rightarrow 电梯线程$$<p>当然，根据大家设计的不同，可能还有其他的共享对象或者其他的箭头关系（主要取决于应对电梯踢人<code>OUT-F</code>和接受临时调度、Update等奇葩请求的设计）。</p>
<p>而电梯是如何决策其状态转移的呢？电梯有如下状态等：当前楼层，是否开门，等待（下称pending）队列，电梯内乘客队列（下称current）。在第一次作业我们就实现了这样一个状态机：采用ALS, LOOK, 或者其他的什么算法。我采用的是出于优先级考虑的，在<strong>高覆盖率</strong>的同时<strong>降低加权平均等待时间</strong>的改进的LOOK算法。</p>
<h2 id="executions的引入"><code>executions</code>的引入</h2>
<p>那么，这一状态机的<strong>输入</strong>是什么？</p>
<p>回顾我们的架构设计，理所当然的，我们会说：输入当然是分配器分配给该电梯的等待队列，吗？</p>
<p>事实上，其决策并<strong>不依赖输入</strong>，换言之，并不是只有有新的请求时电梯才会动的。即使没有请求，电梯也会把自己唤醒，逐步更新自己的状态，直到回归pending和current都变为空的状态。</p>
<p>也就是说，<strong>在任一时刻，若假定该状态机不再会有新的输入（不再分配新的请求），那我们就能推演出该状态机的后续所有行为。</strong>
所以，在后文中，我们暂且规定，称“状态机”为这种没有输入的，自动决策状态转移的状态机。
有没有很像上学期计组做的那个CPU，把机器码记录在文件中加载出来，就能自动执行状态转移？如果把CPU和记录机器码的存储设备框在一起，而不认为机器码是一种输入。把机器码比作pending和current中的数据，和这一单元的电梯是不是很像？</p>
<p>那我们还该如何定义“分配新请求”这种行为呢？很简单，每次分配了新请求，或者告诉电梯要进行SCHE或UPDATE时，我们可以重新计算一遍该电梯从当前状态作所有决策，直到回归空闲状态这一区间中，<strong>所有的状态转移</strong>，并将其更新给电梯线程，电梯线程依次执行即可。</p>
<p>这里，我们引入一个队列 <code>LinkedList&lt;Executeable&gt; executions</code>。用以存储当前电梯所有的状态转移行为，依次执行完就可以抵达名为空闲的终点。</p>
<blockquote>
<p>Interface Executeable，要求实现方法execute(Elevator elevator);  执行时实现状态转移，更新电梯的当前状态</p></blockquote>
<h2 id="解构一台电梯">解构一台电梯</h2>
<p>我们实现了对电梯这一对象的逐步<strong>解构</strong>：现在你还可以坚持称电梯线程在<strong>模拟一台电梯</strong>，实际上它在做的事情只有：<strong>计算executions，execute执行，或者当时间条件不满足时await()</strong>。</p>
<p>下述是对该电梯完全解构的最后一步：把计算executions的工作交给分配器</p>
<p>为什么要这么做？这么做有什么好处？我们考虑分配器的如下分配策略：</p>
<ul>
<li>分配器现在需要<strong>分配某乘客请求</strong>给六台电梯中的任一台，如果可以的话，它希望知道<strong>分配给具体哪一台电梯</strong>能获得最优性能。（当然，不可以的话，随机挑一台塞进去也不是不能跑）</li>
<li>既然对分配器想要分配的这一时刻来说，每一台电梯的接下来的所有行为都是已知的，那么每一台电梯接下来的行为可以用以计算其成本。</li>
<li>那么，分配器想知道分配给哪一台电梯能让总成本最低，就会<strong>依次尝试把乘客请求分配给其中某一台电梯</strong>的情况，并希望知道其总成本：这样，<strong>选出总成本最低的一种情况</strong>，不就是局部的、已知的最优策略了么。相当于在若干条时间线，选了最完美的一条。</li>
<li>但是，怎么知道每一台电梯接下来的行为，甚至是，每一台电梯在接受了当前乘客请求的这一IF线下，接下来的行为呢？我们刚才已经讨论过了，<strong>既然是状态机，那么必然是可以计算的</strong>。</li>
<li>把电梯线程叫醒帮自己计算看上去不太现实（事实上也不太现实），那就自己计算吧，把六个状态机的状态拷贝一份，再创造六个接受了当前乘客分配的IF线状态机，选出最好的一条IF线，并拿这个IF线状态机替换掉真正的状态机，狸猫换太子，就实现了最优分配策略。</li>
<li>那，算都算完了，电梯线程偷个懒不算了，拿着分配器算好的executions，<strong>到时间就执行并且输出</strong>就好了。</li>
</ul>
<h2 id="影子电梯但是只有影子电梯">影子电梯：但是只有影子电梯</h2>
<p>至此，这一臃肿的、模拟真实电梯运行的线程的工作，只剩下：维护一个状态已知、接下来所有状态转移已知的状态机，到了时间就给状态机<strong>执行一步状态转移并输出</strong>，没到时间就回去等着。</p>
<blockquote>
<p>那么，电梯还存在吗？或许游离于分配器的心中，或许藏匿于状态机的状态里，又或许<strong>闪烁在评测机的眼中</strong>，反正不可能说它存在于电梯线程的模拟中了，这么说电梯线程也不能答应的，它只是拿着一串executions，到时间就输出出来而已，连execute都是封装好的。所以我称这样的“电梯线程”为<code>Class Printer extends Thread</code>，它就是一台到时间就自动打印的打印机而已。</p></blockquote>
<blockquote>
<p>按道理来说，贴代码是没人有心思看的，自己的代码自己迭代时都懒得读，但是这是这个线程所剩下的全部内容了，还是读一下吧？
为可读性优化和简化了部分，所以算伪代码。</p></blockquote>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">run</span>() {  
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">long</span> lastTime <span style="color:#f92672">=</span> System.<span style="color:#a6e22e">currentTimeMillis</span>();  
</span></span><span style="display:flex;"><span>    lock.<span style="color:#a6e22e">lock</span>();
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 为方便读，这里省掉了await的try-catch包装块。</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">while</span> (<span style="color:#66d9ef">true</span>) {  
</span></span><span style="display:flex;"><span>		ExecuteAble execution <span style="color:#f92672">=</span> <span style="color:#66d9ef">null</span>;
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// 瞬间的行为，循环依次完成。</span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">while</span> (<span style="color:#f92672">!</span>executions.<span style="color:#a6e22e">isEmpty</span>()) {  
</span></span><span style="display:flex;"><span>			execution <span style="color:#f92672">=</span> executions.<span style="color:#a6e22e">getFirst</span>();  
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> (needTimeToExecute(execution)) {
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>			lastTime <span style="color:#f92672">=</span> executeAndUpdate(execution, lastTime);  
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// 空闲状态，尝试结束或等待新任务的分配。</span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (executions.<span style="color:#a6e22e">isEmpty</span>()) {  
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> (end) { <span style="color:#66d9ef">break</span>; }  
</span></span><span style="display:flex;"><span>			MainProcess.<span style="color:#a6e22e">signalDispatcher</span>();  
</span></span><span style="display:flex;"><span>			printable.<span style="color:#a6e22e">await</span>();  
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">continue</span>;
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// 非瞬间行为，判断是否满足执行条件，失败则等待。</span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">long</span> timeToWait <span style="color:#f92672">=</span> lastTime  
</span></span><span style="display:flex;"><span>			<span style="color:#f92672">+</span> needTimeMap.<span style="color:#a6e22e">get</span>(execution)  
</span></span><span style="display:flex;"><span>			<span style="color:#f92672">-</span> System.<span style="color:#a6e22e">currentTimeMillis</span>();  
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (timeToWait <span style="color:#f92672">&lt;=</span> 0) {
</span></span><span style="display:flex;"><span>			lastTime <span style="color:#f92672">=</span> executeAndUpdate(execution, lastTime);  
</span></span><span style="display:flex;"><span>		} <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>			printable.<span style="color:#a6e22e">await</span>(timeToWait, TimeUnit.<span style="color:#a6e22e">MILLISECONDS</span>);  
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>    lock.<span style="color:#a6e22e">unlock</span>();
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>于是，我们实现了所谓<strong>影子电梯</strong>，证明了影子电梯的可行性，但是全部都是影子电梯。与其说分配器是通过影子电梯计算出分配给具体哪一台真正的电梯，不如说分配器是<strong>拿一台更新后的影子电梯换掉了原来的影子电梯</strong>。</p>
<h1 id="既然影子电梯可行如何适应性能指标">既然影子电梯可行，如何适应性能指标？</h1>
<p>现在谈谈该调度策略是如何权衡总时间、加权平均时间和电量的：</p>
<ol>
<li>首先，我们要尽量降低<strong>总时间$T_{run}$</strong>：这一性能指标显然比另外两个重要的多，如果为追求低功耗而$T_{run}$过大，我们甚至会被判断为效率太低而<strong>超时</strong>，而平均分配、随机分配等方法，也都是在<strong>放弃对于加权平均时间和功耗的考量</strong>下，追求$T_{run}$的解法。</li>
</ol>
<p>但是，$T_{run}$有两个特性：</p>
<ul>
<li>一是对于所有电梯来说，<strong>只有最大的$T_{run}$是有意义的</strong>，当其中一台电梯的总时间很长，而给其他某台电梯分配了请求后总时间依然不比最长的总时间长，那么$T_{run}$是没有变化的，此时追求降低$T_{run}$是一种没太大意义的行为。</li>
<li>二是对于当前$T_{run}$最大的电梯来说，<strong>捎带请求是一种以牺牲少量$T_{run}$换取极大加权平均时间和功耗上收益的决策</strong>。代价是你需要花额外0.4s的$T_{run}$在这一层停下并开关门，性能上却相当划算。</li>
</ul>
<p>因此，在六台电梯分别接受分配请求的时间线中，我选出所有接受分配请求后，$\Delta T_{run} \leq 1s$的时间线并纳入考虑，如果没有符合条件的，则选出$T_{run}$增加值最小的一种情况直接作为分配结果。</p>
<p>接下来我们就可以不考虑$T_{run}$对性能的影响了，即使还有影响，也不到1s，可以大致忽略。我们要考虑，经过筛选后的若干种情况里，加权平均时间$wT$和功耗$W$综合最优的一种情况。但由于性能分是与同学们排名后计算的，我并不知道怎样取得综合最优，理论上我们需要满足：</p>
$$\begin{align*}
\Delta \text{cost} &= a \Delta wT + b \Delta W, \quad a + b = 1 \\
\begin{pmatrix} a & b \end{pmatrix} &= \arg\min \Delta \text{cost}
\end{align*}$$<p>我取$\begin{pmatrix} a &amp; b \end{pmatrix} = \begin{pmatrix} \frac{10}{10+1} &amp; \frac{1}{10+1} \end{pmatrix}$，最后效果尚可。</p>
<h1 id="双轿厢线程协作是否应该影响对象行为">双轿厢：线程协作是否应该影响对象行为？</h1>
<p>我们已经论述过了，时间是线程（具体来讲，是<code>Printer</code>这一打印机线程）要考虑的，线程是<strong>动态的、连续的</strong>，共享对象只有状态，是<strong>静态的、瞬间的</strong>。</p>
<p>所以双轿厢电梯的行为，是共享对象所考虑的，同步开始改造和避免相撞却是线程所需保证的。</p>
<p>具体来讲，我们采取的策略是到达临界楼层后，通过锁等方式让协作线程若有需求先等待自己完成任务，自己完成后尽快退出临界楼层（当然该行为也是共享对象所存储的，而非线程唤起的），放还锁让协作线程继续动态行为。</p>
<p>而在同步改造方面：</p>
<ul>
<li>当两电梯的下一execution均为<code>UPDATE-BEGIN</code>时，由分配器输出<code>UPDATE-BEGIN</code>并唤醒两打印机线程进入计时。两线程共享一把锁。</li>
<li>其中一台电梯<code>UPDATE-BEGIN</code>时锁上共享锁，<code>UPDATE-END</code>时先输出<code>UPDATE-END</code>，然后放还共享锁。</li>
<li>另一台电梯不输出，<code>UPDATE-BEGIN</code>时无行为，但<code>UPDATE-END</code>时先尝试拿到共享锁，拿到后立即放还，然后才执行自己的后续操作。</li>
<li>这样，我们就实现了两协作线程的同步。</li>
</ul>
<p>在这一过程中，线程间的交互不对对象状态产生影响，只对状态转移的时间，即线程行为有所限制。故而，<strong>线程协作不影响对象行为</strong>。</p>
<blockquote>
<p>接下来补充比较重要的内容。</p></blockquote>
<h1 id="架构设计">架构设计</h1>
<p><div class="post-img-view">
    <a data-fancybox="gallery"
         href="UML.png">
        <img alt="UML" loading="lazy" src="/posts/buaa/oo/unit-2/summary/UML_hu_acfc11404447a7e.webp">
    </a>
</div></p>
<p>很明显能看出三段的设计：$线程-共享对象-线程-共享对象-线程$。</p>
<p>前文已介绍过该架构的工作流程，在第一次作业中，我采用与大家相同的架构，而在第二次作业的重构中，我将电梯线程的功能解构提取，变成了如上的只保留简单功能的<code>PrinterThread</code>。第三次作业中，无新增类。</p>
<p>值得介绍的是Scheduler类，其包装了该状态机的决策行为，也即其所有的状态转移计算过程。通过封装Scheduler，我们实现了电梯决策器的可拓展性：当我们需要更换、优化电梯算法，只需要换一个Scheduler或者继承原Scheduler即可。</p>
<blockquote>
<p>这里给出一种性能优化思路，配备多种Scheduler，考虑每种电梯装载不同Scheduler，采取不同算法的时间线，并综合总的性能考量，返回给各状态机最优的executions。但该方法的计算量预估提升了一个数量级，为避免CTLE，应谨慎考虑。</p></blockquote>
<h1 id="线程协作">线程协作</h1>
<p><div class="post-img-view">
    <a data-fancybox="gallery"
         href="sequence-diagram.png">
        <img alt="Sequence Diagram" loading="lazy" src="/posts/buaa/oo/unit-2/summary/sequence-diagram_hu_5e2a5a58756fb817.webp">
    </a>
</div>
上图已明了介绍线程中的协作关系，此处详细解释最后的线程结束的判定：</p>
<ul>
<li>首先，输入线程的结束条件很清晰：读取到值为<code>null</code>的请求时。</li>
<li>但对于Request Queue来说，输入线程与六个电梯线程同时作为生产者，分配器作为消费者；同时，对于每个电梯状态机，分配器是生产者，电梯线程是消费者。</li>
<li>这就形成了一个圈：分配器与电梯互为消费者和生产者，而生产者没有结束时，消费者自然不可以结束。</li>
<li>因此，我们重新定义电梯线程作为生产者的结束：当其executions为空，即空闲状态下，它自然不可能再放归新的请求，我们可以认为其处于临时的结束状态。</li>
<li>而对于此时的调度器，倘若没有需要分配的请求，其会尝试结束：
<ul>
<li>输入线程已结束</li>
<li>各电梯线程处于空闲状态</li>
<li>也即对于RequestQueue，不会有新的生产，也因此没有消费行为和消费行为导致的新的生产。</li>
</ul>
</li>
<li>此时调度器可以认为达到结束条件，结束自身线程并对后续所有线程设置结束。</li>
</ul>
<blockquote>
<p>有趣的和重要的均已结束，现在补充作业要求的其他内容。</p></blockquote>
<h1 id="易变的内容">易变的内容</h1>
<p>稳定的内容已于上文完成分析，而易变的内容，我们需着眼分析两个“例外”：<code>SCHE</code>和<code>UPDATE</code>。</p>
<ul>
<li>对于<code>SCHE</code>，我选择将<code>ScheBegin</code>和<code>ScheEnd</code>纳入<code>Executeable</code>范畴，将其视为状态机的正常状态转移行为，从而使其回归稳定的内容的体系；</li>
<li>对于<code>UPDATE</code>大体相同，但<code>UPDATE-BEGIN</code>实在太特殊，为了两电梯之间的同步，我将其设置为电梯的一种新的状态并因此补充了大量特判，这也是引发我bug的直接原因：补丁没打全。</li>
</ul>
<h1 id="bug分析与debug方法">Bug分析与Debug方法</h1>
<p>第一二次作业无bug，对第三次作业的<code>UPDATE-BEGIN</code>处理引发了第三次作业的bug，并直接导致了强测爆炸：</p>
<p>对于<code>UPDATE-ACCEPT</code>前分配给电梯的请求，经过改造后并不一定能接受，因为其所在楼层不一定属于自己所能移动的范围内。而为了避免<code>UPDATE</code>和<code>SCHE</code>之间无法<code>RECEIVE</code>请求导致分配器轮询，我为每个电梯配置<code>RECEIVE</code>请求缓存区，囤积在<code>END</code>后再输出，因此错过了<code>UPDATE-BEGIN</code>时清空当前已<code>RECEIVE</code>请求的机会，从而可能<code>RECEIVE</code>改造后无法处理的请求。</p>
<p>改正方法为：<code>UPDATE</code>开始时清除<code>RECEIVE</code>缓存区中自己改造后无法处理的请求。</p>
<p>Debug方法为输出。当debug模式启用时，输出各关键行为前后的线程状态、状态机状态。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">// MainProcess.java</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">debug</span>() { <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">false</span>; }
</span></span></code></pre></div><blockquote>
<p>虽然本次作业没有要求课程建议，但是实在很想建议：</p>
<p>能不能给一个<code>TimableOutput.debug(String string)</code>然后输出内容不计入评测，只供debug时便于人类查看，间接解决掉评测出的bug在本地无法复现的问题？这样只要写好关键步骤的日志，就能快速定位到bug，即使本地无法复现也可以正常修复？</p></blockquote>
<h1 id="线程安全与层次化设计">线程安全与层次化设计</h1>
<ol>
<li><strong>锁的合理使用</strong>
<ul>
<li>在本次作业中，线程安全是至关重要的。尤其是在处理多线程的电梯调度和状态更新时，锁的使用非常关键。例如，在电梯线程和分配器线程之间共享的状态机状态（如电梯的当前楼层、电梯内乘客队列等）必须通过锁来保证线程安全。</li>
<li>我们使用了<code>ReentrantLock</code>来确保在更新状态时不会出现竞态条件。例如，在电梯线程执行状态转移时，需要对<code>executions</code>队列进行操作，此时必须加锁，防止分配器线程同时修改该队列。同时，锁的使用也需要谨慎，避免死锁的发生。在电梯线程和分配器线程之间，我们通过合理的锁顺序和锁的释放时机来避免死锁。</li>
<li>使用<code>ReentrantLock</code>有什么好处？条件管理更灵活，而且锁可以脱离对象或代码块而存在，请看使用了<code>ReentrantLock</code>的影子电梯的名场面<strong>六把锁</strong>：</li>
</ul>
</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>   elevators.<span style="color:#a6e22e">forEach</span>(Elevator::lock);
</span></span><span style="display:flex;"><span>   <span style="color:#75715e">// 计算与分配</span>
</span></span><span style="display:flex;"><span>   elevators.<span style="color:#a6e22e">forEach</span>(Elevator::unlock);
</span></span></code></pre></div><ol start="2">
<li><strong>线程间通信的同步机制</strong>
<ul>
<li>线程间通信的安全性也是线程安全的重要方面。在本次作业中，电梯线程和分配器线程之间通过<code>executions</code>队列进行通信，而这个队列的更新和读取必须是线程安全的。</li>
<li>我们使用了<code>Condition</code>来实现线程间的同步。例如，当电梯线程处于空闲状态时，它会调用<code>await()</code>等待分配器线程的信号。分配器线程在计算出新的<code>executions</code>后，会调用<code>signal()</code>唤醒电梯线程。这种同步机制确保了线程间通信的正确性和及时性。</li>
<li>同时，在处理双轿厢电梯的<strong>同步</strong>（改造期间）与<strong>互斥</strong>（临界楼层）时，我们通过共享一把<code>ReentrantLock</code>来实现两台电梯线程之间的同步。这种同步机制不仅保证了线程安全，还避免了电梯之间的冲突。</li>
</ul>
</li>
<li><strong>架构设计的层次化</strong>
<ul>
<li>层次化设计使得代码更加清晰和易于维护。在本次作业中，我们将整个电梯系统划分为多个功能模块，每个模块负责特定的功能。</li>
<li>例如，输入线程负责读取请求并将其放入请求队列；分配器线程负责从请求队列中取出请求并分配给电梯；电梯线程负责执行电梯的状态转移。这种模块划分使得每个线程的功能单一，便于理解和维护。</li>
<li>同时，我们还引入了<code>Scheduler</code>类来封装电梯的状态转移计算逻辑。这样，当需要更换或优化电梯算法时，只需要修改<code>Scheduler</code>类，而不需要修改电梯线程的代码。这种层次化设计提高了代码的可扩展性和可维护性。</li>
</ul>
</li>
</ol>
]]></content:encoded>
    </item>
    <item>
      <title>[BUAA-OS] 理论作业 4</title>
      <link>https://oNya685.github.io/posts/buaa/os/homework-4/</link>
      <pubDate>Thu, 17 Apr 2025 21:25:00 +0800</pubDate>
      <guid>https://oNya685.github.io/posts/buaa/os/homework-4/</guid>
      <description>&lt;p&gt;&lt;strong&gt;&lt;a href=&#34;%e4%bd%9c%e4%b8%9a4.pdf&#34; target=&#34;_blank&#34;&gt;点此查看作业源文件&lt;/a&gt;
&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&#34;1-读者写者问题写者优先&#34;&gt;1. 读者写者问题（写者优先）&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;共享读;&lt;/li&gt;
&lt;li&gt;互斥写、读写互斥;&lt;/li&gt;
&lt;li&gt;写者优先于读者（一旦有写者，则后续读者必须等待，唤醒时优先考虑写者）。&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;semaphore room_empty &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;      &lt;span style=&#34;color:#75715e&#34;&gt;// 读写互斥
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;semaphore mutex_read &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;      &lt;span style=&#34;color:#75715e&#34;&gt;// 保护 read_count
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;semaphore mutex_write &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;     &lt;span style=&#34;color:#75715e&#34;&gt;// 保护 write_count
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;semaphore write_priority &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;  &lt;span style=&#34;color:#75715e&#34;&gt;// 写者优先锁
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; read_count &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;, write_count &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;reader&lt;/span&gt;() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;P&lt;/span&gt;(write_priority);         &lt;span style=&#34;color:#75715e&#34;&gt;// 检查是否有写者等待
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;P&lt;/span&gt;(mutex_read);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    read_count&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (read_count &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a6e22e&#34;&gt;P&lt;/span&gt;(room_empty);         &lt;span style=&#34;color:#75715e&#34;&gt;// 第一个读者获取读写锁
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;V&lt;/span&gt;(mutex_read);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;V&lt;/span&gt;(write_priority);         &lt;span style=&#34;color:#75715e&#34;&gt;// 释放写者优先锁
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 读取
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;P&lt;/span&gt;(mutex_read);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    read_count&lt;span style=&#34;color:#f92672&#34;&gt;--&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (read_count &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a6e22e&#34;&gt;V&lt;/span&gt;(room_empty);           &lt;span style=&#34;color:#75715e&#34;&gt;// 最后一个读者释放读写锁
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;V&lt;/span&gt;(mutex_read);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;writer&lt;/span&gt;() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;P&lt;/span&gt;(mutex_write);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    write_count&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (write_count &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a6e22e&#34;&gt;P&lt;/span&gt;(write_priority);     &lt;span style=&#34;color:#75715e&#34;&gt;// 第一个写者阻止新读者
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;V&lt;/span&gt;(mutex_write);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;P&lt;/span&gt;(room_empty);             &lt;span style=&#34;color:#75715e&#34;&gt;// 获取读写锁
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#75715e&#34;&gt;// 写入
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;	
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;V&lt;/span&gt;(room_empty);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;P&lt;/span&gt;(mutex_write);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    write_count&lt;span style=&#34;color:#f92672&#34;&gt;--&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (write_count &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a6e22e&#34;&gt;V&lt;/span&gt;(write_priority);     &lt;span style=&#34;color:#75715e&#34;&gt;// 最后一个写者允许新读者
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;V&lt;/span&gt;(mutex_write);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h1 id=&#34;2-寿司店问题&#34;&gt;2. 寿司店问题&lt;/h1&gt;
&lt;p&gt;假设一个寿司店有5个座位，如果你到达的时候有一个空座位，你可以立刻就坐。但是如果你到达的时候5个座位都是满的有人已经就坐，这就意味着这些人都是一起来吃饭的，那么你需要等待所有的人一起离开才能就坐。编写同步原语，实现这个场景的约束。&lt;/p&gt;</description>
      <content:encoded><![CDATA[<p><strong><a href="%e4%bd%9c%e4%b8%9a4.pdf" target="_blank">点此查看作业源文件</a>
</strong></p>
<h1 id="1-读者写者问题写者优先">1. 读者写者问题（写者优先）</h1>
<ol>
<li>共享读;</li>
<li>互斥写、读写互斥;</li>
<li>写者优先于读者（一旦有写者，则后续读者必须等待，唤醒时优先考虑写者）。</li>
</ol>
<hr>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>semaphore room_empty <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;      <span style="color:#75715e">// 读写互斥
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>semaphore mutex_read <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;      <span style="color:#75715e">// 保护 read_count
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>semaphore mutex_write <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;     <span style="color:#75715e">// 保护 write_count
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>semaphore write_priority <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;  <span style="color:#75715e">// 写者优先锁
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> read_count <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>, write_count <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">reader</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">P</span>(write_priority);         <span style="color:#75715e">// 检查是否有写者等待
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">P</span>(mutex_read);
</span></span><span style="display:flex;"><span>    read_count<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (read_count <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">P</span>(room_empty);         <span style="color:#75715e">// 第一个读者获取读写锁
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">V</span>(mutex_read);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">V</span>(write_priority);         <span style="color:#75715e">// 释放写者优先锁
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 读取
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">P</span>(mutex_read);
</span></span><span style="display:flex;"><span>    read_count<span style="color:#f92672">--</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (read_count <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">V</span>(room_empty);           <span style="color:#75715e">// 最后一个读者释放读写锁
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">V</span>(mutex_read);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">writer</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">P</span>(mutex_write);
</span></span><span style="display:flex;"><span>    write_count<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (write_count <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">P</span>(write_priority);     <span style="color:#75715e">// 第一个写者阻止新读者
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">V</span>(mutex_write);
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">P</span>(room_empty);             <span style="color:#75715e">// 获取读写锁
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 写入
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">V</span>(room_empty);
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">P</span>(mutex_write);
</span></span><span style="display:flex;"><span>    write_count<span style="color:#f92672">--</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (write_count <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">V</span>(write_priority);     <span style="color:#75715e">// 最后一个写者允许新读者
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">V</span>(mutex_write);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h1 id="2-寿司店问题">2. 寿司店问题</h1>
<p>假设一个寿司店有5个座位，如果你到达的时候有一个空座位，你可以立刻就坐。但是如果你到达的时候5个座位都是满的有人已经就坐，这就意味着这些人都是一起来吃饭的，那么你需要等待所有的人一起离开才能就坐。编写同步原语，实现这个场景的约束。</p>
<hr>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>semaphore mutex <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;         <span style="color:#75715e">// 保护共享变量
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>semaphore batch_lock <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;    <span style="color:#75715e">// 批次锁
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>semaphore waiting <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;       <span style="color:#75715e">// 等待新批次
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> count <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;               <span style="color:#75715e">// 当前批次人数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">customer</span>() {
</span></span><span style="display:flex;"><span>CONSUME:
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">P</span>(mutex);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (count <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 新批次开始
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#a6e22e">P</span>(batch_lock);       <span style="color:#75715e">// 获取批次锁
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (count <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">5</span>) {
</span></span><span style="display:flex;"><span>        count<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">V</span>(mutex);
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 就坐
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 离开
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">P</span>(mutex);
</span></span><span style="display:flex;"><span>        count<span style="color:#f92672">--</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (count <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 批次结束，唤醒等待者
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#a6e22e">V</span>(batch_lock);
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">5</span>; i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>                <span style="color:#a6e22e">V</span>(waiting); <span style="color:#75715e">// 唤醒最多5人
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">V</span>(mutex);
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">V</span>(mutex);
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">P</span>(waiting);          <span style="color:#75715e">// 等待新批次
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#75715e">// 上一批次结束，被唤醒
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">goto</span> CONSUME;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h1 id="3-进门问题">3. 进门问题。</h1>
<h2 id="1请给出pv操作和信号量的物理意义">（1）请给出P、V操作和信号量的物理意义。</h2>
<ol>
<li>信号量的物理意义：信号量是一种同步机制，用于控制多个进程/线程对共享资源的访问。可以看作是一个计数器，表示当前可用的资源数量或某种状态。</li>
<li>P操作的物理意义：表示申请资源。在互斥访问中，P(S) 相当于加锁。</li>
<li>V操作的物理意义：表示释放资源，如果有进程在等待该资源，则唤醒其中一个。在互斥访问中，V(S) 相当于解锁。</li>
</ol>
<h2 id="2一个软件公司有5名员工每人刷卡上班员工刷卡后需要等待直到所有员工都刷卡后才能进入公司为了避免拥挤公司要求员工一个一个通过大门所有员工都进入后最后进入的员工负责关门请用pv操作实现员工之间的同步关系">（2）一个软件公司有5名员工，每人刷卡上班。员工刷卡后需要等待，直到所有员工都刷卡后才能进入公司。为了避免拥挤，公司要求员工一个一个通过大门。所有员工都进入后，最后进入的员工负责关门。请用P、V操作实现员工之间的同步关系。</h2>
<hr>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>semaphore barrier <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;       <span style="color:#75715e">// 等待所有员工到达
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>semaphore door <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;          <span style="color:#75715e">// 控制逐个通过
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>semaphore mutex <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;         <span style="color:#75715e">// 保护计数器
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> count <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">employee</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">P</span>(mutex);
</span></span><span style="display:flex;"><span>    count<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (count <span style="color:#f92672">==</span> <span style="color:#ae81ff">5</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">V</span>(barrier);          <span style="color:#75715e">// 第5人触发屏障
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">V</span>(mutex);
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">P</span>(barrier);              <span style="color:#75715e">// 所有员工等待在此
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">V</span>(barrier);              <span style="color:#75715e">// 保持屏障信号
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">P</span>(door);
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 通过大门
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">V</span>(door);
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">P</span>(mutex);
</span></span><span style="display:flex;"><span>    count<span style="color:#f92672">--</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (count <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 关门
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">V</span>(mutex);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h1 id="4-搜索-插入-删除问题">4. 搜索-插入-删除问题。</h1>
<p>三个线程对一个单链表进行并发的访问，分别进行搜索、插入和删除。搜索线程仅仅读取链表，因此多个搜索线程可以并发。插入线程把数据项插入到链表最后的位置；多个插入线程必须互斥防止同时执行插入操作。但是，一个插入线程可以和多个搜索线程并发执行。最后，删除线程可以从链表中任何一个位置删除数据。一次只能有一个删除线程执行；删除线程之间，删除线程和搜索线程，删除线程和插入线程都不能同时执行。</p>
<p>请编写三类线程的同步互斥代码，描述这种三路的分类互斥问题。</p>
<hr>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>semaphore search_mutex <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;    <span style="color:#75715e">// 搜索并发控制
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>semaphore insert_mutex <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;    <span style="color:#75715e">// 插入互斥
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>semaphore delete_mutex <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;    <span style="color:#75715e">// 删除独占
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> search_count <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">search</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">P</span>(search_mutex);
</span></span><span style="display:flex;"><span>    search_count<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (search_count <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">P</span>(delete_mutex);       <span style="color:#75715e">// 阻止删除
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">V</span>(search_mutex);
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 搜索
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">P</span>(search_mutex);
</span></span><span style="display:flex;"><span>    search_count<span style="color:#f92672">--</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (search_count <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">V</span>(delete_mutex);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">V</span>(search_mutex);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">insert</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">P</span>(insert_mutex);           <span style="color:#75715e">// 插入互斥
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 插入
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">V</span>(insert_mutex);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">delete</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">P</span>(delete_mutex);           <span style="color:#75715e">// 独占删除
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 删除
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">V</span>(delete_mutex);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div>]]></content:encoded>
    </item>
    <item>
      <title>[BUAA-OS] Lab 2 实验报告</title>
      <link>https://oNya685.github.io/posts/buaa/os/lab-2-report/</link>
      <pubDate>Fri, 11 Apr 2025 09:53:55 +0800</pubDate>
      <guid>https://oNya685.github.io/posts/buaa/os/lab-2-report/</guid>
      <description>&lt;h1 id=&#34;一思考题&#34;&gt;一、思考题&lt;/h1&gt;
&lt;h2 id=&#34;thinking-21&#34;&gt;Thinking 2.1&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;请根据上述说明，回答问题：在编写的 C 程序中，指针变量中存储的地址被视为虚拟地址，还是物理地址？MIPS 汇编程序中 lw和sw 指令使用的地址被视为虚拟地址，还是物理地址？&lt;/p&gt;</description>
      <content:encoded><![CDATA[<h1 id="一思考题">一、思考题</h1>
<h2 id="thinking-21">Thinking 2.1</h2>
<blockquote>
<p>请根据上述说明，回答问题：在编写的 C 程序中，指针变量中存储的地址被视为虚拟地址，还是物理地址？MIPS 汇编程序中 lw和sw 指令使用的地址被视为虚拟地址，还是物理地址？</p></blockquote>
<hr>
<p>都是<strong>虚拟地址</strong>。本质都是翻译为含虚拟地址的机器码，交由CPU进行访存。</p>
<h2 id="thinking-22">Thinking 2.2</h2>
<blockquote>
<p>请思考下述两个问题：</p>
<ul>
<li>从可重用性的角度，阐述用宏来实现链表的好处。</li>
<li>查看实验环境中的/usr/include/sys/queue.h，了解其中单向链表与循环链表的实现，比较它们与本实验中使用的双向链表，分析三者在插入与删除操作上的性能差异。</li>
</ul></blockquote>
<hr>
<ol>
<li>通过宏定义，该链表实现了对于各种类型的可重用性。
上机后补充：例如<code>MBlock</code>与其field（<code>mb_link</code>），可以直接使用该链表以及操作链表的宏（例如<code>LIST_INSERT_AFTER</code>与<code>LIST_REMOVE</code>）。</li>
<li>比较单向链表、循环链表与双向链表：</li>
</ol>
<table>
  <thead>
      <tr>
          <th style="text-align: center">操作</th>
          <th style="text-align: center">单向链表</th>
          <th style="text-align: center">循环链表</th>
          <th style="text-align: center">双向链表</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td style="text-align: center">插入</td>
          <td style="text-align: center">性能相似，但插入到尾结点需要完整遍历链表</td>
          <td style="text-align: center">性能相似，但插入到尾结点更快</td>
          <td style="text-align: center">性能相似，但插入到尾结点需要完整遍历链表</td>
      </tr>
      <tr>
          <td style="text-align: center">删除</td>
          <td style="text-align: center">需要找上一结点的位置，O(n)</td>
          <td style="text-align: center">性能与双向链表相似</td>
          <td style="text-align: center">性能与循环链表相似</td>
      </tr>
  </tbody>
</table>
<h2 id="thinking-23">Thinking 2.3</h2>
<blockquote>
<p>请阅读include/queue.h以及include/pmap.h,将Page_list的结构梳理清楚，选择正确的展开结构。</p></blockquote>
<hr>
<p>选C。</p>
<p>首先，<code>le_prev</code>是指向前继结点的后继指针的指针，类型是<code>struct Type **</code>，排除A。</p>
<p>其次，<code>lh_first</code>是指向链表首结点的指针，类型是<code>struct Type *</code>，排除B。</p>
<h2 id="thinking-24">Thinking 2.4</h2>
<blockquote>
<p>请思考下面两个问题：</p>
<ul>
<li>请阅读上面有关TLB的描述，从虚拟内存和多进程操作系统的实现角度，阐述ASID的必要性。</li>
<li>请阅读 MIPS 4Kc 文档《MIPS32® 4K™ Processor Core Family Software User’s Manual》的 Section 3.3.1 与 Section 3.4，结合 ASID 段的位数，说明 4Kc 中可容纳不同的地址空间的最大数量。</li>
</ul></blockquote>
<hr>
<ol>
<li>
<p>某一虚拟地址在不同地址空间中可以被映射到不同物理地址，所以需要ASID以确定地址空间。</p>
</li>
<li>
<p>可容纳最多64个不同的地址空间。</p>
</li>
</ol>
<pre tabindex="0"><code>Instead, the OS assigns a 6-bit unique code to each task’s distinct address space. Since the ASID is only 6 bits long, OS software does have to lend a hand if there are ever more than 64 address spaces in concurrent use; but it probably won’t happen too often.
</code></pre><h2 id="thinking-25">Thinking 2.5</h2>
<blockquote>
<p>请回答下述三个问题：</p>
<ul>
<li>tlb_invalidate和tlb_out的调用关系？</li>
<li>请用一句话概括tlb_invalidate的作用。</li>
<li>逐行解释tlb_out中的汇编代码。</li>
</ul></blockquote>
<hr>
<ol>
<li><code>tlb_invalidate</code>调用了<code>tlb_out</code>。</li>
<li>调用<code>tlb_invalidate</code>可以将该地址与虚拟地址的映射表项从TLB中清除。</li>
<li><code>tlb_out</code>：用于清除指定虚拟地址对应的TLB表项。通过先保存当前ENTRYHI值，然后设置新的ENTRYHI进行TLB探测，找到对应表项后通过写入空值实现删除，最后恢复原始ENTRYHI值。</li>
</ol>
<pre tabindex="0"><code class="language-mips" data-lang="mips">LEAF(tlb_out)                    // 定义名为tlb_out的叶子函数
.set noreorder                   // 禁止汇编器重新排列指令顺序
	mfc0    t0, CP0_ENTRYHI      // 将协处理器CP0的ENTRYHI寄存器值保存到t0
	mtc0    a0, CP0_ENTRYHI      // 将参数寄存器a0的值写入CP0的ENTRYHI寄存器
	nop                          // 空操作，确保mtc0操作完成
	/* Step 1: Use &#39;tlbp&#39; to probe TLB entry */
	/* Exercise 2.8: Your code here. (1/2) */
	tlbp                         // TLB探测指令，根据ENTRYHI查找匹配的TLB条目
	nop                          // 保证tlbp指令完成
	/* Step 2: Fetch the probe result from CP0.Index */
	mfc0    t1, CP0_INDEX        // 将CP0的INDEX寄存器值读取到t1
.set reorder                     // 允许汇编器重新排列指令顺序
	bltz    t1, NO_SUCH_ENTRY    // 如果未找到该ENTRY，跳转到NO_SUCH_ENTRY
.set noreorder                   // 再次禁止指令重排
	mtc0    zero, CP0_ENTRYHI    // 清零CP0的ENTRYHI寄存器
	mtc0    zero, CP0_ENTRYLO0   // 清零CP0的ENTRYLO0寄存器
	mtc0    zero, CP0_ENTRYLO1   // 清零CP0的ENTRYLO1寄存器
	nop                          // 保证寄存器写入操作完成
	/* Step 3: Use &#39;tlbwi&#39; to write CP0.EntryHi/Lo into TLB at CP0.Index  */
	/* Exercise 2.8: Your code here. (2/2) */
	tlbwi                        // 将当前EntryHi/EntryLo写入TLB表项，删除该条目
.set reorder                     // 恢复指令重排

NO_SUCH_ENTRY:                   // 未找到对应TLB条目时的标签
	mtc0    t0, CP0_ENTRYHI      // 恢复原始ENTRYHI寄存器值
	j       ra                   // 函数返回
END(tlb_out)                     // 函数结束
</code></pre><h2 id="thinking-26">Thinking 2.6</h2>
<blockquote>
<p>请结合 Lab2 开始的 CPU 访存流程与下图中的 Lab2 用户函数部分，尝试将函数调用与CPU访存流程对应起来，思考函数调用与CPU访存流程的关系。</p></blockquote>
<p><div class="post-img-view">
    <a data-fancybox="gallery"
         href="%E5%9B%BE%202.9%20-%20Lab2%20in%20MOS.png">
        <img alt="图 2.9 - Lab2 in MOS" loading="lazy" src="/posts/buaa/os/lab-2-report/%E5%9B%BE%202.9%20-%20Lab2%20in%20MOS_hu_af7d8134b90ca25f.webp">
    </a>
</div></p>
<hr>
<p>在 Lab2（以及后续实验）中，4Kc CPU 的访存过程可以概括为以下几个关键步骤</p>
<ul>
<li>当 CPU 执行一条访存相关的指令（包含取指令、读数据、写数据）时，会把<strong>虚拟地址</strong>送入 MMU。</li>
<li>MMU 会首先在 TLB 中查找该虚拟地址是否有对应的物理地址映射。
<ul>
<li>若命中（TLB Hit），CPU 即可直接得知该虚拟地址对应的<strong>物理地址</strong>，并进行后续的读写缓存或内存操作。</li>
<li>若未命中（TLB Miss），CPU 会触发异常，进入内核执行 TLB refill / page fault 处理流程（视情况而定），由操作系统的异常/中断处理例程负责查找该虚拟地址应对应的物理地址、分配物理页、更新 TLB。</li>
</ul>
</li>
<li>当映射关系建立后，CPU 可以“拿到”正确的物理地址并进行实际的内存（或外设寄存器）读写操作。</li>
</ul>
<p>在这个过程中，所看到的「kuseg、kseg0、kseg1」等地址段的区别，决定了 CPU 是否直接对高地址位清零映射（无缓存/有缓存）或者需要通过 TLB。<strong>对于用户态的地址（kuseg，0x00000000~0x7fffffff），一定要通过 TLB</strong>。</p>
<p>在 Lab2 中，当我们调用函数时，背后的硬件过程正是 CPU 发出虚拟地址、经 TLB 查表或异常处理、进而映射到物理地址并访问内存的流程。<strong>函数调用是软件层面分配、管理地址空间的逻辑，而 CPU 访存流程是硬件层面真正将指令和数据从内存取出、写入的机制；两者一一对应、紧密耦合</strong>。通过把它们结合起来，我们就能全面理解操作系统与用户态程序在地址空间管理上的工作原理。</p>
<h2 id="thinking-27">Thinking 2.7</h2>
<blockquote>
<p>从下述三个问题中任选其一回答：</p>
<ul>
<li>简单了解并叙述X86体系结构中的内存管理机制，比较X86和MIPS 在内存管理上的区别。</li>
<li>简单了解并叙述RISC-V 中的内存管理机制，比较RISC-V 与 MIPS 在内存管理上的区别。</li>
<li>简单了解并叙述LoongArch 中的内存管理机制，比较 LoongArch 与 MIPS 在内存管理上的区别。</li>
</ul></blockquote>
<hr>
<p>X86 与 MIPS 内存管理的主要区别</p>
<ul>
<li>分段机制与固定地址区间
<ul>
<li><strong>X86：</strong><br>
传统上依靠分段来实现内存保护和地址转换，虽然现代操作系统多采用扁平模型，但分段概念依然存在，并且在保护模式下提供了多级特权和动态调整段基址的能力。</li>
<li><strong>MIPS：</strong><br>
使用固定的地址区间划分（如kuseg、kseg0、kseg1），没有灵活的分段机制，内核与用户空间的划分由硬件地址范围直接确定，整体设计更加简单。</li>
</ul>
</li>
<li>分页管理方式
<ul>
<li><strong>X86：</strong><br>
采用硬件支持的多级页表结构，地址转换过程由硬件直接完成（结合 TLB 缓存），在现代 x86-64 中使用 4 级或更多级页表，同时支持 PAE 和 NX 等扩展特性。</li>
<li><strong>MIPS：</strong><br>
通常依赖软件管理的 TLB，当发生 TLB miss 时，通过异常处理由操作系统完成页表查找和 TLB 填充，其页表结构也较为灵活，但整体在硬件自动化管理程度上较 X86 要简单。</li>
</ul>
</li>
<li>TLB 设计
<ul>
<li><strong>X86：</strong><br>
TLB 作为硬件缓存，通常与分页机制紧密结合，自动维护地址映射缓存，减少页表查找延迟。</li>
<li><strong>MIPS：</strong><br>
TLB 由软件管理，需要操作系统在 TLB miss 异常处理程序中主动维护，虽然这种设计在一定程度上降低了硬件复杂性，但对操作系统的设计与调度要求更高。</li>
</ul>
</li>
</ul>
<h1 id="二难点分析与实验体会">二、难点分析与实验体会</h1>
<h2 id="1-链表宏的理解与使用">1. 链表宏的理解与使用</h2>
<p>链表中大量指针，指针的指针，混杂在一起，较难理解其具体含义。经过<code>struct Page</code>链表的阅读及补全后初步理解链表宏的使用流程与传参细节。</p>
<h2 id="2-二级页表的实现">2. 二级页表的实现</h2>
<p>经过实验代码，我们能发现二级页表的页表项其实是<code>u_long</code>类型，由页框号与有效位组成。通过这一类型的实现有一些反直觉，在理解其为字对齐后便理解了一些实现细节。</p>
<h1 id="三原创说明">三、原创说明</h1>
<p>参考资料：</p>
<ol>
<li><em>MIPS32® 4K™ Processor Core Family Software User’s Manual</em></li>
<li><a href="https://zhuanlan.zhihu.com/p/549874101" target="_blank">全网超详细解析！X86/X64处理器体系结构及寻址模式 - 知乎</a>
</li>
<li><a href="https://blog.csdn.net/d1306937299/article/details/87874422" target="_blank">X86内存管理机制&ndash;分段机制详析_x86 为什么要这么多段寄存器-CSDN博客</a>
</li>
</ol>
]]></content:encoded>
    </item>
    <item>
      <title>[BUAA-OS] 理论作业 3</title>
      <link>https://oNya685.github.io/posts/buaa/os/homework-3/</link>
      <pubDate>Sun, 06 Apr 2025 17:03:00 +0800</pubDate>
      <guid>https://oNya685.github.io/posts/buaa/os/homework-3/</guid>
      <description>&lt;p&gt;&lt;strong&gt;&lt;a href=&#34;%e4%bd%9c%e4%b8%9a3.pdf&#34; target=&#34;_blank&#34;&gt;点此查看作业源文件&lt;/a&gt;
&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&#34;第一题&#34;&gt;第一题&lt;/h1&gt;
&lt;h2 id=&#34;1请问进程整个的地址空间有多少字节一页有多少字节&#34;&gt;（1）请问进程整个的地址空间有多少字节？一页有多少字节？&lt;/h2&gt;
$$ 进程整个的地址空间 = 2^{32}B = 4GB $$$$一页有 2^{12}B = 4KB$$&lt;h2 id=&#34;2一个进程如果从-0x80000000-开始映射-4mb-大小页表空间求第一级页表页目录的起始逻辑地址并指出从哪个逻辑地址可以读出第一级页表页目录所在的物理页框号说明理由注意-b-代表字节一个-32-位地址占-4-字节&#34;&gt;（2）一个进程如果从 0x80000000 开始映射 4MB 大小页表空间，求第一级页表（页目录）的起始逻辑地址，并指出从哪个逻辑地址可以读出第一级页表（页目录）所在的物理页框号。说明理由。（注意 B 代表字节，一个 32 位地址占 4 字节）&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;进程页表空间映射起始地址为&lt;code&gt;0x80000000&lt;/code&gt;，所以页目录的第&lt;code&gt;0x200&lt;/code&gt;项指向页表空间，所以第一级页表的起始逻辑地址为&lt;code&gt;0x80200000&lt;/code&gt;。&lt;/p&gt;</description>
      <content:encoded><![CDATA[<p><strong><a href="%e4%bd%9c%e4%b8%9a3.pdf" target="_blank">点此查看作业源文件</a>
</strong></p>
<h1 id="第一题">第一题</h1>
<h2 id="1请问进程整个的地址空间有多少字节一页有多少字节">（1）请问进程整个的地址空间有多少字节？一页有多少字节？</h2>
$$ 进程整个的地址空间 = 2^{32}B = 4GB $$$$一页有 2^{12}B = 4KB$$<h2 id="2一个进程如果从-0x80000000-开始映射-4mb-大小页表空间求第一级页表页目录的起始逻辑地址并指出从哪个逻辑地址可以读出第一级页表页目录所在的物理页框号说明理由注意-b-代表字节一个-32-位地址占-4-字节">（2）一个进程如果从 0x80000000 开始映射 4MB 大小页表空间，求第一级页表（页目录）的起始逻辑地址，并指出从哪个逻辑地址可以读出第一级页表（页目录）所在的物理页框号。说明理由。（注意 B 代表字节，一个 32 位地址占 4 字节）</h2>
<ul>
<li>
<p>进程页表空间映射起始地址为<code>0x80000000</code>，所以页目录的第<code>0x200</code>项指向页表空间，所以第一级页表的起始逻辑地址为<code>0x80200000</code>。</p>
</li>
<li>
<p>页目录自映射，访问逻辑地址<code>0x80200800</code>可以读取页目录所在的物理页框号。</p>
</li>
</ul>
<h2 id="3如果当前进程的页目录物理基地址页目录和相应页表内容如图下所示请描述访问以下逻辑地址时系统进行地址转换的过程如可行给出最终访存读取到的数据逻辑地址0x00x008030040x00402001">（3）如果当前进程的页目录物理基地址、页目录和相应页表内容如图下所示，请描述访问以下逻辑地址时系统进行地址转换的过程，如可行，给出最终访存读取到的数据。逻辑地址：0x0、0x00803004、0x00402001</h2>
<ol>
<li>访问<code>0x0</code>：
<ul>
<li>| 0000 0000 00 | 00 0000 0000 | 0000 0000 0000 |</li>
<li>找页目录第0项 -&gt; 页表项内容：00000 | 000</li>
<li>缺页异常</li>
</ul>
</li>
<li>访问<code>0x00803004</code>：
<ul>
<li>| 0000 0000 10 | 00 0000 0011 | 0000 0000 0100 |</li>
<li>找页目录第2项 -&gt; 页表项：00005 | 001</li>
<li>页表地址：<code>0x5000</code>，有效</li>
<li>找页表第3项 -&gt; 页表项：00020 | 001</li>
<li>页地址：<code>0x20000</code></li>
<li>物理地址：<code>0x20000</code> + <code>0x004</code> = <code>0x20004</code></li>
<li>读取到的字为<code>0x326001</code></li>
<li>读取到的数据：<code>0x00</code>（小端序）或<code>0x01</code>（大端序）</li>
</ul>
</li>
<li>访问<code>0x00402001</code>：
<ul>
<li>| 0000 0000 01 | 00 0000 0010 | 0000 0000 0001 |</li>
<li>找页目录第1项 -&gt; 页表项内容：00001 | 001</li>
<li>页表地址：<code>0x1000</code>，有效</li>
<li>找页表第2项 -&gt; 页表项：00005 | 001</li>
<li>页地址：<code>0x5000</code></li>
<li>物理地址：<code>0x5000</code> + <code>0x001</code> = <code>0x5001</code></li>
<li>读取到的字为<code>0x0</code></li>
<li>读取到的数据：<code>0x00</code></li>
</ul>
</li>
</ol>
<h2 id="4要想访问物理地址-0x326028需要使用哪个逻辑地址">（4）要想访问物理地址 0x326028，需要使用哪个逻辑地址？</h2>
<ul>
<li>页内偏移：<code>0x028</code></li>
<li>页框号：<code>0x326</code>，出现在<code>0x20000</code> + 1 * <code>0x4</code>，所以二级页表号：<code>0x1</code></li>
<li>页框号：<code>0x20</code>，出现在<code>0x1000</code> + 3 * <code>0x4</code>，所以一级页表号：<code>0x3</code></li>
<li>逻辑地址：| 0000 0000 11 | 00 0000 0001 | 0000 0010 1000 |</li>
<li>即：<code>0x00c01028</code></li>
</ul>
<h1 id="第二题">第二题</h1>
<h2 id="1load-0x00001022">（1）Load [0x00001022]</h2>
<ul>
<li>页目录号：<code>0x000</code>
<ul>
<li>访问<code>0x0020 0000</code> + 4 * <code>0x000</code> = <code>0x0020 0000</code>：<code>0x0010 0007</code>
<ul>
<li>二级页表页框号：<code>0x00100</code></li>
<li>标志位：<code>0x007</code>，Valid, Read/Write</li>
</ul>
</li>
</ul>
</li>
<li>二级页表号：<code>0x001</code>
<ul>
<li>访问<code>0x0010 0000</code> + 4 * <code>0x001</code> = <code>0x0010 0004</code>：<code>0x0000 4067</code>
<ul>
<li>物理页框号：<code>0x00004</code></li>
<li>标志位：<code>0x067</code>，Valid, Read/Write</li>
</ul>
</li>
</ul>
</li>
<li>页内偏移量：<code>0x022</code>
<ul>
<li>访问<code>0x0000 4000</code> + <code>0x022</code> = <code>0x0000 4022</code>：<code>0x20</code></li>
</ul>
</li>
<li><strong>成功：<code>0x20</code></strong></li>
</ul>
<h2 id="2store-0x00c07222">（2）Store [0x00C07222]</h2>
<ul>
<li>页目录号：<code>0x003</code>
<ul>
<li>访问<code>0x0020 0000</code> + 4 * <code>0x003</code> = <code>0x0020 000C</code>：<code>0x0010 3007</code>
<ul>
<li>二级页表页框号：<code>0x00103</code></li>
<li>标志位：<code>0x007</code>，Valid, Read/Write</li>
</ul>
</li>
</ul>
</li>
<li>二级页表号：<code>0x007</code>
<ul>
<li>访问<code>0x0010 3000</code> + 4 * <code>0x007</code> = <code>0x0010 301C</code>：<code>0xEEFF 0001</code>
<ul>
<li>标志位：<code>0x001</code>，Valid, Read Only</li>
</ul>
</li>
</ul>
</li>
<li>页内偏移量：<code>0x222</code></li>
<li><strong>Error: Read Only</strong></li>
</ul>
<h2 id="3store-0x00c005bf">（3）Store [0x00C005BF]</h2>
<ul>
<li>页目录号：<code>0x003</code>
<ul>
<li>访问<code>0x0020 0000</code> + 4 * <code>0x003</code> = <code>0x0020 000C</code>：<code>0x0010 3007</code>
<ul>
<li>二级页表页框号：<code>0x00103</code></li>
<li>标志位：<code>0x007</code>，Valid, Read/Write</li>
</ul>
</li>
</ul>
</li>
<li>二级页表号：<code>0x000</code>
<ul>
<li>访问<code>0x0010 3000</code> + 4 * <code>0x000</code> = <code>0x0010 3000</code>：<code>0x1122 0067</code>
<ul>
<li>物理页框号：<code>0x11220</code></li>
<li>标志位：<code>0x067</code>，Valid, Read/Write</li>
</ul>
</li>
</ul>
</li>
<li>页内偏移量：<code>0x5BF</code>
<ul>
<li>写入<code>0x1122 0000</code> + <code>0x067</code> = <code>0x1122 0067</code></li>
</ul>
</li>
<li><strong>OK: <code>0x1122 0067</code></strong></li>
</ul>
<h2 id="4load-0x00003013">（4）Load [0x00003013]</h2>
<ul>
<li>页目录号：<code>0x000</code>
<ul>
<li>访问<code>0x0020 0000</code> + 4 * <code>0x000</code> = <code>0x0020 0000</code>：<code>0x0010 0007</code>
<ul>
<li>二级页表页框号：<code>0x00100</code></li>
<li>标志位：<code>0x007</code>，Valid, Read/Write</li>
</ul>
</li>
</ul>
</li>
<li>二级页表号：<code>0x003</code>
<ul>
<li>访问<code>0x0010 0000</code> + 4 * <code>0x003</code> = <code>0x0010 000C</code>：<code>0x0000 4007</code>
<ul>
<li>物理页框号：<code>0x00004</code></li>
<li>标志位：<code>0x007</code>，Valid, Read/Write</li>
</ul>
</li>
</ul>
</li>
<li>页内偏移量：<code>0x013</code>
<ul>
<li>访问<code>0x0000 4000</code> + <code>0x013</code> = <code>0x0000 4013</code>：<code>0x19</code></li>
</ul>
</li>
<li><strong>成功：<code>0x19</code></strong></li>
</ul>
<h2 id="5load-0xff80078f">（5）Load [0xFF80078F]</h2>
<ul>
<li>页目录号：<code>0x3FE</code>
<ul>
<li>访问<code>0x0020 0000</code> + 4 * <code>0x3FE</code> = <code>0x0020 0FF8</code>：<code>0x001F E007</code>
<ul>
<li>二级页表页框号：<code>0x001FE</code></li>
<li>标志位：<code>0x007</code>，Valid, Read/Write</li>
</ul>
</li>
</ul>
</li>
<li>二级页表号：<code>0x000</code>
<ul>
<li>访问<code>0x001F E000</code> + 4 * <code>0x000</code> = <code>0x001F E000</code>：<code>0x0415 0000</code>
<ul>
<li>标志位：<code>0x000</code>，Invalid</li>
</ul>
</li>
</ul>
</li>
<li>页内偏移量：<code>0x78F</code></li>
<li><strong>Error: Invalid</strong></li>
</ul>
<h2 id="6load-0xfffff005">（6）Load [0xFFFFF005]</h2>
<ul>
<li>页目录号：<code>0x3FF</code>
<ul>
<li>访问<code>0x0020 0000</code> + 4 * <code>0x3FF</code> = <code>0x0020 0FFC</code>：<code>0x001F F007</code>
<ul>
<li>二级页表页框号：<code>0x001FF</code></li>
<li>标志位：<code>0x007</code>，Valid, Read/Write</li>
</ul>
</li>
</ul>
</li>
<li>二级页表号：<code>0x3FF</code>
<ul>
<li>访问<code>0x001F F000</code> + 4 * <code>0x3FF</code> = <code>0x001F FFFC</code>：<code>0x0010 3067</code>
<ul>
<li>物理页框号：<code>0x00103</code></li>
<li>标志位：<code>0x067</code>，Valid, Read/Write</li>
</ul>
</li>
</ul>
</li>
<li>页内偏移量：<code>0x005</code>
<ul>
<li>访问<code>0x0010 3000</code> + <code>0x005</code> = <code>0x0010 3005</code>：<code>0x66</code></li>
</ul>
</li>
<li><strong>成功：<code>0x66</code></strong></li>
</ul>
<p>综上所述：</p>
<table>
  <thead>
      <tr>
          <th>指令</th>
          <th>结果</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>Load [0x00001022]</td>
          <td><code>0x20</code></td>
      </tr>
      <tr>
          <td>Store [0x00C07222]</td>
          <td>Error</td>
      </tr>
      <tr>
          <td>Store [0x00C005BF]</td>
          <td>OK</td>
      </tr>
      <tr>
          <td>Load [0x00003013]</td>
          <td><code>0x19</code></td>
      </tr>
      <tr>
          <td>Load [0xFF80078F]</td>
          <td>Error</td>
      </tr>
      <tr>
          <td>Load [0xFFFFF005]</td>
          <td><code>0x66</code></td>
      </tr>
  </tbody>
</table>
]]></content:encoded>
    </item>
    <item>
      <title>[BUAA-OS] 理论作业 2</title>
      <link>https://oNya685.github.io/posts/buaa/os/homework-2/</link>
      <pubDate>Fri, 28 Mar 2025 19:00:00 +0800</pubDate>
      <guid>https://oNya685.github.io/posts/buaa/os/homework-2/</guid>
      <description>&lt;p&gt;&lt;strong&gt;&lt;a href=&#34;%e4%bd%9c%e4%b8%9a2.pdf&#34; target=&#34;_blank&#34;&gt;点此查看作业源文件&lt;/a&gt;
&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&#34;1-动态内存分配需要对内存分区进行管理一般使用位图和空闲链表两种方法128mb的内存以n字节为单元分配对于链表假设内存中数据段和空闲区交替排列长度均为64kb并假设链表中的每个节点需要记录32位的内存地址信息16位长度信息和16位下一节点域信息这两种方法分别需要多少字节的存储空间哪种方法更好&#34;&gt;1. 动态内存分配需要对内存分区进行管理，一般使用位图和空闲链表两种方法。128MB的内存以n字节为单元分配，对于链表，假设内存中数据段和空闲区交替排列，长度均为64KB。并假设链表中的每个节点需要记录32位的内存地址信息、16位长度信息和16位下一节点域信息。这两种方法分别需要多少字节的存储空间？哪种方法更好？&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;若使用位图方法：&lt;/li&gt;
&lt;/ul&gt;
$$单元数 = \frac{128MB}{nB} = \frac{2^{27}}{n}块$$$$所需存储空间 = \frac{2^{27}}{n}b = \frac{16}{n}MB$$&lt;ul&gt;
&lt;li&gt;若使用空闲链表方法：&lt;/li&gt;
&lt;/ul&gt;
$$段数=\frac{128MB}{64KB+64KB} = 2^{10}段$$$$所需存储空间 = 2^{10} \times (32 + 16 + 16)b = 8KB$$&lt;ul&gt;
&lt;li&gt;哪种方法更好：
&lt;ul&gt;
&lt;li&gt;当n&amp;lt;2048时，空闲链表所需存储空间更小，空闲链表方法更好；&lt;/li&gt;
&lt;li&gt;当n&amp;gt;2048时，位图所需存储空间更小，位图方法更好。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;2-在一个交换系统中按内存地址排列的空闲区大小是-10kb4kb20kb18kb7kb9kb12kb和15kb对于连续的段请求12kb10kb9kb使用firstfitbestfitworstfit和nextfit将找出哪些空闲区&#34;&gt;2. 在一个交换系统中，按内存地址排列的空闲区大小是: 10KB、4KB、20KB、18KB、7KB、9KB、12KB和15KB。对于连续的段请求：12KB、10KB、9KB。使用FirstFit、BestFit、WorstFit和NextFit将找出哪些空闲区？&lt;/h1&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;段请求&lt;/th&gt;
          &lt;th&gt;FirstFit&lt;/th&gt;
          &lt;th&gt;BestFit&lt;/th&gt;
          &lt;th&gt;WorstFit&lt;/th&gt;
          &lt;th&gt;NextFit&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;12KB&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;20KB&lt;/td&gt;
          &lt;td&gt;12KB&lt;/td&gt;
          &lt;td&gt;20KB&lt;/td&gt;
          &lt;td&gt;20KB&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;10KB&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;10KB&lt;/td&gt;
          &lt;td&gt;10KB&lt;/td&gt;
          &lt;td&gt;18KB&lt;/td&gt;
          &lt;td&gt;18KB&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;9KB&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;18KB&lt;/td&gt;
          &lt;td&gt;9KB&lt;/td&gt;
          &lt;td&gt;15KB&lt;/td&gt;
          &lt;td&gt;9KB&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;h1 id=&#34;3-解释逻辑地址物理地址地址映射并举例说明&#34;&gt;3. 解释逻辑地址、物理地址、地址映射，并举例说明。&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;逻辑地址（Logical Address）：
逻辑地址是程序运行时由 CPU 生成的地址，也称为虚拟地址。用户进程只能访问逻辑地址，不能直接访问物理内存。&lt;br&gt;
例如某程序访问地址 &lt;code&gt;0x1234&lt;/code&gt;，但该地址只是进程的逻辑地址空间中的一部分。&lt;/p&gt;</description>
      <content:encoded><![CDATA[<p><strong><a href="%e4%bd%9c%e4%b8%9a2.pdf" target="_blank">点此查看作业源文件</a>
</strong></p>
<h1 id="1-动态内存分配需要对内存分区进行管理一般使用位图和空闲链表两种方法128mb的内存以n字节为单元分配对于链表假设内存中数据段和空闲区交替排列长度均为64kb并假设链表中的每个节点需要记录32位的内存地址信息16位长度信息和16位下一节点域信息这两种方法分别需要多少字节的存储空间哪种方法更好">1. 动态内存分配需要对内存分区进行管理，一般使用位图和空闲链表两种方法。128MB的内存以n字节为单元分配，对于链表，假设内存中数据段和空闲区交替排列，长度均为64KB。并假设链表中的每个节点需要记录32位的内存地址信息、16位长度信息和16位下一节点域信息。这两种方法分别需要多少字节的存储空间？哪种方法更好？</h1>
<ul>
<li>若使用位图方法：</li>
</ul>
$$单元数 = \frac{128MB}{nB} = \frac{2^{27}}{n}块$$$$所需存储空间 = \frac{2^{27}}{n}b = \frac{16}{n}MB$$<ul>
<li>若使用空闲链表方法：</li>
</ul>
$$段数=\frac{128MB}{64KB+64KB} = 2^{10}段$$$$所需存储空间 = 2^{10} \times (32 + 16 + 16)b = 8KB$$<ul>
<li>哪种方法更好：
<ul>
<li>当n&lt;2048时，空闲链表所需存储空间更小，空闲链表方法更好；</li>
<li>当n&gt;2048时，位图所需存储空间更小，位图方法更好。</li>
</ul>
</li>
</ul>
<h1 id="2-在一个交换系统中按内存地址排列的空闲区大小是-10kb4kb20kb18kb7kb9kb12kb和15kb对于连续的段请求12kb10kb9kb使用firstfitbestfitworstfit和nextfit将找出哪些空闲区">2. 在一个交换系统中，按内存地址排列的空闲区大小是: 10KB、4KB、20KB、18KB、7KB、9KB、12KB和15KB。对于连续的段请求：12KB、10KB、9KB。使用FirstFit、BestFit、WorstFit和NextFit将找出哪些空闲区？</h1>
<table>
  <thead>
      <tr>
          <th>段请求</th>
          <th>FirstFit</th>
          <th>BestFit</th>
          <th>WorstFit</th>
          <th>NextFit</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>12KB</strong></td>
          <td>20KB</td>
          <td>12KB</td>
          <td>20KB</td>
          <td>20KB</td>
      </tr>
      <tr>
          <td><strong>10KB</strong></td>
          <td>10KB</td>
          <td>10KB</td>
          <td>18KB</td>
          <td>18KB</td>
      </tr>
      <tr>
          <td><strong>9KB</strong></td>
          <td>18KB</td>
          <td>9KB</td>
          <td>15KB</td>
          <td>9KB</td>
      </tr>
  </tbody>
</table>
<h1 id="3-解释逻辑地址物理地址地址映射并举例说明">3. 解释逻辑地址、物理地址、地址映射，并举例说明。</h1>
<ol>
<li>
<p>逻辑地址（Logical Address）：
逻辑地址是程序运行时由 CPU 生成的地址，也称为虚拟地址。用户进程只能访问逻辑地址，不能直接访问物理内存。<br>
例如某程序访问地址 <code>0x1234</code>，但该地址只是进程的逻辑地址空间中的一部分。</p>
</li>
<li>
<p>物理地址（Physical Address）：<br>
物理地址是实际存在于内存（RAM）中的地址，由操作系统和硬件管理。<br>
例子： 逻辑地址 <code>0x1234</code> 可能被映射到物理内存的 <code>0xABCD1234</code>。</p>
</li>
<li>
<p>地址映射（Address Mapping）：<br>
地址映射是逻辑地址到物理地址的转换过程，通常由MMU通过分页、分段、段页结合等方式完成。
例子： 在分页系统中，逻辑地址 <code>0x1234</code> 可能属于页号2，页内偏移 <code>0x034</code>，MMU 通过页表找到物理页框5，映射后的物理地址为 <code>0x5034</code>。</p>
</li>
</ol>
<h1 id="4-解释页式段式存储管理中为什么要设置页段表和快表简述页式段式地址转换过程">4. 解释页式（段式）存储管理中为什么要设置页（段）表和快表，简述页式（段式）地址转换过程。</h1>
<ol>
<li>
<p>为什么要设置页（段）表和快表</p>
<ul>
<li>页表（段表）：用于记录逻辑地址到物理地址的映射关系，存储完整的映射信息，保证进程可以正确访问物理内存。</li>
<li>快表：是一种高速缓存，用于存储最近访问的页（段）表项，加速地址转换，提高地址转换效率，减少访问内存的开销。</li>
</ul>
</li>
<li>
<p>页式存储管理的地址转换过程</p>
<ol>
<li>CPU 生成逻辑地址，包含页号和页内偏移。</li>
<li>查询 TLB，如果页号在 TLB 中，则直接获取对应的物理页框号，得到物理地址。</li>
<li>若TLB 未命中（缺页表项），需要访问页表，通过页号查找对应的物理页框号。</li>
<li>组合物理页框号和页内偏移，形成物理地址，访问数据。</li>
<li>更新 TLB（如果 TLB 未命中，则将新查找的页表项加入 TLB）。</li>
</ol>
</li>
<li>
<p>段式存储管理的地址转换过程</p>
<ol>
<li>CPU 生成逻辑地址，包含段号和段内偏移。</li>
<li>查询 TLB，如果段号在 TLB 中，则直接获取段的基址，计算物理地址。</li>
<li>若TLB 未命中，访问段表，查找段号对应的段基址和段界限。</li>
<li>检查越界，如果段内偏移&gt;段界限，发生段越界异常，否则继续计算。</li>
<li>物理地址 = 段基址 + 段内偏移，然后访问数据。</li>
<li>更新 TLB（如果 TLB 未命中，则将新的段表项加入 TLB）。</li>
</ol>
</li>
</ol>
<h1 id="5-叙述缺页中断的处理流程">5. 叙述缺页中断的处理流程。</h1>
<p>缺页中断发生在进程访问的页面不在内存时，系统需要从外存加载该页面到内存。处理流程如下：</p>
<ol>
<li>
<p>产生缺页中断</p>
<ul>
<li>进程访问某个逻辑地址，CPU 通过页表查找对应的物理页框。</li>
<li>如果该页表项无效（页不在内存），则触发缺页中断。</li>
</ul>
</li>
<li>
<p>保存进程状态</p>
<ul>
<li>CPU 保存当前进程的上下文，包括程序计数器（PC）和寄存器等，确保中断后能恢复执行。</li>
</ul>
</li>
<li>
<p>操作系统处理缺页</p>
<ul>
<li>查找页表：操作系统检查该页是否有效。
<ul>
<li>有效但不在内存 → 继续处理。</li>
<li>非法访问 → 触发异常（如段错误），终止进程。</li>
</ul>
</li>
<li>选择物理页框：
<ul>
<li>若有空闲页框，直接使用。</li>
<li>若内存已满，使用页面置换算法（如 FIFO、LRU）淘汰一个旧页面。</li>
</ul>
</li>
</ul>
</li>
<li>
<p>读取页面到内存</p>
<ul>
<li>从外存（如磁盘）读取所需页面，拷贝到选定的物理页框。</li>
</ul>
</li>
<li>
<p>更新页表和 TLB</p>
<ul>
<li>修改页表项，标记该页已在内存，并更新页框号。</li>
<li>若该页表项在 TLB（快表）中，需更新或清除 TLB 旧项，保证地址转换正确。</li>
</ul>
</li>
<li>
<p>恢复进程执行</p>
<ul>
<li>恢复进程上下文，重新执行触发缺页的指令。</li>
<li>由于该页已加载到内存，不会再次触发缺页中断。</li>
</ul>
</li>
</ol>
<h1 id="6-假设一个机器有38位的虚拟地址和32位的物理地址">6. 假设一个机器有38位的虚拟地址和32位的物理地址。</h1>
<h2 id="1-与一级页表相比多级页表的主要优点是什么">(1) 与一级页表相比，多级页表的主要优点是什么？</h2>
<ul>
<li>空间利用率高。多级页表只在需要时分配低层页表，从而避免为整个虚拟地址空间都预留大量连续的页表空间，节省内存空间。</li>
</ul>
<h2 id="2如果使用二级页表页面大小为16kb每个页表项有4个字节应该为虚拟地址中的第一级和第二级页表域各分配多少位">(2) 如果使用二级页表，页面大小为16KB，每个页表项有4个字节。应该为虚拟地址中的第一级和第二级页表域各分配多少位？</h2>
<p>页面大小为 16KB，即</p>
$$16\,\text{KB} = 16 \times 1024 = 2^{14}\,\text{字节}$$<p>因此页内偏移需要 14 位，虚拟地址结构如下：</p>
$$\underbrace{\text{第一级页表域}}_{x\,\text{位}}\,\,\underbrace{\text{第二级页表域}}_{y\,\text{位}}\,\,\underbrace{\text{页内偏移}}_{14\,\text{位}}$$<p>虚拟地址为38位，因此$x + y + 14 = 38位$，所以$x + y = 24,\text{位}$。</p>
<p>每个页表项为4B，页表页的大小与页面大小相同，即16KB。一个页表页能容纳的页表项个数为</p>
$$\frac{16\,\text{KB}}{4\,\text{B}} = 4096 = 2^{12}\,\text{项}$$<p>因此第二级页表的索引域需要12位，即$y=12$。</p>
<p>由$x+y=24$可得$x=12$。即：</p>
$$\underbrace{\text{第一级页表域}}_{12\,\text{位}}\,\,\underbrace{\text{第二级页表域}}_{12\,\text{位}}\,\,\underbrace{\text{页内偏移}}_{14\,\text{位}}$$<h1 id="7-假设页面的访问存在一定的周期性循环但周期之间会随机出现一些页面的访问例如012511431012511332012511等请思考">7. 假设页面的访问存在一定的周期性循环，但周期之间会随机出现一些页面的访问。例如：0,1,2…,511,431,0,1,2…511,332,0,1,2,…,511等。请思考：</h1>
<h2 id="1lrufifo和clock算法的效果如何">(1) LRU、FIFO和Clock算法的效果如何？</h2>
<p>如果物理页框数不足512个，三种算法会发生相同的几乎全部缺页问题。</p>
<h2 id="2如果有500个页框能否设计一个优于lrufifo和clock的算法">(2) 如果有500个页框，能否设计一个优于LRU、FIFO和Clock的算法？</h2>
<p>其中499个页框对应存储0-498页，第500个页框用于置换。</p>
<h1 id="8-一个交换系统通过紧缩技术来清理碎片如果内存碎片和数据区域是随机分配的而且假设读写32位内存字需要10nsec-那么如果紧缩128mb的内存需要多久简单起见假设第0个字是碎片的一部分而最高位的字包含了有效的数据">8. 一个交换系统通过紧缩技术来清理碎片。如果内存碎片和数据区域是随机分配的。而且假设读写32位内存字需要10nsec. 那么如果紧缩128MB的内存需要多久？简单起见，假设第0个字是碎片的一部分而最高位的字包含了有效的数据。</h1>
$$128MB=\frac{128\times 2^{23}b}{32b/word} = 2^{25}words$$$$T=2^{25}words \times (10ns/word + 10ns/word) = 6.711\times 10^8ns = 0.6711s$$<p>需要约$0.6711s$。</p>
]]></content:encoded>
    </item>
    <item>
      <title>[BUAA-OS] Lab 1 实验报告</title>
      <link>https://oNya685.github.io/posts/buaa/os/lab-1-report/</link>
      <pubDate>Fri, 28 Mar 2025 10:06:33 +0800</pubDate>
      <guid>https://oNya685.github.io/posts/buaa/os/lab-1-report/</guid>
      <description>&lt;h1 id=&#34;一思考题&#34;&gt;一、思考题&lt;/h1&gt;
&lt;h2 id=&#34;thinking-11&#34;&gt;Thinking 1.1&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;在阅读附录中的编译链接详解以及本章内容后，尝试分别使用实验环境中的原生x86工具链（gcc、ld、readelf、objdump等）和MIPS交叉编译工具链（带有mips-linux-gnu-前缀，如mips-linux-gnu-gcc、mips-linux-gnu-ld），重复其中的编译和解析过程，观察相应的结果，并解释其中向objdump传入的参数的含义。&lt;/p&gt;</description>
      <content:encoded><![CDATA[<h1 id="一思考题">一、思考题</h1>
<h2 id="thinking-11">Thinking 1.1</h2>
<blockquote>
<p>在阅读附录中的编译链接详解以及本章内容后，尝试分别使用实验环境中的原生x86工具链（gcc、ld、readelf、objdump等）和MIPS交叉编译工具链（带有mips-linux-gnu-前缀，如mips-linux-gnu-gcc、mips-linux-gnu-ld），重复其中的编译和解析过程，观察相应的结果，并解释其中向objdump传入的参数的含义。</p></blockquote>
<hr>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>git@23373270:~/test $  gcc -E hello.c &gt; gcc-E.out
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># gcc-E.out:</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>...<span style="color:#f92672">(</span>&lt;stdio.h&gt;的内容<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 2 &#34;hello.c&#34; 2</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 3 &#34;hello.c&#34;</span>
</span></span><span style="display:flex;"><span>int main<span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    printf<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;Hello World!\n&#34;</span><span style="color:#f92672">)</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> 0;
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>git@23373270:~/test $  mips-linux-gnu-gcc -E hello.c &gt; mips-gcc-E.out
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># mips-gcc-E.out:</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>...<span style="color:#f92672">(</span>&lt;stdio.h&gt;的内容<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 2 &#34;hello.c&#34; 2</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 3 &#34;hello.c&#34;</span>
</span></span><span style="display:flex;"><span>int main<span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    printf<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;Hello World!\n&#34;</span><span style="color:#f92672">)</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> 0;
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><p>进行预处理的情况下，两者几乎没有区别。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>git@23373270:~/test $  gcc -c hello.c
</span></span><span style="display:flex;"><span>git@23373270:~/test $  objdump -DS hello.o &gt; objdump-DS.out
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># objdump-DS.out:</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>hello.o：     文件格式 elf64-x86-64
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Disassembly of section .text:
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">0000000000000000</span> &lt;main&gt;:
</span></span><span style="display:flex;"><span>   0:   f3 0f 1e fa             endbr64
</span></span><span style="display:flex;"><span>   4:   <span style="color:#ae81ff">55</span>                      push   %rbp
</span></span><span style="display:flex;"><span>   5:   <span style="color:#ae81ff">48</span> <span style="color:#ae81ff">89</span> e5                mov    %rsp,%rbp
</span></span><span style="display:flex;"><span>   8:   <span style="color:#ae81ff">48</span> 8d <span style="color:#ae81ff">05</span> <span style="color:#ae81ff">00</span> <span style="color:#ae81ff">00</span> <span style="color:#ae81ff">00</span> <span style="color:#ae81ff">00</span>    lea    0x0<span style="color:#f92672">(</span>%rip<span style="color:#f92672">)</span>,%rax        <span style="color:#75715e"># f &lt;main+0xf&gt;</span>
</span></span><span style="display:flex;"><span>   f:   <span style="color:#ae81ff">48</span> <span style="color:#ae81ff">89</span> c7                mov    %rax,%rdi
</span></span><span style="display:flex;"><span>  12:   e8 <span style="color:#ae81ff">00</span> <span style="color:#ae81ff">00</span> <span style="color:#ae81ff">00</span> <span style="color:#ae81ff">00</span>          call   <span style="color:#ae81ff">17</span> &lt;main+0x17&gt;
</span></span><span style="display:flex;"><span>  17:   b8 <span style="color:#ae81ff">00</span> <span style="color:#ae81ff">00</span> <span style="color:#ae81ff">00</span> <span style="color:#ae81ff">00</span>          mov    $0x0,%eax
</span></span><span style="display:flex;"><span>  1c:   5d                      pop    %rbp
</span></span><span style="display:flex;"><span>  1d:   c3                      ret
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Disassembly of section .rodata:
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">0000000000000000</span> &lt;.rodata&gt;:
</span></span><span style="display:flex;"><span>...
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Disassembly of section .comment:
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">0000000000000000</span> &lt;.comment&gt;:
</span></span><span style="display:flex;"><span>...
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Disassembly of section .note.gnu.property:
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">0000000000000000</span> &lt;.note.gnu.property&gt;:
</span></span><span style="display:flex;"><span>...
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Disassembly of section .eh_frame:
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">0000000000000000</span> &lt;.eh_frame&gt;:
</span></span><span style="display:flex;"><span>...
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>git@23373270:~/test $  mips-linux-gnu-gcc -c hello.c
</span></span><span style="display:flex;"><span>git@23373270:~/test $  mips-linux-gnu-objdump -DS hello.o &gt; mips-objdump-DS.out
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># mips-objdump-DS.out:</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>hello.o：     文件格式 elf32-tradbigmips
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Disassembly of section .text:
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">00000000</span> &lt;main&gt;:
</span></span><span style="display:flex;"><span>   0:   27bdffe0        addiu   sp,sp,-32
</span></span><span style="display:flex;"><span>   4:   afbf001c        sw      ra,28<span style="color:#f92672">(</span>sp<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>   8:   afbe0018        sw      s8,24<span style="color:#f92672">(</span>sp<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>   c:   03a0f025        move    s8,sp
</span></span><span style="display:flex;"><span>  10:   3c1c0000        lui     gp,0x0
</span></span><span style="display:flex;"><span>  14:   279c0000        addiu   gp,gp,0
</span></span><span style="display:flex;"><span>  18:   afbc0010        sw      gp,16<span style="color:#f92672">(</span>sp<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>  1c:   3c020000        lui     v0,0x0
</span></span><span style="display:flex;"><span>  20:   <span style="color:#ae81ff">24440000</span>        addiu   a0,v0,0
</span></span><span style="display:flex;"><span>  24:   8f820000        lw      v0,0<span style="color:#f92672">(</span>gp<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>  28:   0040c825        move    t9,v0
</span></span><span style="display:flex;"><span>  2c:   0320f809        jalr    t9
</span></span><span style="display:flex;"><span>  30:   <span style="color:#ae81ff">00000000</span>        nop
</span></span><span style="display:flex;"><span>  34:   8fdc0010        lw      gp,16<span style="color:#f92672">(</span>s8<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>  38:   <span style="color:#ae81ff">00001025</span>        move    v0,zero
</span></span><span style="display:flex;"><span>  3c:   03c0e825        move    sp,s8
</span></span><span style="display:flex;"><span>  40:   8fbf001c        lw      ra,28<span style="color:#f92672">(</span>sp<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>  44:   8fbe0018        lw      s8,24<span style="color:#f92672">(</span>sp<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>  48:   27bd0020        addiu   sp,sp,32
</span></span><span style="display:flex;"><span>  4c:   03e00008        jr      ra
</span></span><span style="display:flex;"><span>  50:   <span style="color:#ae81ff">00000000</span>        nop
</span></span><span style="display:flex;"><span>        ...
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Disassembly of section .reginfo:
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">00000000</span> &lt;.reginfo&gt;:
</span></span><span style="display:flex;"><span>...
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Disassembly of section .MIPS.abiflags:
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">00000000</span> &lt;.MIPS.abiflags&gt;:
</span></span><span style="display:flex;"><span>...
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Disassembly of section .pdr:
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">00000000</span> &lt;.pdr&gt;:
</span></span><span style="display:flex;"><span>...
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Disassembly of section .rodata:
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">00000000</span> &lt;.rodata&gt;:
</span></span><span style="display:flex;"><span>...
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Disassembly of section .comment:
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">00000000</span> &lt;.comment&gt;:
</span></span><span style="display:flex;"><span>...
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Disassembly of section .gnu.attributes:
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">00000000</span> &lt;.gnu.attributes&gt;:
</span></span><span style="display:flex;"><span>...
</span></span></code></pre></div><p>只编译不链接，生成目标文件，发现被编译为不同的汇编语言，且分别为64位和32位。</p>
<p>其中向<code>objdump</code>传入参数<code>-D</code>和<code>-S</code>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>git@23373270:~/test $  objdump --help
</span></span><span style="display:flex;"><span>    -D, --disassemble-all    Display assembler contents of all sections
</span></span><span style="display:flex;"><span>    -S, --source             Intermix source code with disassembly
</span></span></code></pre></div><p><code>-D</code>：显示所有段的汇编内容
<code>-S</code>：将源代码与反汇编代码混合显示</p>
<h2 id="thinking-12">Thinking 1.2</h2>
<blockquote>
<p>思考下述问题：</p>
<ul>
<li>尝试使用我们编写的readelf程序，解析之前在target目录下生成的内核ELF文件。</li>
<li>也许你会发现我们编写的readelf程序是不能解析readelf文件本身的，而我们刚才介绍的系统工具readelf则可以解析，这是为什么呢？（提示：尝试使用readelf -h，并阅读tools/readelf目录下的Makefile，观察readelf与hello的不同）</li>
</ul></blockquote>
<hr>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>git@23373270:~/23373270 <span style="color:#f92672">(</span>lab1<span style="color:#f92672">)</span>$  tools/readelf/readelf target/mos
</span></span><span style="display:flex;"><span>0:0x0
</span></span><span style="display:flex;"><span>1:0x80020000
</span></span><span style="display:flex;"><span>2:0x80021930
</span></span><span style="display:flex;"><span>3:0x80021948
</span></span><span style="display:flex;"><span>4:0x80021960
</span></span><span style="display:flex;"><span>5:0x0
</span></span><span style="display:flex;"><span>6:0x0
</span></span><span style="display:flex;"><span>7:0x0
</span></span><span style="display:flex;"><span>8:0x0
</span></span><span style="display:flex;"><span>9:0x0
</span></span><span style="display:flex;"><span>10:0x0
</span></span><span style="display:flex;"><span>11:0x0
</span></span><span style="display:flex;"><span>12:0x0
</span></span><span style="display:flex;"><span>13:0x0
</span></span><span style="display:flex;"><span>14:0x0
</span></span><span style="display:flex;"><span>15:0x0
</span></span><span style="display:flex;"><span>16:0x0
</span></span><span style="display:flex;"><span>17:0x0
</span></span><span style="display:flex;"><span>18:0x0
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>git@23373270:~/23373270/tools/readelf <span style="color:#f92672">(</span>lab1<span style="color:#f92672">)</span>$  readelf -h readelf
</span></span><span style="display:flex;"><span>ELF 头：
</span></span><span style="display:flex;"><span>  Magic：   7f <span style="color:#ae81ff">45</span> 4c <span style="color:#ae81ff">46</span> <span style="color:#ae81ff">02</span> <span style="color:#ae81ff">01</span> <span style="color:#ae81ff">01</span> <span style="color:#ae81ff">00</span> <span style="color:#ae81ff">00</span> <span style="color:#ae81ff">00</span> <span style="color:#ae81ff">00</span> <span style="color:#ae81ff">00</span> <span style="color:#ae81ff">00</span> <span style="color:#ae81ff">00</span> <span style="color:#ae81ff">00</span> <span style="color:#ae81ff">00</span>
</span></span><span style="display:flex;"><span>  类别:                              ELF64
</span></span><span style="display:flex;"><span>  数据:                              <span style="color:#ae81ff">2</span> 补码，小端序 <span style="color:#f92672">(</span>little endian<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>  Version:                           <span style="color:#ae81ff">1</span> <span style="color:#f92672">(</span>current<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>  OS/ABI:                            UNIX - System V
</span></span><span style="display:flex;"><span>  ABI 版本:                          <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>  类型:                              DYN <span style="color:#f92672">(</span>Position-Independent Executable file<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>  系统架构:                          Advanced Micro Devices X86-64
</span></span><span style="display:flex;"><span>  版本:                              0x1
</span></span><span style="display:flex;"><span>  入口点地址：               0x1180
</span></span><span style="display:flex;"><span>  程序头起点：          <span style="color:#ae81ff">64</span> <span style="color:#f92672">(</span>bytes into file<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>  Start of section headers:          <span style="color:#ae81ff">14488</span> <span style="color:#f92672">(</span>bytes into file<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>  标志：             0x0
</span></span><span style="display:flex;"><span>  Size of this header:               <span style="color:#ae81ff">64</span> <span style="color:#f92672">(</span>bytes<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>  Size of program headers:           <span style="color:#ae81ff">56</span> <span style="color:#f92672">(</span>bytes<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>  Number of program headers:         <span style="color:#ae81ff">13</span>
</span></span><span style="display:flex;"><span>  Size of section headers:           <span style="color:#ae81ff">64</span> <span style="color:#f92672">(</span>bytes<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>  Number of section headers:         <span style="color:#ae81ff">31</span>
</span></span><span style="display:flex;"><span>  Section header string table index: <span style="color:#ae81ff">30</span>
</span></span></code></pre></div><p>观察<code>tools/readelf/Makefile</code>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>readelf: main.o readelf.o
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">$(</span>CC<span style="color:#66d9ef">)</span> $^ -o $@
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>hello: hello.c
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">$(</span>CC<span style="color:#66d9ef">)</span> $^ -o $@ -m32 -static -g
</span></span></code></pre></div><p>区别在于<code>hello</code>为32位程序，<code>readelf</code>是64位程序，且<code>hello</code>的编译有<code>-static</code>修饰，是静态链接的。</p>
<h2 id="thinking-13">Thinking 1.3</h2>
<blockquote>
<p>在理论课上我们了解到，MIPS体系结构上电时，启动入口地址为0xBFC00000（其实启动入口地址是根据具体型号而定的，由硬件逻辑确定，也有可能不是这个地址，但一定是一个确定的地址），但实验操作系统的内核入口并没有放在上电启动地址，而是按照内存布局图放置。思考为什么这样放置内核还能保证内核入口被正确跳转到？
（提示：思考实验中启动过程的两阶段分别由谁执行。）</p></blockquote>
<hr>
<p>系统能够正确跳转到内核入口在于两阶段启动过程和链接脚本控制：</p>
<ol>
<li>
<p>启动阶段划分</p>
<ul>
<li>阶段一：硬件上电后执行固化在 ROM 中的代码（地址 0xBFC00000）</li>
<li>阶段二：Bootloader 加载操作系统内核到指定内存地址</li>
</ul>
</li>
<li>
<p>链接脚本控制（kernel.lds）</p>
</li>
</ol>
<pre tabindex="0"><code class="language-ld" data-lang="ld">/*
 * Set the ENTRY point of the program to _start.
 */
ENTRY(_start)

SECTIONS {
    . = 0x80020000;
    .text : { *(.text) }
	...
}
</code></pre><ol start="3">
<li>入口地址设置（start.S）</li>
</ol>
<pre tabindex="0"><code class="language-mips" data-lang="mips">#include &lt;asm/asm.h&gt;
#include &lt;mmu.h&gt;

.text
EXPORT(_start)
.set at
.set reorder
/* Lab 1 Key Code &#34;enter-kernel&#34; */
    /* clear .bss segment */
    la      v0, bss_start
    la      v1, bss_end
    ...
    j       mips_init
</code></pre><p>实现原理：</p>
<ol>
<li>Bootloader 将内核镜像加载到链接脚本指定的内存地址（0x80020000）</li>
<li>通过<code>ENTRY(_start)</code>指定内核入口符号</li>
<li>汇编代码中 <code>_start</code> 符号通过绝对跳转指令（<code>j mips_init</code>）转移到内核主函数</li>
</ol>
<h1 id="二难点分析与实验体会">二、难点分析与实验体会</h1>
<h2 id="1-elf文件">1. ELF文件</h2>
<p><div class="post-img-view">
    <a data-fancybox="gallery"
         href="Pasted%20image%2020250328172841.png">
        <img loading="lazy" src="/posts/buaa/os/lab-1-report/Pasted%20image%2020250328172841_hu_42ee11080f61b4c9.webp">
    </a>
</div></p>
<p>对ELF文件的概念缺少理解，写完<code>readelf</code>实际使用后才理解其含义。</p>
<h1 id="三原创说明">三、原创说明</h1>
<p>本以为是<code>readelf</code>在运行时无法读取自己，是因为自己正在运行导致的无法读取。在与赵德祥同学讨论后才注意到<code>readelf</code>与<code>hello</code>在64位和32位上的区别，在此致谢。</p>
]]></content:encoded>
    </item>
    <item>
      <title>迟早会想不出标题的吧</title>
      <link>https://oNya685.github.io/posts/ramble/250322/</link>
      <pubDate>Sat, 22 Mar 2025 16:35:04 +0800</pubDate>
      <guid>https://oNya685.github.io/posts/ramble/250322/</guid>
      <description>&lt;p&gt;也有考虑过要不要把原来的内容搬过来，但好像原来的内容也没有多大价值。&lt;/p&gt;
&lt;p&gt;给Ramble下的内容都改为了随时更新随时发布，不得不说的是图片太大已经成为hugo build和push的阻碍了，这样继续下去迟早会卡顿的，今后只对增量作编译了。&lt;/p&gt;</description>
      <content:encoded><![CDATA[<p>也有考虑过要不要把原来的内容搬过来，但好像原来的内容也没有多大价值。</p>
<p>给Ramble下的内容都改为了随时更新随时发布，不得不说的是图片太大已经成为hugo build和push的阻碍了，这样继续下去迟早会卡顿的，今后只对增量作编译了。</p>
<p>不过写了一个自动同步webdav的脚本，这样以后就能随时看到渲染后的网页了，hugo server也不需要关了。这样倒是方便不少。</p>
<p>专开一栏写Cook，底本是一个<a href="https://cook.aiursoft.cn/" target="_blank">有趣的项目</a>
！</p>
<hr>
<p>有想到人与搜索引擎的交互，尤其是历史记录，一般是天然的版本树，或者说因为有环的存在，可能更像图？或许是一个不错的创业项目，赚不着钱的那种，不过想到就很感兴趣，可能具体实现时很多功能（脏活累活）还得要靠AI来干，小型AI未来可期</p>
<p>想起来某学长记录的陈震的讲座概要，他预测的几个风口与稚晖君去花了好久在干的方向几乎一致。</p>
]]></content:encoded>
    </item>
    <item>
      <title>[BUAA-OO] Unit 1 总结</title>
      <link>https://oNya685.github.io/posts/buaa/oo/unit-1/summary/</link>
      <pubDate>Sat, 22 Mar 2025 14:16:55 +0800</pubDate>
      <guid>https://oNya685.github.io/posts/buaa/oo/unit-1/summary/</guid>
      <description>第一单元博客作业</description>
      <content:encoded><![CDATA[<h1 id="架构简介">架构简介</h1>
<p>在本单元中，作业要求我们对提供了<strong>形式化表述</strong>的复杂表达式进行<strong>解析和化简</strong>，并要求尽可能简短的输出以度量性能分数。</p>
<p>而经过三次作业迭代（其中包含一次重构），最终架构设计图如下：</p>
<p><div class="post-img-view">
    <a data-fancybox="gallery"
         href="UML.png">
        <img loading="lazy" src="/posts/buaa/oo/unit-1/summary/UML_hu_c7d81f24e8d7bd9b.webp">
    </a>
</div></p>
<p>核心处理部分在于递归解析模块的两个递归，在图中具体表现为两个圈。接下来介绍和分析各模块的结构。</p>
<h2 id="主线处理">主线处理</h2>
<p><div class="post-img-view">
    <a data-fancybox="gallery"
         href="%E4%B8%BB%E7%BA%BF%E6%B5%81%E7%A8%8B.png">
        <img alt="主线处理" loading="lazy" src="/posts/buaa/oo/unit-1/summary/%E4%B8%BB%E7%BA%BF%E6%B5%81%E7%A8%8B_hu_50ee1355f57dc9d.webp">
    </a>
</div></p>
<p>本模块是整个项目的主体部分，其中箭头含义表示流程顺序，不代表类的继承关系。主要流程呈现为main方法：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>String input <span style="color:#f92672">=</span> scanner.<span style="color:#a6e22e">nextLine</span>();  <span style="color:#75715e">// 读入</span>
</span></span><span style="display:flex;"><span>Lexer lexer <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Lexer(input.<span style="color:#a6e22e">replaceAll</span>(<span style="color:#e6db74">&#34; &#34;</span>, <span style="color:#e6db74">&#34;&#34;</span>).<span style="color:#a6e22e">replaceAll</span>(<span style="color:#e6db74">&#34;\t&#34;</span>, <span style="color:#e6db74">&#34;&#34;</span>));          <span style="color:#75715e">// 词法解析</span>
</span></span><span style="display:flex;"><span>Parser parser <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Parser(lexer);  <span style="color:#75715e">// 传入Tokens</span>
</span></span><span style="display:flex;"><span>System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(parser  
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">parseExpr</span>()                    <span style="color:#75715e">// 语法解析</span>
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">assign</span>(<span style="color:#66d9ef">null</span>)                   <span style="color:#75715e">// 赋值处理函数调用</span>
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">toPoly</span>()                       <span style="color:#75715e">// 计算化简</span>
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">Print</span>()                        <span style="color:#75715e">// 构造StringBuilder</span>
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">toString</span>());                   <span style="color:#75715e">// 输出结果</span>
</span></span></code></pre></div><p>这样类似<strong>流水线</strong>的设计的优点是显而易见的，我们只需写好每一模块，封装成<strong>黑盒</strong>，确保每一部分的程序正确性，就可以完整实现所需功能。</p>
<p>然而，见上面整体图可以看出，除了实现核心功能的解析模块，其余部分的<strong>耦合度</strong>其实是偏高的。</p>
<p><div class="post-img-view">
    <a data-fancybox="gallery"
         href="Pasted%20image%2020250321102634.png">
        <img alt="Method Metrics" loading="lazy" src="/posts/buaa/oo/unit-1/summary/Pasted%20image%2020250321102634_hu_e1b1a3fedae6e702.webp">
    </a>
</div></p>
<p><div class="post-img-view">
    <a data-fancybox="gallery"
         href="Pasted%20image%2020250321102951.png">
        <img alt="Class Metrics" loading="lazy" src="/posts/buaa/oo/unit-1/summary/Pasted%20image%2020250321102951_hu_12bd78d8e3f53682.webp">
    </a>
</div></p>
<p>我们会发现，<code>Lexer</code>, <code>Parser</code>, <code>Poly</code>这几个在主线中实现了相当一部分功能的类，因为把大量的<strong>重复性</strong>功能藏在一个类甚至一个方法内部实现（例如Lexer的大量if-else出现了控制分支数目大的问题），出现了耦合度过高、可读性差的问题。</p>
<p>举例来说，我们可以分析这个只由两个类实现计算、化简、简化功能的模块：</p>
<h2 id="计算化简">计算化简</h2>
<p><div class="post-img-view">
    <a data-fancybox="gallery"
         href="%E8%AE%A1%E7%AE%97%E5%8C%96%E7%AE%80%E6%A8%A1%E5%9D%97.png">
        <img alt="计算化简" loading="lazy" src="/posts/buaa/oo/unit-1/summary/%E8%AE%A1%E7%AE%97%E5%8C%96%E7%AE%80%E6%A8%A1%E5%9D%97_hu_9a0ff4d29315da4b.webp">
    </a>
</div></p>
<p>这个模块内部实现了过多功能，方法个数多，方法规模大，只因它们都涉及到用于存储化简后输出结果的类——<code>Poly</code>（多项式）和<code>Mono</code>（单项式）——这就导致了这一部分难读、难拆、难拓展。</p>
<h2 id="递归解析">递归解析</h2>
<p>而与之相对的，由于有先导课程的最后一次作业的架构作参考，这个采用递归下降法解析和存储的模块有相当良好的可拓展性和低耦合度。</p>
<p><div class="post-img-view">
    <a data-fancybox="gallery"
         href="%E9%80%92%E5%BD%92%E8%A7%A3%E6%9E%90%E6%A8%A1%E5%9D%97.png">
        <img alt="递归解析" loading="lazy" src="/posts/buaa/oo/unit-1/summary/%E9%80%92%E5%BD%92%E8%A7%A3%E6%9E%90%E6%A8%A1%E5%9D%97_hu_94324e327feaacb4.webp">
    </a>
</div></p>
<p>这一模块的度量值相当良好，故省略去分析。这一部分的递归主要在于</p>
<ol>
<li><code>Expr</code> - <code>Term</code> - <code>&lt;Factor&gt; ExprFactor</code> - <code>Expr</code> （见橙色箭头）形成的环，该递归改编自先导课程作业代码。</li>
<li><code>Expr</code> - <code>Term</code> - <code>&lt;Factor&gt; &lt;VarFactor&gt; FuncCall</code> - <code>&lt;FuncDefine.exprs&gt; Expr</code> 。这一递归赋值处理函数调用的思路详见我在第二次作业中的<a href="http://oo.buaa.edu.cn/assignment/608/discussion/1656" target="_blank">讨论发帖</a>
，当然，在非校园网环境下，你也可以<a href="https://oNya685.github.io/posts/buaa/oo/unit-1/homework-2-function/" target="_blank">从此获取</a>
。这一设计有极好的可拓展性，我们将在下一节进一步讨论。</li>
</ol>
<h1 id="迭代成型">迭代成型</h1>
<h2 id="第一次作业">第一次作业</h2>
<p>通过采用先导课的递归下降设计，第一次作业的难点就主要在于计算与化简的部分了。此时我们埋下了直接导致需要重构的第一个雷，对于幂函数的处理，我没有完全参照形式化表述的思路，而是单独设计了一个类来表示幂函数，并于计算时再具体展开。</p>
<h2 id="第二次作业">第二次作业</h2>
<h3 id="重构形式化表述">重构：形式化表述</h3>
<p>重构前后的复杂度其实近似，故省去分析，但值得注意的是前后的架构设计：</p>
<p><div class="post-img-view">
    <a data-fancybox="gallery"
         href="%E9%87%8D%E6%9E%84%E5%AF%B9%E6%AF%94.png">
        <img loading="lazy" src="/posts/buaa/oo/unit-1/summary/%E9%87%8D%E6%9E%84%E5%AF%B9%E6%AF%94_hu_538427942ba17d30.webp">
    </a>
</div></p>
<p>其实都很明了，但最主要的区别其实是：<strong>重构后的类的设计完全符合了给出的形式化表述</strong>。第二次作业的迭代突然把形式化表述内容几乎翻倍不止，如果要沿着原来的架构像打补丁一样加上这大量的迭代内容，很可能最后根本写不完。</p>
<p>而重构后的迭代体验也大幅提升：我只需要无脑照抄形式化表述，就能写好解析器，设计好各个类，这不仅省下了时间，也直接跳过了大量与形式化表述不统一而可能引发的潜在的bug。</p>
<h3 id="另一个大任务是递归函数调用的处理">另一个大任务是递归函数调用的处理</h3>
<p>在得知该迭代需求后，我耗费了相当久的时间思考如何以合理、优雅的方式处理递归函数调用，最终设计的一套<a href="https://oNya685.github.io/posts/buaa/oo/unit-1/homework-2-function/" target="_blank">处理思路</a>
取得了相当好的<strong>可拓展性</strong>和相对低的耦合度，并结合<strong>动态规划</strong>和藏在其中的部分简化（例如，若某<code>ExprFactor</code>的<code>Expr</code>有且只有一个<code>Term</code>，该<code>Term</code>有且只有一个<code>Factor</code>，则该<code>ExprFactor</code>的简化方法返回该<code>Factor</code>，否则返回自身），实现了时间和空间上的大幅优化，并顺利解决掉了当<code>f{n}</code>的<code>n</code>过大时易爆栈的问题（事实上，事后发现课程组的Cost限制完全不足以超时或爆栈）。</p>
<h2 id="第三次作业">第三次作业</h2>
<p>虽说在第二次作业的互测里被打了不少次，理应来说，如果有继续迭代开发的需求，我会继续重构，并明确几点：</p>
<ul>
<li>对象属性是否<strong>可变</strong>，会用到返回值的各种方法除了返回值之外应不应该产生<strong>副作用</strong>，会不会错误得<strong>复用</strong>某对象。</li>
<li>明确哪些类需要重写<code>hashCode()</code>和<code>equals()</code>，这一点对于优化性能得分至关重要。</li>
<li>耦合度过高的<code>Poly</code>和<code>Mono</code>是肯定要拆的，怎么<strong>分解</strong>而能继续实现原有功能，怎么设计更适合迭代的<strong>架构</strong>，怎么给优化性能留位置等。</li>
</ul>
<p>但我并没有重构——第三次作业的需求很简单：</p>
<p>一是普通函数调用，我原设计的递归函数调用处理方法有相当的可拓展性，我甚至<strong>没有修改函数相关的类</strong>就轻松实现了该要求。</p>
<p>二是求导因子，但课程组给求导因子的限制过大，尤其是出现范围十分限定，因此我们只需在主线的流水线挑一个方便的环节（包括解析，运算，赋值，简化），附带上求导运算，就实现了。</p>
<p>所以为什么不重构？第二次作业虽然烂了点，但经过强侧和互测的检验，打完补丁就是能<strong>保障正确性</strong>的代码。重构意味着要重新面对潜在的bug，而在当前这一坨上作简单的迭代并没有显著难度，正确性也更有保障。因此，没有第二次重构。</p>
<h1 id="bug分析">Bug分析</h1>
<h2 id="诡异的hashmap">诡异的<code>HashMap</code></h2>
<p>这一bug并不是被测出来的：不解决这bug程序完全不能跑。这一单元里，大家都或多或少地与HashMap之类的容器或者hashCode等方法斗争了许久。至今我也不知道，除了新建一个容器往里塞，怎么遍历才能做到不报错。如果有下次，我可能选<code>.stream().map().collect()</code>。</p>
<h2 id="完全符合形式化表述但符合得不太完全">完全符合形式化表述，但符合得不太完全</h2>
<pre tabindex="0"><code>&lt;递推表达式&gt; → &lt;常数因子&gt; &lt;空白项&gt; &#39;*&#39; &lt;空白项&gt; &lt;自定义递推函数调用n-1&gt; &lt;空白项&gt; &lt;加减&gt; &lt;空白项&gt; &lt;常数因子&gt; &lt;空白项&gt; &#39;*&#39; &lt;空白项&gt; &lt;自定义递推函数调用n-2&gt; [&lt;空白项&gt; &#39;+&#39; &lt;空白项&gt; &lt;函数表达式&gt;]
</code></pre><p>虽然经过一次完全符合形式化表述的重构，但因为我的设计足以实现对函数调用的解析，所以我本以为递推表达式就是比较特殊的表达式，其实不然。这个<code>[&lt;空白项&gt; '+' &lt;空白项&gt; &lt;函数表达式&gt;]</code>的诡异的加号让<code>... + + + +1</code>这样的表述变成了可能。这一bug着实很坑，但也没有什么经验可总结。</p>
<h2 id="谁会在sin里套sinsin">谁会在<code>sin()</code>里套<code>sin()*sin()</code>？</h2>
<p>本以为第三次作业大家都差不多，互测更是全房 0 Hack，应该不会有bug了……吗？</p>
<p><div class="post-img-view">
    <a data-fancybox="gallery"
         href="Pasted%20image%2020250321193556.png">
        <img alt="Bug修复：最后一次Commit" loading="lazy" src="/posts/buaa/oo/unit-1/summary/Pasted%20image%2020250321193556_hu_28ecd893e0e44ae4.webp">
    </a>
</div></p>
<p>啊，输出了<code>sin(sin(...)*sin(...))</code>，但里面是一个表达式而非一个因子，所以应该是<code>sin((sin(...)*sin(...)))</code>。省去了不该省的括号。这个小bug从第二次作业互测测到第三次作业互测，都没有被测出来，第三次强测反倒测出来了，如果侥幸一点没测出来，这个bug可能永远都不会被发现了。</p>
<h2 id="当然也有喜闻乐见的">当然也有喜闻乐见的</h2>
<p>最喜欢分析的bug是别人的bug，在此稍加分析有参考意义的两例。</p>
<h3 id="extratriangle">extraTriangle!!!</h3>
<p><div class="post-img-view">
    <a data-fancybox="gallery"
         href="2007db7b678091ac411a41f40a2e1d2.jpg">
        <img loading="lazy" src="/posts/buaa/oo/unit-1/summary/2007db7b678091ac411a41f40a2e1d2_hu_7d7b277097085463.webp">
    </a>
</div></p>
<p><code>extraTriangle!!!</code>一位没删用于调试的输出信息的同学如是喊道。</p>
<p>这一bug值得分析是因为教会了我们设计一个调试开关，例如：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">// MainClass.java</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> Class MainClass {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">debug</span>() { <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">true</span>; }
</span></span><span style="display:flex;"><span>	...
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span>(String<span style="color:#f92672">[]</span> args) {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (MainClass.<span style="color:#a6e22e">debug</span>()) {
</span></span><span style="display:flex;"><span>			System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(<span style="color:#e6db74">&#34;Debug模式还没关，别看都不看就直接交了&#34;</span>);
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		...
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="可能复用的对象clone或谨防副作用">可能复用的对象，<code>clone()</code>或谨防副作用</h3>
<p>我用一个简单的函数，调用了<code>f{5}(x,x^2)</code>，就一次刀穿了三人（不过其中一人其实没错，他只是在喊<code>extraTriangle!!!</code>），仔细看看，竟与之前发现并修掉的bug如出一辙。有的时候，我们需要这个对象本身，有的时候，我们只是需要这个对象的值。</p>
<p>张三长大了一岁，无论是谁眼中的张三，都长大了一岁。有的时候，我们需要给张三拍照，把他当前的样子保留下来（或者是生成一个和当前的张三长得一样的克隆人）。问题就出在，可能A让张三长大了一岁，而B想给张三拍照时并没考虑到张三长大了一岁，拍下了不符合预期的照片。</p>
<p>我的解决方案是，A生成张三的克隆人，并把克隆人当成张三，后续让“张三”长大一岁，原来的张三就不会受到影响，B随时都可以给张三拍照拍到正确的样子。</p>
<h1 id="测试策略">测试策略</h1>
<p>看源代码还是太折磨了，只有第一次作业读代码来设计测试用例了，后来都找不到用正则解析的了，大家处理思路十分趋同，与其看代码，不如直接构造各类极端样例，进行盲测了。</p>
<p>当然不能直接用互测窗口测，CD太长；也不能开八个IDEA窗口挨个输入，效率太低；首先将八个压缩包编译生成八个jar包，然后用命令行批量处理，用文件实现读写，最后把大家的答案扔进优化得最好最稳定的同学的jar包，就能得到格式统一的输出了。当然这是不够严谨的做法，我们也可以采取python的一些妙妙工具，把输出的字符串里的x直接文本替换成各种刁钻的数值，评判输出的纯数字结果是不是相隔很小即可（理论上结果应该一模一样，但三角函数优化和浮点数带来的误差不可避免）。</p>
<h1 id="优化策略">优化策略</h1>
<p>前文已经提到了大部分的优化，因为实在无力处理三角函数的各种优化，且保住正确性分比贪性能分更稳妥。</p>
<p>现介绍前文未提到的两处优化：</p>
<h2 id="重写equals以合并同类项">重写<code>equals()</code>以合并同类项</h2>
<p>与之对应的，我们也要重写<code>hashCode()</code>以实现在HashMap中能找到该同类项。</p>
<p>这样我们就可以应对括号内的值<strong>存在关联性</strong>的三角函数之间的合并了。</p>
<h2 id="为返回值作顺带简化">为返回值作顺带简化</h2>
<p>例如前文提到的将<code>ExprFactor</code>返回其中仅有的<code>Factor</code>，可以一定程度上省去不必要的括号；又如<code>cos(0)</code>和<code>sin(0)</code>，可以直接返回具体数值。</p>
<h1 id="心得体会">心得体会</h1>
<p>虽然第三次作业的轻松要求确实减少了我们的工作量，让我直接放弃了第二次的重构，但我仍没能理解普通函数调用为什么会放在递归函数调用之后作为新要求迭代。第二次作业的任务量也着实有些惊悚，不知是传统还是失误。</p>
<p>总的来说，第一单元在先导课提供了参考架构的基础上还算顺利，也能明显感到有所收获，期待第二单元的灵异电梯。</p>
]]></content:encoded>
    </item>
    <item>
      <title>用Condition干掉notifyAll</title>
      <link>https://oNya685.github.io/posts/buaa/oo/unit-2/condition/</link>
      <pubDate>Mon, 17 Mar 2025 16:04:09 +0800</pubDate>
      <guid>https://oNya685.github.io/posts/buaa/oo/unit-2/condition/</guid>
      <description>介绍notify()与notifyAll()的区别，推荐ReentrantLock</description>
      <content:encoded><![CDATA[<p><code>synchronized</code>关键字修饰的局部代码块内，我们能通过<code>wait()</code>, <code>notify()</code>, <code>notifyAll()</code>方法来调控线程之间的协作。</p>
<h1 id="notify和notifyall是什么"><code>notify()</code>和<code>notifyAll()</code>是什么？</h1>
<p>我们先定义两个概念，一个是<strong>等待池</strong>，一个是<strong>锁池</strong>，它们都是随一个锁而形成的<strong>暂存线程</strong>的容器。具体来说：</p>
<p><strong>等待池</strong>中的线程只有被<strong>通知</strong>（notify）时，才会进入<strong>锁池</strong>；否则什么也不做。</p>
<p><strong>锁池</strong>中的线程会不断尝试<strong>抢锁</strong>，如果抢到了锁，会进入<code>synchronized</code>，从开头或上次离开的位置（通过wait离开时）继续执行。</p>
<p>当某线程尝试进入<code>synchronized</code>，即尝试<strong>抢锁</strong>，但<strong>失败</strong>了（因为有其他线程在占用这把锁）时，它会进入<strong>锁池</strong>，持续不断尝试抢锁。</p>
<p>当某线程<strong>抢锁成功</strong>，进入了<code>synchronized</code>，它会离开<strong>锁池</strong>。</p>
<p>当某线程进入了<code>synchronized</code>，并遵循程序的设计，执行了<code>wait()</code>方法，它会进入<strong>等待池</strong>。</p>
<p>当某线程在<code>synchronized</code>中执行了<code>notify()</code>方法，会从<strong>等待池</strong>中随机选取一个线程让其移动到<strong>锁池</strong>。</p>
<p>当某线程在<code>synchronized</code>中执行了<code>notifyAll()</code>方法，会将<strong>等待池</strong>中的所有线程移动到<strong>锁池</strong>。</p>
<h1 id="什么时候用notify什么时候用notifyall">什么时候用<code>notify()</code>，什么时候用<code>notifyAll</code>？</h1>
<h2 id="考虑某多线程任务">考虑某多线程任务</h2>
<p>假设我们有一个资源池，生产者线程向其中添加资源，消费者线程从中获取资源。我们需要确保生产者在资源池满时等待，消费者在资源池空时等待。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#f92672">import</span> java.util.LinkedList;
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> java.util.Queue;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">ResourcePool</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> Queue<span style="color:#f92672">&lt;</span>Object<span style="color:#f92672">&gt;</span> resources <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> LinkedList<span style="color:#f92672">&lt;&gt;</span>();
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">int</span> capacity;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">final</span> Object lock <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Object();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#a6e22e">ResourcePool</span>(<span style="color:#66d9ef">int</span> capacity) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">capacity</span> <span style="color:#f92672">=</span> capacity;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">rent</span>(Object resource) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">synchronized</span> (lock) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">while</span> (resources.<span style="color:#a6e22e">size</span>() <span style="color:#f92672">&gt;=</span> capacity) {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">try</span> {
</span></span><span style="display:flex;"><span>	                System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(<span style="color:#e6db74">&#34;生产者进入等待&#34;</span>);
</span></span><span style="display:flex;"><span>                    lock.<span style="color:#a6e22e">wait</span>(); <span style="color:#75715e">// 如果资源池已满，生产者等待</span>
</span></span><span style="display:flex;"><span>                } <span style="color:#66d9ef">catch</span> (InterruptedException e) {
</span></span><span style="display:flex;"><span>                    e.<span style="color:#a6e22e">printStackTrace</span>();
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>                System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(<span style="color:#e6db74">&#34;生产者被唤醒&#34;</span>);
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            resources.<span style="color:#a6e22e">add</span>(resource);
</span></span><span style="display:flex;"><span>            System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(<span style="color:#e6db74">&#34;生产者: 生产了一个资源, 当前资源数: &#34;</span> <span style="color:#f92672">+</span> resources.<span style="color:#a6e22e">size</span>());
</span></span><span style="display:flex;"><span>            lock.<span style="color:#a6e22e">notify</span>(); <span style="color:#75715e">// 唤醒等待的消费者线程</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> Object <span style="color:#a6e22e">consume</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">synchronized</span> (lock) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">while</span> (resources.<span style="color:#a6e22e">isEmpty</span>()) {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">try</span> {
</span></span><span style="display:flex;"><span>	                System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(<span style="color:#e6db74">&#34;消费者进入等待&#34;</span>);
</span></span><span style="display:flex;"><span>                    lock.<span style="color:#a6e22e">wait</span>(); <span style="color:#75715e">// 如果资源池为空，消费者等待</span>
</span></span><span style="display:flex;"><span>                } <span style="color:#66d9ef">catch</span> (InterruptedException e) {
</span></span><span style="display:flex;"><span>                    e.<span style="color:#a6e22e">printStackTrace</span>();
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>                System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(<span style="color:#e6db74">&#34;消费者被唤醒&#34;</span>);
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            Object resource <span style="color:#f92672">=</span> resources.<span style="color:#a6e22e">remove</span>();
</span></span><span style="display:flex;"><span>            System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(<span style="color:#e6db74">&#34;消费者: 消费了一个资源, 当前资源数: &#34;</span> <span style="color:#f92672">+</span> resources.<span style="color:#a6e22e">size</span>());
</span></span><span style="display:flex;"><span>            lock.<span style="color:#a6e22e">notify</span>(); <span style="color:#75715e">// 唤醒等待的生产者线程</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> resource;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Main</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span>(String<span style="color:#f92672">[]</span> args) {
</span></span><span style="display:flex;"><span>        ResourcePool pool <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> ResourcePool(1);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 借用者1</span>
</span></span><span style="display:flex;"><span>        Thread renter <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Thread(() <span style="color:#f92672">-&gt;</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 0; i <span style="color:#f92672">&lt;</span> 5; i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>                pool.<span style="color:#a6e22e">rent</span>();
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">try</span> {
</span></span><span style="display:flex;"><span>                    Thread.<span style="color:#a6e22e">sleep</span>(1000);
</span></span><span style="display:flex;"><span>                } <span style="color:#66d9ef">catch</span> (InterruptedException e) {
</span></span><span style="display:flex;"><span>                    e.<span style="color:#a6e22e">printStackTrace</span>();
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        });
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        producer.<span style="color:#a6e22e">start</span>();
</span></span><span style="display:flex;"><span>        consumer.<span style="color:#a6e22e">start</span>();
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>在本例中，只有一个生产者线程和一个消费者线程，它们<code>notify()</code>时，只会唤醒彼此，它们被唤醒并继续运行的条件均为<code>resources</code>暂时没被其他人访问。</p>
<h2 id="考虑生产者-消费者多线程任务">考虑生产者-消费者多线程任务</h2>
<p>在生产者-消费者模型中，生产者和消费者线程需要协调工作。生产者在资源池满时等待，消费者在资源池空时等待。当资源池有空间或有资源时，相应的线程被唤醒。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#f92672">import</span> java.util.LinkedList;
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> java.util.Queue;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">ResourcePool</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> Queue<span style="color:#f92672">&lt;</span>Object<span style="color:#f92672">&gt;</span> resources <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> LinkedList<span style="color:#f92672">&lt;&gt;</span>();
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">int</span> capacity;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">final</span> Object lock <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Object();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#a6e22e">ResourcePool</span>(<span style="color:#66d9ef">int</span> capacity) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">capacity</span> <span style="color:#f92672">=</span> capacity;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">produce</span>(Object resource) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">synchronized</span> (lock) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">while</span> (resources.<span style="color:#a6e22e">size</span>() <span style="color:#f92672">&gt;=</span> capacity) {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">try</span> {
</span></span><span style="display:flex;"><span>	                System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(<span style="color:#e6db74">&#34;生产者进入等待&#34;</span>);
</span></span><span style="display:flex;"><span>                    lock.<span style="color:#a6e22e">wait</span>(); <span style="color:#75715e">// 如果资源池已满，生产者等待</span>
</span></span><span style="display:flex;"><span>                } <span style="color:#66d9ef">catch</span> (InterruptedException e) {
</span></span><span style="display:flex;"><span>                    e.<span style="color:#a6e22e">printStackTrace</span>();
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>                System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(<span style="color:#e6db74">&#34;生产者被唤醒&#34;</span>);
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            resources.<span style="color:#a6e22e">add</span>(resource);
</span></span><span style="display:flex;"><span>            System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(<span style="color:#e6db74">&#34;生产者: 生产了一个资源, 当前资源数: &#34;</span> <span style="color:#f92672">+</span> resources.<span style="color:#a6e22e">size</span>());
</span></span><span style="display:flex;"><span>            lock.<span style="color:#a6e22e">notifyAll</span>(); <span style="color:#75715e">// 唤醒所有等待的消费者线程</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> Object <span style="color:#a6e22e">consume</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">synchronized</span> (lock) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">while</span> (resources.<span style="color:#a6e22e">isEmpty</span>()) {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">try</span> {
</span></span><span style="display:flex;"><span>	                System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(<span style="color:#e6db74">&#34;消费者进入等待&#34;</span>);
</span></span><span style="display:flex;"><span>                    lock.<span style="color:#a6e22e">wait</span>(); <span style="color:#75715e">// 如果资源池为空，消费者等待</span>
</span></span><span style="display:flex;"><span>                } <span style="color:#66d9ef">catch</span> (InterruptedException e) {
</span></span><span style="display:flex;"><span>                    e.<span style="color:#a6e22e">printStackTrace</span>();
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>                System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(<span style="color:#e6db74">&#34;消费者被唤醒&#34;</span>);
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            Object resource <span style="color:#f92672">=</span> resources.<span style="color:#a6e22e">remove</span>();
</span></span><span style="display:flex;"><span>            System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(<span style="color:#e6db74">&#34;消费者: 消费了一个资源, 当前资源数: &#34;</span> <span style="color:#f92672">+</span> resources.<span style="color:#a6e22e">size</span>());
</span></span><span style="display:flex;"><span>            lock.<span style="color:#a6e22e">notifyAll</span>(); <span style="color:#75715e">// 唤醒所有等待的生产者线程</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> resource;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Main</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span>(String<span style="color:#f92672">[]</span> args) {
</span></span><span style="display:flex;"><span>        ResourcePool pool <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> ResourcePool(3);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 生产者线程</span>
</span></span><span style="display:flex;"><span>        Thread producer <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Thread(() <span style="color:#f92672">-&gt;</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 0; i <span style="color:#f92672">&lt;</span> 5; i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>                pool.<span style="color:#a6e22e">produce</span>(<span style="color:#66d9ef">new</span> Object());
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">try</span> {
</span></span><span style="display:flex;"><span>                    Thread.<span style="color:#a6e22e">sleep</span>(1000);
</span></span><span style="display:flex;"><span>                } <span style="color:#66d9ef">catch</span> (InterruptedException e) {
</span></span><span style="display:flex;"><span>                    e.<span style="color:#a6e22e">printStackTrace</span>();
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        });
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 消费者线程1</span>
</span></span><span style="display:flex;"><span>        Thread consumer1 <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Thread(() <span style="color:#f92672">-&gt;</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 0; i <span style="color:#f92672">&lt;</span> 5; i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>                pool.<span style="color:#a6e22e">consume</span>();
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">try</span> {
</span></span><span style="display:flex;"><span>                    Thread.<span style="color:#a6e22e">sleep</span>(1000);
</span></span><span style="display:flex;"><span>                } <span style="color:#66d9ef">catch</span> (InterruptedException e) {
</span></span><span style="display:flex;"><span>                    e.<span style="color:#a6e22e">printStackTrace</span>();
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        });
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 消费者线程2</span>
</span></span><span style="display:flex;"><span>        Thread consumer2 <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Thread(() <span style="color:#f92672">-&gt;</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 0; i <span style="color:#f92672">&lt;</span> 5; i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>                pool.<span style="color:#a6e22e">consume</span>();
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">try</span> {
</span></span><span style="display:flex;"><span>                    Thread.<span style="color:#a6e22e">sleep</span>(1000);
</span></span><span style="display:flex;"><span>                } <span style="color:#66d9ef">catch</span> (InterruptedException e) {
</span></span><span style="display:flex;"><span>                    e.<span style="color:#a6e22e">printStackTrace</span>();
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        });
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        producer.<span style="color:#a6e22e">start</span>();
</span></span><span style="display:flex;"><span>        consumer1.<span style="color:#a6e22e">start</span>();
</span></span><span style="display:flex;"><span>        consumer2.<span style="color:#a6e22e">start</span>();
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="为什么要用notifyall用notify会怎么样">为什么要用<code>notifyAll()</code>？用<code>notify()</code>会怎么样？</h3>
<p>使用<code>notifyAll()</code>会唤醒所有等待的线程，确保它们都能重新评估条件。而使用<code>notify()</code>只唤醒一个线程，可能会导致该锁<strong>假死</strong>：有线程在等待，但没有线程在占用或竞争该锁。</p>
<p>如果使用<code>notify()</code>：</p>
<ul>
<li>如果当前资源数为1，且消费者1消耗了一个资源并执行<code>notify()</code>，此时资源数为0；
<ul>
<li>如果消费者1恰好<code>notify()</code>了生产者，正常运行；</li>
<li>如果不巧，消费者1<code>notify()</code>了消费者2，消费者2会因为没有可用资源而重新<code>wait()</code>；
<ul>
<li>此时三者都处于等待池，锁池为空，程序陷入<strong>假死</strong>。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>如果使用<code>notifyAll()</code>：</p>
<ul>
<li>所有等待的线程都会被唤醒，重新评估条件。</li>
<li>即使某些线程发现条件不满足并继续等待，其他线程仍然有机会执行。</li>
</ul>
<h2 id="如何判断用notify还是notifyall">如何判断用<code>notify()</code>还是<code>notifyAll()</code>？</h2>
<p>判断使用<code>notify()</code>还是<code>notifyAll()</code>的关键在于线程等待的<strong>条件</strong>（condition）是否相同。</p>
<ul>
<li>如果所有等待的线程都在等待同一个条件，使用<code>notify()</code>可能足够。</li>
<li>如果线程等待的条件不同，或者需要确保所有线程都能重新评估条件，使用<code>notifyAll()</code>更安全。</li>
</ul>
<blockquote>
<p>要是我们能给不同的线程设置不同的等待条件该多好。生产者生产后只唤醒条件为<code>资源不为空</code>的消费者，消费者消费后只唤醒条件为<code>资源不为满</code>的生产者们，那就肯定不会假死了！</p></blockquote>
<h2 id="用synchronized的代码怎么改造成用reentrantlock和condition">用<code>synchronized</code>的代码怎么改造成用<code>ReentrantLock</code>和<code>Condition</code></h2>
<h3 id="什么是reentrantlock">什么是<code>ReentrantLock</code></h3>
<p><code>ReentrantLock</code>是一个可重入的互斥锁，它提供了与<code>synchronized</code>类似的功能，但更加灵活。它允许更细粒度的锁控制，并且可以配合<code>Condition</code>对象使用。</p>
<h3 id="condition有什么优势"><code>Condition</code>有什么优势</h3>
<p><code>Condition</code>接口提供了类似于<code>wait()</code>、<code>notify()</code>和<code>notifyAll()</code>的方法，但更加灵活。它允许一个锁对象有多个<code>Condition</code>实例，每个实例可以用于不同的条件等待和通知。</p>
<h3 id="代码改造">代码改造</h3>
<p>将上述代码改造成使用<code>ReentrantLock</code>和<code>Condition</code>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#f92672">import</span> java.util.LinkedList;
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> java.util.Queue;
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> java.util.concurrent.locks.Condition;
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> java.util.concurrent.locks.Lock;
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> java.util.concurrent.locks.ReentrantLock;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">ResourcePool</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> Queue<span style="color:#f92672">&lt;</span>Object<span style="color:#f92672">&gt;</span> resources <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> LinkedList<span style="color:#f92672">&lt;&gt;</span>();
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">int</span> capacity;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">final</span> Lock lock <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> ReentrantLock();
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">final</span> Condition notFull <span style="color:#f92672">=</span> lock.<span style="color:#a6e22e">newCondition</span>();
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">final</span> Condition notEmpty <span style="color:#f92672">=</span> lock.<span style="color:#a6e22e">newCondition</span>();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#a6e22e">ResourcePool</span>(<span style="color:#66d9ef">int</span> capacity) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">capacity</span> <span style="color:#f92672">=</span> capacity;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">produce</span>(Object resource) {
</span></span><span style="display:flex;"><span>        lock.<span style="color:#a6e22e">lock</span>();
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">try</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">while</span> (resources.<span style="color:#a6e22e">size</span>() <span style="color:#f92672">&gt;=</span> capacity) {
</span></span><span style="display:flex;"><span>                notFull.<span style="color:#a6e22e">await</span>(); <span style="color:#75715e">// 如果资源池已满，生产者等待</span>
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            resources.<span style="color:#a6e22e">add</span>(resource);
</span></span><span style="display:flex;"><span>            System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(<span style="color:#e6db74">&#34;生产者: 生产了一个资源, 当前资源数: &#34;</span> <span style="color:#f92672">+</span> resources.<span style="color:#a6e22e">size</span>());
</span></span><span style="display:flex;"><span>            notEmpty.<span style="color:#a6e22e">signal</span>(); <span style="color:#75715e">// 唤醒单个等待的消费者线程</span>
</span></span><span style="display:flex;"><span>        } <span style="color:#66d9ef">catch</span> (InterruptedException e) {
</span></span><span style="display:flex;"><span>            e.<span style="color:#a6e22e">printStackTrace</span>();
</span></span><span style="display:flex;"><span>        } <span style="color:#66d9ef">finally</span> {
</span></span><span style="display:flex;"><span>            lock.<span style="color:#a6e22e">unlock</span>();
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> Object <span style="color:#a6e22e">consume</span>() {
</span></span><span style="display:flex;"><span>        lock.<span style="color:#a6e22e">lock</span>();
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">try</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">while</span> (resources.<span style="color:#a6e22e">isEmpty</span>()) {
</span></span><span style="display:flex;"><span>                notEmpty.<span style="color:#a6e22e">await</span>(); <span style="color:#75715e">// 如果资源池为空，消费者等待</span>
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            Object resource <span style="color:#f92672">=</span> resources.<span style="color:#a6e22e">remove</span>();
</span></span><span style="display:flex;"><span>            System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(<span style="color:#e6db74">&#34;消费者: 消费了一个资源, 当前资源数: &#34;</span> <span style="color:#f92672">+</span> resources.<span style="color:#a6e22e">size</span>());
</span></span><span style="display:flex;"><span>            notFull.<span style="color:#a6e22e">signal</span>(); <span style="color:#75715e">// 唤醒单个等待的生产者线程</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> resource;
</span></span><span style="display:flex;"><span>        } <span style="color:#66d9ef">catch</span> (InterruptedException e) {
</span></span><span style="display:flex;"><span>            e.<span style="color:#a6e22e">printStackTrace</span>();
</span></span><span style="display:flex;"><span>        } <span style="color:#66d9ef">finally</span> {
</span></span><span style="display:flex;"><span>            lock.<span style="color:#a6e22e">unlock</span>();
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Main</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span>(String<span style="color:#f92672">[]</span> args) {
</span></span><span style="display:flex;"><span>        ResourcePool pool <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> ResourcePool(3);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 生产者线程</span>
</span></span><span style="display:flex;"><span>        Thread producer <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Thread(() <span style="color:#f92672">-&gt;</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 0; i <span style="color:#f92672">&lt;</span> 5; i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>                pool.<span style="color:#a6e22e">produce</span>(<span style="color:#66d9ef">new</span> Object());
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">try</span> {
</span></span><span style="display:flex;"><span>                    Thread.<span style="color:#a6e22e">sleep</span>(1000);
</span></span><span style="display:flex;"><span>                } <span style="color:#66d9ef">catch</span> (InterruptedException e) {
</span></span><span style="display:flex;"><span>                    e.<span style="color:#a6e22e">printStackTrace</span>();
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        });
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 消费者线程1</span>
</span></span><span style="display:flex;"><span>        Thread consumer1 <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Thread(() <span style="color:#f92672">-&gt;</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 0; i <span style="color:#f92672">&lt;</span> 5; i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>                pool.<span style="color:#a6e22e">consume</span>();
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">try</span> {
</span></span><span style="display:flex;"><span>                    Thread.<span style="color:#a6e22e">sleep</span>(1000);
</span></span><span style="display:flex;"><span>                } <span style="color:#66d9ef">catch</span> (InterruptedException e) {
</span></span><span style="display:flex;"><span>                    e.<span style="color:#a6e22e">printStackTrace</span>();
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        });
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 消费者线程2</span>
</span></span><span style="display:flex;"><span>        Thread consumer2 <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Thread(() <span style="color:#f92672">-&gt;</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 0; i <span style="color:#f92672">&lt;</span> 5; i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>                pool.<span style="color:#a6e22e">consume</span>();
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">try</span> {
</span></span><span style="display:flex;"><span>                    Thread.<span style="color:#a6e22e">sleep</span>(1000);
</span></span><span style="display:flex;"><span>                } <span style="color:#66d9ef">catch</span> (InterruptedException e) {
</span></span><span style="display:flex;"><span>                    e.<span style="color:#a6e22e">printStackTrace</span>();
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        });
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        producer.<span style="color:#a6e22e">start</span>();
</span></span><span style="display:flex;"><span>        consumer1.<span style="color:#a6e22e">start</span>();
</span></span><span style="display:flex;"><span>        consumer2.<span style="color:#a6e22e">start</span>();
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="改造后的代码解释">改造后的代码解释</h3>
<ol>
<li>
<p><strong>锁的初始化</strong>：</p>
<ul>
<li>使用<code>ReentrantLock</code>代替<code>synchronized</code>，提供更灵活的锁控制。</li>
</ul>
</li>
<li>
<p><strong>条件的初始化</strong>：</p>
<ul>
<li>为生产者和消费者分别创建两个<code>Condition</code>实例<code>notFull</code>和<code>notEmpty</code>，分别用于等待资源池满和空的条件。</li>
</ul>
</li>
<li>
<p><strong>生产者方法</strong>：</p>
<ul>
<li>在资源池满时，生产者线程调用<code>notFull.await()</code>进入等待。</li>
<li>当资源池有空间时，调用<code>notEmpty.signal()</code>唤醒单个消费者线程。</li>
</ul>
</li>
<li>
<p><strong>消费者方法</strong>：</p>
<ul>
<li>在资源池空时，消费者线程调用<code>notEmpty.await()</code>进入等待。</li>
<li>当资源池有资源时，调用<code>notFull.signal()</code>唤醒单个生产者线程。</li>
</ul>
</li>
</ol>
<p>通过这种改造，我们使用<code>ReentrantLock</code>和<code>Condition</code>实现了更灵活的线程同步，避免了<code>synchronized</code>的一些限制。</p>
]]></content:encoded>
    </item>
    <item>
      <title>啊，这个title是不是还不能重复</title>
      <link>https://oNya685.github.io/posts/ramble/250317/</link>
      <pubDate>Mon, 17 Mar 2025 12:19:49 +0800</pubDate>
      <guid>https://oNya685.github.io/posts/ramble/250317/</guid>
      <description>&lt;p&gt;马原老师课讲得挺好，特别是对理论的讲解，只可惜她又考勤又严格。&lt;del&gt;但也只是嘴上严格，只提醒不惩罚，上课干别的事也容许了&lt;/del&gt;&lt;/p&gt;
&lt;p&gt;老师提到维特根斯坦的早期的思想，大意是从形式语言的角度证明了世界是可以用语言完备表述的。&lt;/p&gt;</description>
      <content:encoded><![CDATA[<p>马原老师课讲得挺好，特别是对理论的讲解，只可惜她又考勤又严格。<del>但也只是嘴上严格，只提醒不惩罚，上课干别的事也容许了</del></p>
<p>老师提到维特根斯坦的早期的思想，大意是从形式语言的角度证明了世界是可以用语言完备表述的。</p>
<hr>
<p>走在路上听到旁边人说：“当过皇帝的人都死了。”</p>
<p>没绷住。</p>
]]></content:encoded>
    </item>
    <item>
      <title>我的周末呢</title>
      <link>https://oNya685.github.io/posts/ramble/250316/</link>
      <pubDate>Mon, 17 Mar 2025 00:40:43 +0800</pubDate>
      <guid>https://oNya685.github.io/posts/ramble/250316/</guid>
      <description>&lt;p&gt;折腾了两天的Hugo框架和PaperMod主题，总算搭出一套暂且顺手的方案。不得不提到的是，配合上OS实验顺带学会的shell脚本，一些操作得以简化或自动化，方便了不少，包括自动的从WebDAV同步、自动生成commit message和push。脚本源码参见&lt;a href=&#34;https://github.com/oNya685/oNya685.github.io/&#34; target=&#34;_blank&#34;&gt;oNya685/oNya685.github.io&lt;/a&gt;
。&lt;/p&gt;</description>
      <content:encoded><![CDATA[<p>折腾了两天的Hugo框架和PaperMod主题，总算搭出一套暂且顺手的方案。不得不提到的是，配合上OS实验顺带学会的shell脚本，一些操作得以简化或自动化，方便了不少，包括自动的从WebDAV同步、自动生成commit message和push。脚本源码参见<a href="https://github.com/oNya685/oNya685.github.io/" target="_blank">oNya685/oNya685.github.io</a>
。</p>
<p>费劲了两天，周末也就过去了。本周末的OO互测很没意思，作为Unit 1的收尾，这次迭代难度比上周的要低上太多，也难以写出什么错误，一天下来，七星<sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup>成功率都是0%。</p>
<p>偶尔也在想这些东西是在写给谁看，像是埋了颗种子却不发芽，将来挖出来时回忆的是当时埋种子的自己。<del>当然，如果这些碎碎念被发现，说不定也很有趣</del></p>
<div class="footnotes" role="doc-endnotes">
<hr>
<ol>
<li id="fn:1">
<p>本周不知为什么被分到了只有七人的房间，按往常，应该是八星。其实有几个七星房间也正常，毕竟<em>对于 $\forall n,a,b\in N^+$，当 $n\geq a\times b$时，必定 $\exists p,q\in N$，使得 $n=p\times a+q\times b$。</em> 这是随手写的，不知道对不对。&#160;<a href="#fnref:1" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
</ol>
</div>
]]></content:encoded>
    </item>
    <item>
      <title>[BUAA-OS] Lab 0 实验报告</title>
      <link>https://oNya685.github.io/posts/buaa/os/lab-0-report/</link>
      <pubDate>Sun, 16 Mar 2025 11:27:33 +0800</pubDate>
      <guid>https://oNya685.github.io/posts/buaa/os/lab-0-report/</guid>
      <description>&lt;h1 id=&#34;一思考题&#34;&gt;一、思考题&lt;/h1&gt;
&lt;h2 id=&#34;thinking-01&#34;&gt;Thinking 0.1&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;思考下列有关Git的问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在前述已初始化的~/learnGit 目录下，创建一个名为README.txt的文件。执行命令git status &amp;gt; Untracked.txt（其中的 &amp;gt; 为输出重定向，我们将在0.6.3中详细介绍）。&lt;/li&gt;
&lt;li&gt;在README.txt 文件中添加任意文件内容，然后使用add命令，再执行命令git status &amp;gt; Stage.txt。&lt;/li&gt;
&lt;li&gt;提交README.txt，并在提交说明里写入自己的学号。&lt;/li&gt;
&lt;li&gt;执行命令cat Untracked.txt 和cat Stage.txt，对比两次运行的结果，体会README.txt两次所处位置的不同。&lt;/li&gt;
&lt;li&gt;修改README.txt 文件，再执行命令git status &amp;gt; Modified.txt。&lt;/li&gt;
&lt;li&gt;执行命令cat Modified.txt，观察其结果和第一次执行add命令之前的status是否一样，并思考原因。&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h3 id=&#34;1-untrackedtxt&#34;&gt;1. Untracked.txt&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$  cat Untracked.txt
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;位于分支 master
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;未跟踪的文件:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  （使用 &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;git add &amp;lt;文件&amp;gt;...&amp;#34;&lt;/span&gt; 以包含要提交的内容）
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        README.txt
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        Untracked.txt
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;提交为空，但是存在尚未跟踪的文件（使用 &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;git add&amp;#34;&lt;/span&gt; 建立跟踪）
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;新建了&lt;code&gt;README.txt&lt;/code&gt;文件，处于Untracked状态。&lt;/p&gt;</description>
      <content:encoded><![CDATA[<h1 id="一思考题">一、思考题</h1>
<h2 id="thinking-01">Thinking 0.1</h2>
<blockquote>
<p>思考下列有关Git的问题：</p>
<ul>
<li>在前述已初始化的~/learnGit 目录下，创建一个名为README.txt的文件。执行命令git status &gt; Untracked.txt（其中的 &gt; 为输出重定向，我们将在0.6.3中详细介绍）。</li>
<li>在README.txt 文件中添加任意文件内容，然后使用add命令，再执行命令git status &gt; Stage.txt。</li>
<li>提交README.txt，并在提交说明里写入自己的学号。</li>
<li>执行命令cat Untracked.txt 和cat Stage.txt，对比两次运行的结果，体会README.txt两次所处位置的不同。</li>
<li>修改README.txt 文件，再执行命令git status &gt; Modified.txt。</li>
<li>执行命令cat Modified.txt，观察其结果和第一次执行add命令之前的status是否一样，并思考原因。</li>
</ul></blockquote>
<hr>
<h3 id="1-untrackedtxt">1. Untracked.txt</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>$  cat Untracked.txt
</span></span><span style="display:flex;"><span>位于分支 master
</span></span><span style="display:flex;"><span>未跟踪的文件:
</span></span><span style="display:flex;"><span>  （使用 <span style="color:#e6db74">&#34;git add &lt;文件&gt;...&#34;</span> 以包含要提交的内容）
</span></span><span style="display:flex;"><span>        README.txt
</span></span><span style="display:flex;"><span>        Untracked.txt
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>提交为空，但是存在尚未跟踪的文件（使用 <span style="color:#e6db74">&#34;git add&#34;</span> 建立跟踪）
</span></span></code></pre></div><p>新建了<code>README.txt</code>文件，处于Untracked状态。</p>
<h3 id="2-stagedtxt">2. Staged.txt</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>$  cat Staged.txt
</span></span><span style="display:flex;"><span>位于分支 master
</span></span><span style="display:flex;"><span>要提交的变更：
</span></span><span style="display:flex;"><span>  （使用 <span style="color:#e6db74">&#34;git restore --staged &lt;文件&gt;...&#34;</span> 以取消暂存）
</span></span><span style="display:flex;"><span>        新文件：   README.txt
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>未跟踪的文件:
</span></span><span style="display:flex;"><span>  （使用 <span style="color:#e6db74">&#34;git add &lt;文件&gt;...&#34;</span> 以包含要提交的内容）
</span></span><span style="display:flex;"><span>        Staged.txt
</span></span><span style="display:flex;"><span>        Untracked.txt
</span></span></code></pre></div><p>修改了<code>README.txt</code>的文件内容，并跟踪和暂存该文件，处于Staged状态。</p>
<h3 id="3-modifiedtxt">3. Modified.txt</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>$  cat Modified.txt
</span></span><span style="display:flex;"><span>位于分支 master
</span></span><span style="display:flex;"><span>尚未暂存以备提交的变更：
</span></span><span style="display:flex;"><span>  （使用 <span style="color:#e6db74">&#34;git add &lt;文件&gt;...&#34;</span> 更新要提交的内容）
</span></span><span style="display:flex;"><span>  （使用 <span style="color:#e6db74">&#34;git restore &lt;文件&gt;...&#34;</span> 丢弃工作区的改动）
</span></span><span style="display:flex;"><span>        修改：     README.txt
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>未跟踪的文件:
</span></span><span style="display:flex;"><span>  （使用 <span style="color:#e6db74">&#34;git add &lt;文件&gt;...&#34;</span> 以包含要提交的内容）
</span></span><span style="display:flex;"><span>        Modified.txt
</span></span><span style="display:flex;"><span>        Staged.txt
</span></span><span style="display:flex;"><span>        Untracked.txt
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>修改尚未加入提交（使用 <span style="color:#e6db74">&#34;git add&#34;</span> 和/或 <span style="color:#e6db74">&#34;git commit -a&#34;</span>）
</span></span></code></pre></div><p><code>README.txt</code>经暂存和提交后处于Unmodified状态，修改文件内容使其进入Modified状态等待暂存。</p>
<h2 id="thinking-02">Thinking 0.2</h2>
<blockquote>
<p>仔细看看<a href="%e5%9b%be%200.10%20-%20Git%20%e4%b8%ad%e7%9a%84%e5%9b%9b%e7%a7%8d%e7%8a%b6%e6%80%81%e8%bd%ac%e6%8d%a2%e5%85%b3%e7%b3%bb.png" target="_blank">0.10</a>
，思考一下箭头中的add the file、stage the file和commit分别对应的是Git里的哪些命令呢？</p>
<p><div class="post-img-view">
    <a data-fancybox="gallery"
         href="%E5%9B%BE%200.10%20-%20Git%20%E4%B8%AD%E7%9A%84%E5%9B%9B%E7%A7%8D%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2%E5%85%B3%E7%B3%BB.png">
        <img alt="图 0.10 - Git 中的四种状态转换关系" loading="lazy" src="/posts/buaa/os/lab-0-report/%E5%9B%BE%200.10%20-%20Git%20%E4%B8%AD%E7%9A%84%E5%9B%9B%E7%A7%8D%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2%E5%85%B3%E7%B3%BB_hu_85b07da4fcfbe74e.webp">
    </a>
</div></p></blockquote>
<hr>
<h3 id="1-add-the-file">1. add the file</h3>
<p>add the file 对应的是<code>git add</code>。</p>
<h3 id="2-stage-the-file">2. stage the file</h3>
<p>stage the file 对应的是<code>git add</code>。</p>
<h3 id="3-commit">3. commit</h3>
<p>commit 对应的是<code>git commit</code>。</p>
<h2 id="thinking-03">Thinking 0.3</h2>
<blockquote>
<p>思考下列问题：</p>
<ol>
<li>代码文件print.c被错误删除时，应当使用什么命令将其恢复？</li>
<li>代码文件print.c被错误删除后，执行了git rm print.c命令，此时应当使用什么命令将其恢复？</li>
<li>无关文件hello.txt已经被添加到暂存区时，如何在不删除此文件的前提下将其移出暂存区？</li>
</ol></blockquote>
<h3 id="1-代码文件-printc-被错误删除时应当使用什么命令将其恢复">1. 代码文件 print.c 被错误删除时，应当使用什么命令将其恢复？</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>git restore print.c
</span></span></code></pre></div><p>print.c 尚未执行<code>git add</code>，故可以从暂存区将print.c恢复到工作区中。</p>
<h3 id="2-代码文件-printc-被错误删除后执行了-git-rm-printc-命令此时应当使用什么命令将其恢复">2. 代码文件 print.c 被错误删除后，执行了 git rm print.c 命令，此时应当使用什么命令将其恢复？</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>git reset HEAD print.c
</span></span><span style="display:flex;"><span>git restore print.c
</span></span></code></pre></div><p>首先撤销暂存区的修改（删除了print.c），然后将print.c从暂存区恢复到工作区。</p>
<h3 id="3-无关文件-hellotxt-已经被添加到暂存区时如何在不删除此文件的前提下将其移出暂存区">3. 无关文件 hello.txt 已经被添加到暂存区时，如何在不删除此文件的前提下将其移出暂存区？</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>git reset HEAD hello.txt
</span></span></code></pre></div><p>撤销暂存区的修改，把暂存区恢复到执行<code>git add</code>之前的状态。</p>
<h2 id="thinking-04">Thinking 0.4</h2>
<blockquote>
<p>思考下列有关 Git 的问题：</p>
<ul>
<li>找到在 /home/22xxxxxx/learnGit 下刚刚创建的 README.txt 文件，若不存在则新建该文件。</li>
<li>在文件里加入 Testing 1，git add，git commit，提交说明记为 1。</li>
<li>模仿上述做法，把 1 分别改为 2 和 3，再提交两次。</li>
<li>使用 git log 命令查看提交日志，看是否已经有三次提交，记下提交说明为 3 的哈希值<sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup>。</li>
<li>进行版本回退。执行命令 git reset &ndash;hard HEAD^ 后，再执行 git log，观察其变化。</li>
<li>找到提交说明为 1 的哈希值，执行命令 git reset &ndash;hard &lt;hash&gt; 后，再执行 git log，观察其变化。</li>
<li>现在已经回到了旧版本，为了再次回到新版本，执行 git reset &ndash;hard &lt;hash&gt;，再执行 git log，观察其变化。</li>
</ul></blockquote>
<hr>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>$  git log
</span></span><span style="display:flex;"><span>commit a6ebe244272dd6bcb1f57ba9af3c957f3e7235b3 <span style="color:#f92672">(</span>HEAD -&gt; master<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>Author: 姜宇墨 &lt;YumoJiang@buaa.edu.cn&gt;
</span></span><span style="display:flex;"><span>Date:   Tue Mar <span style="color:#ae81ff">11</span> 19:08:41 <span style="color:#ae81ff">2025</span> +0800
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#ae81ff">3</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>commit 1d11df1461528ce8e2b67151384d4b24bdfec571
</span></span><span style="display:flex;"><span>Author: 姜宇墨 &lt;YumoJiang@buaa.edu.cn&gt;
</span></span><span style="display:flex;"><span>Date:   Tue Mar <span style="color:#ae81ff">11</span> 19:08:33 <span style="color:#ae81ff">2025</span> +0800
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#ae81ff">2</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>commit 3f8eb4043efae29bbb9eb626444f955a825f3535
</span></span><span style="display:flex;"><span>Author: 姜宇墨 &lt;YumoJiang@buaa.edu.cn&gt;
</span></span><span style="display:flex;"><span>Date:   Tue Mar <span style="color:#ae81ff">11</span> 19:08:12 <span style="color:#ae81ff">2025</span> +0800
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#ae81ff">1</span>
</span></span></code></pre></div><p>提交说明为<code>3</code>的哈希值为<code>a6ebe244272dd6bcb1f57ba9af3c957f3e7235b3</code>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>$  git reset --hard HEAD^
</span></span><span style="display:flex;"><span>HEAD 现在位于 1d11df1 <span style="color:#ae81ff">2</span>
</span></span><span style="display:flex;"><span>$  git log
</span></span><span style="display:flex;"><span>commit 1d11df1461528ce8e2b67151384d4b24bdfec571 <span style="color:#f92672">(</span>HEAD -&gt; master<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>Author: 姜宇墨 &lt;YumoJiang@buaa.edu.cn&gt;
</span></span><span style="display:flex;"><span>Date:   Tue Mar <span style="color:#ae81ff">11</span> 19:08:33 <span style="color:#ae81ff">2025</span> +0800
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#ae81ff">2</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>commit 3f8eb4043efae29bbb9eb626444f955a825f3535
</span></span><span style="display:flex;"><span>Author: 姜宇墨 &lt;YumoJiang@buaa.edu.cn&gt;
</span></span><span style="display:flex;"><span>Date:   Tue Mar <span style="color:#ae81ff">11</span> 19:08:12 <span style="color:#ae81ff">2025</span> +0800
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#ae81ff">1</span>
</span></span></code></pre></div><p>变化：当前Git仓库的状态回到了<code>2</code>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>$  git reset --hard 3f8eb4043efae29bbb9eb626444f955a825f3535
</span></span><span style="display:flex;"><span>HEAD 现在位于 3f8eb40 <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>$  git log
</span></span><span style="display:flex;"><span>commit 3f8eb4043efae29bbb9eb626444f955a825f3535 <span style="color:#f92672">(</span>HEAD -&gt; master<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>Author: 姜宇墨 &lt;YumoJiang@buaa.edu.cn&gt;
</span></span><span style="display:flex;"><span>Date:   Tue Mar <span style="color:#ae81ff">11</span> 19:08:12 <span style="color:#ae81ff">2025</span> +0800
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#ae81ff">1</span>
</span></span></code></pre></div><p>变化：当前Git仓库的状态回到了<code>1</code>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>$  git reset --hard a6ebe244272dd6bcb1f57ba9af3c957f3e7235b3
</span></span><span style="display:flex;"><span>HEAD 现在位于 a6ebe24 <span style="color:#ae81ff">3</span>
</span></span><span style="display:flex;"><span>$  git log
</span></span><span style="display:flex;"><span>commit a6ebe244272dd6bcb1f57ba9af3c957f3e7235b3 <span style="color:#f92672">(</span>HEAD -&gt; master<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>Author: 姜宇墨 &lt;YumoJiang@buaa.edu.cn&gt;
</span></span><span style="display:flex;"><span>Date:   Tue Mar <span style="color:#ae81ff">11</span> 19:08:41 <span style="color:#ae81ff">2025</span> +0800
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#ae81ff">3</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>commit 1d11df1461528ce8e2b67151384d4b24bdfec571
</span></span><span style="display:flex;"><span>Author: 姜宇墨 &lt;YumoJiang@buaa.edu.cn&gt;
</span></span><span style="display:flex;"><span>Date:   Tue Mar <span style="color:#ae81ff">11</span> 19:08:33 <span style="color:#ae81ff">2025</span> +0800
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#ae81ff">2</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>commit 3f8eb4043efae29bbb9eb626444f955a825f3535
</span></span><span style="display:flex;"><span>Author: 姜宇墨 &lt;YumoJiang@buaa.edu.cn&gt;
</span></span><span style="display:flex;"><span>Date:   Tue Mar <span style="color:#ae81ff">11</span> 19:08:12 <span style="color:#ae81ff">2025</span> +0800
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#ae81ff">1</span>
</span></span></code></pre></div><p>变化：当前Git仓库的状态回到了<code>3</code>。</p>
<h2 id="thinking-05">Thinking 0.5</h2>
<blockquote>
<p>执行如下命令, 并查看结果</p>
<ul>
<li>echo first</li>
<li>echo second &gt; output.txt</li>
<li>echo third &gt; output.txt</li>
<li>echo forth &raquo; output.txt</li>
</ul></blockquote>
<hr>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>$  echo first
</span></span><span style="display:flex;"><span>first
</span></span><span style="display:flex;"><span>$  echo second &gt; output.txt <span style="color:#f92672">&amp;&amp;</span> cat output.txt
</span></span><span style="display:flex;"><span>second
</span></span><span style="display:flex;"><span>$  echo third &gt; output.txt <span style="color:#f92672">&amp;&amp;</span> cat output.txt
</span></span><span style="display:flex;"><span>third
</span></span><span style="display:flex;"><span>$  echo forth &gt;&gt; output.txt <span style="color:#f92672">&amp;&amp;</span> cat output.txt
</span></span><span style="display:flex;"><span>third
</span></span><span style="display:flex;"><span>forth
</span></span></code></pre></div><h2 id="thinking-06">Thinking 0.6</h2>
<blockquote>
<p>使用你知道的方法（包括重定向）创建下图内容的文件（文件命名为 test），将创建该文件的命令序列保存在command文件中，并将test文件作为批处理文件运行，将运行结果输出至result文件中。给出command文件和result文件的内容，并对最后的结果进行解释说明（可以从test文件的内容入手）。具体实现的过程中思考下列问题: echo echo Shell Start 与 echo `echo Shell Start` 效果是否有区别; echo echo $c&gt;file1 与 echo `echo $c&gt;file1` 效果是否有区别.</p></blockquote>
<hr>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#75715e"># command</span>
</span></span><span style="display:flex;"><span>echo <span style="color:#e6db74">&#39;echo Shell Start...&#39;</span> &gt; test
</span></span><span style="display:flex;"><span>echo <span style="color:#e6db74">&#39;echo set a = 1&#39;</span> &gt;&gt; test
</span></span><span style="display:flex;"><span>echo <span style="color:#e6db74">&#39;a=1&#39;</span> &gt;&gt; test
</span></span><span style="display:flex;"><span>echo <span style="color:#e6db74">&#39;echo set b = 2&#39;</span> &gt;&gt; test
</span></span><span style="display:flex;"><span>echo <span style="color:#e6db74">&#39;b=2&#39;</span> &gt;&gt; test
</span></span><span style="display:flex;"><span>echo <span style="color:#e6db74">&#39;echo set c = a+b&#39;</span> &gt;&gt; test
</span></span><span style="display:flex;"><span>echo <span style="color:#e6db74">&#39;c=$[$a+$b]&#39;</span> &gt;&gt; test
</span></span><span style="display:flex;"><span>echo <span style="color:#e6db74">&#39;echo c = $c&#39;</span> &gt;&gt; test
</span></span><span style="display:flex;"><span>echo <span style="color:#e6db74">&#39;echo save c to ./file1&#39;</span> &gt;&gt; test
</span></span><span style="display:flex;"><span>echo <span style="color:#e6db74">&#39;echo $c&gt;file1&#39;</span> &gt;&gt; test
</span></span><span style="display:flex;"><span>echo <span style="color:#e6db74">&#39;echo save b to ./file2&#39;</span> &gt;&gt; test
</span></span><span style="display:flex;"><span>echo <span style="color:#e6db74">&#39;echo $b&gt;file2&#39;</span> &gt;&gt; test
</span></span><span style="display:flex;"><span>echo <span style="color:#e6db74">&#39;echo save a to ./file3&#39;</span> &gt;&gt; test
</span></span><span style="display:flex;"><span>echo <span style="color:#e6db74">&#39;echo $a&gt;file3&#39;</span> &gt;&gt; test
</span></span><span style="display:flex;"><span>echo <span style="color:#e6db74">&#39;echo save file1 file2 file3 to file4&#39;</span> &gt;&gt; test
</span></span><span style="display:flex;"><span>echo <span style="color:#e6db74">&#39;cat file1&gt;file4&#39;</span> &gt;&gt; test
</span></span><span style="display:flex;"><span>echo <span style="color:#e6db74">&#39;cat file2&gt;&gt;file4&#39;</span> &gt;&gt; test
</span></span><span style="display:flex;"><span>echo <span style="color:#e6db74">&#39;cat file3&gt;&gt;file4&#39;</span> &gt;&gt; test
</span></span><span style="display:flex;"><span>echo <span style="color:#e6db74">&#39;echo save file4 to ./result&#39;</span> &gt;&gt; test
</span></span><span style="display:flex;"><span>echo <span style="color:#e6db74">&#39;cat file4&gt;&gt;result&#39;</span> &gt;&gt; test
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#75715e"># test</span>
</span></span><span style="display:flex;"><span>echo Shell Start...        <span style="color:#75715e"># 输出初始化提示</span>
</span></span><span style="display:flex;"><span>echo set a <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>a<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>                        <span style="color:#75715e"># 设置变量a=1</span>
</span></span><span style="display:flex;"><span>echo set b <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>
</span></span><span style="display:flex;"><span>b<span style="color:#f92672">=</span><span style="color:#ae81ff">2</span>                        <span style="color:#75715e"># 设置变量b=2</span>
</span></span><span style="display:flex;"><span>echo set c <span style="color:#f92672">=</span> a+b
</span></span><span style="display:flex;"><span>c<span style="color:#f92672">=</span>$<span style="color:#f92672">[</span>$a+$b<span style="color:#f92672">]</span>                 <span style="color:#75715e"># 执行算术运算c=a+b=1+2=3</span>
</span></span><span style="display:flex;"><span>echo c <span style="color:#f92672">=</span> $c                <span style="color:#75715e"># 输出计算结果</span>
</span></span><span style="display:flex;"><span>echo save c to ./file1
</span></span><span style="display:flex;"><span>echo $c&gt;file1              <span style="color:#75715e"># 将c的值写入file1</span>
</span></span><span style="display:flex;"><span>echo save b to ./file2
</span></span><span style="display:flex;"><span>echo $b&gt;file2              <span style="color:#75715e"># 将b的值写入file2</span>
</span></span><span style="display:flex;"><span>echo save a to ./file3
</span></span><span style="display:flex;"><span>echo $a&gt;file3              <span style="color:#75715e"># 将a的值写入file3</span>
</span></span><span style="display:flex;"><span>echo save file1 file2 file3 to file4
</span></span><span style="display:flex;"><span>cat file1&gt;file4            <span style="color:#75715e"># 创建file4并写入file1内容</span>
</span></span><span style="display:flex;"><span>cat file2&gt;&gt;file4           <span style="color:#75715e"># 追加file2内容</span>
</span></span><span style="display:flex;"><span>cat file3&gt;&gt;file4           <span style="color:#75715e"># 追加file3内容</span>
</span></span><span style="display:flex;"><span>echo save file4 to ./result
</span></span><span style="display:flex;"><span>cat file4&gt;&gt;result          <span style="color:#75715e"># 最终结果是c,b,a的值</span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>$  ./test
</span></span><span style="display:flex;"><span>Shell Start...
</span></span><span style="display:flex;"><span>set a <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>set b <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>
</span></span><span style="display:flex;"><span>set c <span style="color:#f92672">=</span> a+b
</span></span><span style="display:flex;"><span>c <span style="color:#f92672">=</span> <span style="color:#ae81ff">3</span>
</span></span><span style="display:flex;"><span>save c to ./file1
</span></span><span style="display:flex;"><span>save b to ./file2
</span></span><span style="display:flex;"><span>save a to ./file3
</span></span><span style="display:flex;"><span>save file1 file2 file3 to file4
</span></span><span style="display:flex;"><span>save file4 to ./result
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>$  cat result
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">3</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">2</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">1</span>
</span></span></code></pre></div><p>反引号会先执行命令替换，改变重定向行为。</p>
<table>
  <thead>
      <tr>
          <th>echo echo Shell Start</th>
          <th>echo `echo Shell Start`</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>输出字符串<code>echo Shell Start</code></td>
          <td>先执行命令<code>echo Shell Start</code>再输出该命令的执行结果<code>Shell Start</code></td>
      </tr>
  </tbody>
</table>
<table>
  <thead>
      <tr>
          <th>echo echo $c&gt;file1</th>
          <th>echo `echo $c&gt;file1`</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>将字符串<code>echo 3</code>写入file1</td>
          <td>先将<code>3</code>写入file1，再输出写入的执行结果（为空），即终端无输出</td>
      </tr>
  </tbody>
</table>
<h1 id="二难点分析与实验体会">二、难点分析与实验体会</h1>
<p>本次实验的主要难点在于<strong>工具链的命令行参数</strong>和<strong>shell编程</strong>掌握不够熟练。</p>
<h3 id="难点1sed的用法">难点1：<code>sed</code>的用法</h3>
<p>为实现在 hello_os.sh 所处的目录新建一个名为BBB的文件，其内容为 AAA文件的第8、32、128、512、1024行的内容提取，构造<code>sed</code>命令</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sed -n <span style="color:#e6db74">&#39;8p;32p;128p;512p;1024p&#39;</span> <span style="color:#e6db74">&#34;</span>$1<span style="color:#e6db74">&#34;</span> &gt; <span style="color:#e6db74">&#34;</span>$2<span style="color:#e6db74">&#34;</span>
</span></span></code></pre></div><h3 id="难点2awk行号提取">难点2：<code>awk</code>行号提取</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>grep -n <span style="color:#e6db74">&#34;</span>$2<span style="color:#e6db74">&#34;</span> ./<span style="color:#e6db74">&#34;</span>$1<span style="color:#e6db74">&#34;</span> | awk -F <span style="color:#e6db74">&#39;:&#39;</span> <span style="color:#e6db74">&#39;{print $1}&#39;</span> &gt; ./<span style="color:#e6db74">&#34;</span>$3<span style="color:#e6db74">&#34;</span>
</span></span></code></pre></div><h3 id="难点3gcc与make的特殊用法">难点3：GCC与Make的特殊用法</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#75715e"># 多目录编译示例</span>
</span></span><span style="display:flex;"><span>gcc -I ../include -c fibo.c -o fibo.o
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 调用子目录make命令示例</span>
</span></span><span style="display:flex;"><span>make -C code fibo.o
</span></span></code></pre></div><hr>
<h1 id="三原创说明">三、原创说明</h1>
<p>在本次实验中，对工具链的使用参考了官方manual和<code>--help</code>参数。</p>
<p>在Neovim和LazyVim的安装与配置中，参考了<a href="https://blog.csdn.net/m0_60670525/article/details/136329707" target="_blank">如何在Ubuntu上安装最新版本的Neovim并快速配置_ubuntu安装neovim-CSDN博客</a>
</p>
<div class="footnotes" role="doc-endnotes">
<hr>
<ol>
<li id="fn:1">
<p>使用 git log 命令时，在 commit 标识符后的一长串数字和字母组成的字符串&#160;<a href="#fnref:1" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
</ol>
</div>
]]></content:encoded>
    </item>
    <item>
      <title>[BUAA-OS] 理论作业 1</title>
      <link>https://oNya685.github.io/posts/buaa/os/homework-1/</link>
      <pubDate>Sun, 16 Mar 2025 11:19:17 +0800</pubDate>
      <guid>https://oNya685.github.io/posts/buaa/os/homework-1/</guid>
      <description>&lt;p&gt;&lt;strong&gt;&lt;a href=&#34;%e4%bd%9c%e4%b8%9a1.pdf&#34; target=&#34;_blank&#34;&gt;点此查看作业源文件&lt;/a&gt;
&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&#34;1什么是多道程序设计多道程序设计与分时系统的区别是什么&#34;&gt;1.什么是多道程序设计？多道程序设计与分时系统的区别是什么？&lt;/h1&gt;
&lt;p&gt;多道程序设计技术，是指允许多个程序同时进⼊内存并运⾏。即同时把多个程序放⼊内存中，并允许它们交替在CPU中运⾏，共享系统中的各种硬、软件资源，当⼀道程序因I/O请求⽽暂停运⾏时，CPU便⽴即转去运⾏另⼀道程序。多道程序设计技术提⾼了CPU、I/O设备和内存的利⽤率，从⽽提⾼了整个系统的资源利⽤率和系统吞吐量，最终提⾼了整个系统的效率。&lt;/p&gt;</description>
      <content:encoded><![CDATA[<p><strong><a href="%e4%bd%9c%e4%b8%9a1.pdf" target="_blank">点此查看作业源文件</a>
</strong></p>
<h1 id="1什么是多道程序设计多道程序设计与分时系统的区别是什么">1.什么是多道程序设计？多道程序设计与分时系统的区别是什么？</h1>
<p>多道程序设计技术，是指允许多个程序同时进⼊内存并运⾏。即同时把多个程序放⼊内存中，并允许它们交替在CPU中运⾏，共享系统中的各种硬、软件资源，当⼀道程序因I/O请求⽽暂停运⾏时，CPU便⽴即转去运⾏另⼀道程序。多道程序设计技术提⾼了CPU、I/O设备和内存的利⽤率，从⽽提⾼了整个系统的资源利⽤率和系统吞吐量，最终提⾼了整个系统的效率。</p>
<p>多道程序设计与分时系统的区别在于：多道程序设计主要关注的是如何让多个程序在内存中同时存在并交替执⾏，以提⾼资源利⽤率。分时系统则是在多道程序设计的基础上进⼀步发展，它不仅允许多个程序并发执⾏，还通过时间⽚轮转的⽅式为每个⽤户分配CPU时间，使得多个⽤户可以⼏乎同时使⽤计算机，提供交互式服务。</p>
<h1 id="2什么原因推动了操作系统从批处理发展到多道程序进而发展到分时系统">2.什么原因推动了操作系统从批处理发展到多道程序，进而发展到分时系统？</h1>
<p>批处理系统的运⾏效率被低速I/O设备限制，CPU空闲时间多，利⽤率低，因此发展出多道程序系统；</p>
<p>多道程序系统平均周转时间⻓，不能提供交互作⽤能⼒，因此发展出允许多个⽤户共享计算机，多个程序分时共享硬、软件资源的分时系统。</p>
<h1 id="3什么是陷阱与中断的区别是什么什么是系统调用">3.什么是陷阱？与中断的区别是什么？什么是系统调用？</h1>
<p>陷阱是⼀种同步异常，是程序内部有意设置的某⼀特定指令执⾏的结果，例如系统调⽤。陷阱是程序执⾏过程中预期的⾏为，可以复现，⽤于请求操作系统提供服务等。</p>
<p>中断是⼀种异步异常，通常由外部事件（I/O设备、处理器时钟或定时器）触发，与处理器正在执⾏的内容⽆关。中断是不可预测的，⽤于处理外部事件。</p>
<p>系统调⽤是⽤户程序与操作系统内核之间的接⼝，允许⽤户程序请求操作系统提供的服务。系统调⽤本质上是⼀种同步异常，或陷阱，⽤于安全地进⼊内核模式并执⾏特权操作。</p>
<h1 id="4判断可移植的操作系统可以从一个系统架构移植到另外一个系统架构而无需修改">4.判断：可移植的操作系统可以从一个系统架构移植到另外一个系统架构而无需修改。</h1>
<p>错误。不同系统架构之间存在指令集差异、内存管理方式不同、硬件寄存器配置不一致等根本性区别，操作系统必须针对这些硬件特性进行调整。</p>
<h2 id="1请解释为什么构建完全可移植的os是不可能的">(1)请解释为什么构建完全可移植的OS是不可能的？</h2>
<p>不同硬件架构的指令集、总线设计和CPU字长等存在差异，操作系统必须依赖硬件相关代码，⽆法完全通⽤。</p>
<h2 id="2如果需要你设计一个高度可移植的os那么请描述你需要设计的两个层次">(2)如果需要你设计一个高度可移植的OS，那么请描述你需要设计的两个层次？</h2>
<p>高度可移植的操作系统由机器相关层和机器无关层组成。机器无关层只需实现一次即可。</p>
<p>机器相关层处理硬件的具体特性，必须针对每个架构单独实现。该层为机器无关层提供统一的接口。为实现高度可移植性，机器相关层的规模应尽可能最小化。</p>
<h1 id="5在设计操作系统时一些设计指标是相互矛盾的例如资源利用率吞吐量处理时间健壮性等请给出一对相互矛盾的设计实例">5.在设计操作系统时，一些设计指标是相互矛盾的，例如资源利用率、吞吐量、处理时间、健壮性等。请给出一对相互矛盾的设计实例。</h1>
<p>资源利⽤率与响应时间。</p>
<p>资源利⽤率⾼意味着尽可能多地利⽤系统资源，但可能导致频繁的切换和复杂的调度策略，从⽽增加响应时间。响应时间短要求操作系统能够快速响应⽤户请求，可能保留更多的资源⽤于即时响应，导致资源利⽤率下降。</p>
<h1 id="6一个计算机系统有输入机一台打印机两台现有二道程序同时投入运行且程序a先开始运行程序b后运行程序a的运行轨迹为计算50ms打印信息100ms再计算50ms打印信息100ms结束程序b运行的轨迹为计算50ms输入数据80ms再计算100ms结束要求">6.一个计算机系统有输入机一台、打印机两台，现有二道程序同时投入运行，且程序A先开始运行，程序B后运行。程序A的运行轨迹为：计算50ms，打印信息100ms，再计算50ms，打印信息100ms，结束。程序B运行的轨迹为：计算50ms，输入数据80ms，再计算100ms，结束。要求：</h1>
<h2 id="1用图画出这二道程序并发执行时的工作情况">(1)用图画出这二道程序并发执行时的工作情况。</h2>
<p><div class="post-img-view">
    <a data-fancybox="gallery"
         href="Pasted%20image%2020250316112252.png">
        <img loading="lazy" src="/posts/buaa/os/homework-1/Pasted%20image%2020250316112252_hu_714830f66a53f33c.webp">
    </a>
</div></p>
<h2 id="2说明在二道程序运行时cpu有无空闲等待若有在哪段时间内等待为什么会空闲等待">(2)说明在二道程序运行时，CPU有无空闲等待？若有，在哪段时间内等待？为什么会空闲等待？</h2>
<p>有。在100ms~150ms，程序A在打印信息，程序B在输入数据，故CPU处于空闲等待。</p>
<h2 id="3程序ab运行时有无等待现象在什么时候会发生等待现象">(3)程序A、B运行时有无等待现象？在什么时候会发生等待现象？</h2>
<p>程序A没有，程序B有。</p>
<p>在180ms~200ms，程序B完成了输入数据，在等待CPU空闲，而程序A占用了处理器，正在进行计算，故程序B等待了20ms。</p>
]]></content:encoded>
    </item>
    <item>
      <title>[BUAA-OO] Unit 1 递归函数调用的解析与计算</title>
      <link>https://oNya685.github.io/posts/buaa/oo/unit-1/homework-2-function/</link>
      <pubDate>Wed, 05 Mar 2025 20:48:35 +0000</pubDate>
      <guid>https://oNya685.github.io/posts/buaa/oo/unit-1/homework-2-function/</guid>
      <description>&lt;h1 id=&#34;函数调用处理机制&#34;&gt;函数调用处理机制&lt;/h1&gt;
&lt;h2 id=&#34;核心思路&#34;&gt;核心思路&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;实参与形参分离&lt;/strong&gt;：通过&lt;code&gt;assignment&lt;/code&gt;哈希表实现参数映射，实现&lt;strong&gt;形参&lt;/strong&gt;（函数定义时的参数名）与&lt;strong&gt;相对实参&lt;/strong&gt;（调用时传入的具体因子）的对应关系。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;递归替换&lt;/strong&gt;：通过&lt;code&gt;assign&lt;/code&gt;方法逐层展开函数调用&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;终止条件&lt;/strong&gt;：当递归到&lt;strong&gt;初始定义&lt;/strong&gt;表达式时完成解析&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;关键实现步骤&#34;&gt;关键实现步骤&lt;/h2&gt;
&lt;h3 id=&#34;数据结构&#34;&gt;数据结构&lt;/h3&gt;
&lt;p&gt;为函数调用因子引入通过&lt;code&gt;HashMap&amp;lt;String, Factor&amp;gt;&lt;/code&gt;实现的新成员变量&lt;code&gt;assignment&lt;/code&gt;，并在为语素实现的&lt;code&gt;assign&lt;/code&gt;方法中作为传入参数。&lt;/p&gt;</description>
      <content:encoded><![CDATA[<h1 id="函数调用处理机制">函数调用处理机制</h1>
<h2 id="核心思路">核心思路</h2>
<ol>
<li><strong>实参与形参分离</strong>：通过<code>assignment</code>哈希表实现参数映射，实现<strong>形参</strong>（函数定义时的参数名）与<strong>相对实参</strong>（调用时传入的具体因子）的对应关系。</li>
<li><strong>递归替换</strong>：通过<code>assign</code>方法逐层展开函数调用</li>
<li><strong>终止条件</strong>：当递归到<strong>初始定义</strong>表达式时完成解析</li>
</ol>
<h2 id="关键实现步骤">关键实现步骤</h2>
<h3 id="数据结构">数据结构</h3>
<p>为函数调用因子引入通过<code>HashMap&lt;String, Factor&gt;</code>实现的新成员变量<code>assignment</code>，并在为语素实现的<code>assign</code>方法中作为传入参数。</p>
<p>对于<code>FuncCall</code>因子，引入<code>Integer index</code>，<code>FuncDefine</code>，<code>ArrayList&lt;Factor&gt;</code>，用于实现对Expr中的FuncCall因子的完全解析。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">FuncCall</span> <span style="color:#66d9ef">extends</span> VarFactor {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">final</span> ConstantFactor index;  
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">final</span> FuncDefine define;  
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">final</span> HashMap<span style="color:#f92672">&lt;</span>BaseVar, Factor<span style="color:#f92672">&gt;</span> assignment; <span style="color:#75715e">// 实际参数列表</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="处理流程">处理流程</h3>
<p>通过<code>expr = expr.assign(null)</code>中调用<code>funcCall.define.get(index).assign(assignment).assign(null)</code>，因除<code>FuncCall</code>以外的其他语素有其<code>assign</code>方法，所以将不断递归下降直到<code>funcCall.define.get(1)</code>和<code>funcCall.define.get(0)</code>。此时再递归向下将不再出现<code>FuncCall</code>类，递归结束并逐级返回。从而实现的<code>Expr</code>的去<code>FuncCall</code>流程，以便进行<code>toPoly</code>和<code>simplify</code>。</p>
<ol>
<li>
<p><strong>初始化调用</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>expr <span style="color:#f92672">=</span> expr.<span style="color:#a6e22e">assign</span>(<span style="color:#66d9ef">null</span>);
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 通过expr.assign(null)启动替换链条，null参数表示要解析的最上层表达式中的参数为绝对实参</span>
</span></span></code></pre></div></li>
<li>
<p><strong>参数替换机制</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">// FuncCall.java</span>
</span></span><span style="display:flex;"><span>ExprFactor <span style="color:#a6e22e">assign</span>(HashMap<span style="color:#f92672">&lt;</span>String, Factor<span style="color:#f92672">&gt;</span> assignment) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">define</span>.<span style="color:#a6e22e">get</span>(<span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">index</span>)
</span></span><span style="display:flex;"><span>        .<span style="color:#a6e22e">assign</span>(<span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">assignment</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 先应用this.assignment当前层的参数绑定</span>
</span></span><span style="display:flex;"><span>        .<span style="color:#a6e22e">assign</span>(assignment);
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 再应用外层传入的assignment参数，实现参数作用域的嵌套覆盖</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div></li>
<li>
<p><strong>递归展开过程</strong></p>
<pre tabindex="0"><code>// 高层调用 → 中间层展开 → 基础层解析
funcCall.assign(null)
→ funcCall.define.get(index).assign(assignment).assign(null)
→ ...
→ funcCall&#39;.define.get(index&#39;).assign(assignment&#39;).assign(assignment).assign(null)
→ ...
→ funcCall&#39;&#39;.define.get(index&#39;&#39;).assign(assignment&#39;&#39;).assign(assignment&#39;).assign(assignment).assign(null)
→ ...
→ funcCall.define.get(0 | 1).assign... // 初始定义表达式
</code></pre></li>
</ol>
<h3 id="类方法实现">类方法实现</h3>
<p>经<code>assign</code>方法，<code>BaseVar.assign(assignment)</code>返回<code>Factor</code>，<code>PowerFunc.assign(assignment)</code>返回<code>ExprFactor</code>，<code>FuncCall</code>递归调用<code>(Expr)define.get(this.index).assign(this.assignment).assign(assignment)</code>返回<code>ExprFactor</code>，其他语素的<code>assign</code>方法返回同类对象。最终递归返回不含<code>FuncCall</code>的纯<code>Expr</code>，即可施之<code>toPoly</code>方法。</p>
<table>
  <thead>
      <tr>
          <th>类名</th>
          <th>assign方法行为</th>
          <th>返回类型</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>BaseVar</td>
          <td>直接返回对应的含相对实参的Factor</td>
          <td>Factor</td>
      </tr>
      <tr>
          <td>PowerFunc</td>
          <td>返回参数赋值的ExprFactor</td>
          <td>ExprFactor</td>
      </tr>
      <tr>
          <td>FuncCall</td>
          <td>递归调用下层定义进行参数替换</td>
          <td>ExprFactor</td>
      </tr>
      <tr>
          <td>其他因子</td>
          <td>返回由自身组成语素.assign()构造的同类对象</td>
          <td>同类对象</td>
      </tr>
  </tbody>
</table>
<h2 id="处理终点">处理终点</h2>
<p>当递归到<code>define.get(0 | 1)</code>时：</p>
<ol>
<li>不再包含FuncCall对象，函数调用结构完全消解</li>
<li>所有形参已被实际参数替换</li>
<li>表达式完全展开为基本元素</li>
<li>可安全调用<code>toPoly()</code>进行多项式转换</li>
<li>可进行最终化简<code>simplify()</code></li>
</ol>
]]></content:encoded>
    </item>
  </channel>
</rss>
