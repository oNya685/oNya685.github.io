<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Operating System on oNya&#39;s Blog</title>
    <link>https://oNya685.github.io/categories/operating-system/</link>
    <description>Recent content in Operating System on oNya&#39;s Blog</description>
    <generator>Hugo -- 0.145.0</generator>
    <language>zh-cn</language>
    <lastBuildDate>Fri, 28 Mar 2025 19:00:00 +0800</lastBuildDate>
    <atom:link href="https://oNya685.github.io/categories/operating-system/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>[BUAA-OS] 理论作业 2</title>
      <link>https://oNya685.github.io/posts/buaa/os/homework-2/</link>
      <pubDate>Fri, 28 Mar 2025 19:00:00 +0800</pubDate>
      <guid>https://oNya685.github.io/posts/buaa/os/homework-2/</guid>
      <description>&lt;p&gt;&lt;strong&gt;&lt;a href=&#34;%e4%bd%9c%e4%b8%9a2.pdf&#34; target=&#34;_blank&#34;&gt;点此查看作业源文件&lt;/a&gt;
&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&#34;1-动态内存分配需要对内存分区进行管理一般使用位图和空闲链表两种方法128mb的内存以n字节为单元分配对于链表假设内存中数据段和空闲区交替排列长度均为64kb并假设链表中的每个节点需要记录32位的内存地址信息16位长度信息和16位下一节点域信息这两种方法分别需要多少字节的存储空间哪种方法更好&#34;&gt;1. 动态内存分配需要对内存分区进行管理，一般使用位图和空闲链表两种方法。128MB的内存以n字节为单元分配，对于链表，假设内存中数据段和空闲区交替排列，长度均为64KB。并假设链表中的每个节点需要记录32位的内存地址信息、16位长度信息和16位下一节点域信息。这两种方法分别需要多少字节的存储空间？哪种方法更好？&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;若使用位图方法：&lt;/li&gt;
&lt;/ul&gt;
$$单元数 = \frac{128MB}{nB} = \frac{2^{27}}{n}块$$$$所需存储空间 = \frac{2^{27}}{n}b = \frac{16}{n}MB$$&lt;ul&gt;
&lt;li&gt;若使用空闲链表方法：&lt;/li&gt;
&lt;/ul&gt;
$$段数=\frac{128MB}{64KB+64KB} = 2^{10}段$$$$所需存储空间 = 2^{10} \times (32 + 16 + 16)b = 8KB$$&lt;ul&gt;
&lt;li&gt;哪种方法更好：
&lt;ul&gt;
&lt;li&gt;当n&amp;lt;2048时，空闲链表所需存储空间更小，空闲链表方法更好；&lt;/li&gt;
&lt;li&gt;当n&amp;gt;2048时，位图所需存储空间更小，位图方法更好。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;2-在一个交换系统中按内存地址排列的空闲区大小是-10kb4kb20kb18kb7kb9kb12kb和15kb对于连续的段请求12kb10kb9kb使用firstfitbestfitworstfit和nextfit将找出哪些空闲区&#34;&gt;2. 在一个交换系统中，按内存地址排列的空闲区大小是: 10KB、4KB、20KB、18KB、7KB、9KB、12KB和15KB。对于连续的段请求：12KB、10KB、9KB。使用FirstFit、BestFit、WorstFit和NextFit将找出哪些空闲区？&lt;/h1&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;段请求&lt;/th&gt;
          &lt;th&gt;FirstFit&lt;/th&gt;
          &lt;th&gt;BestFit&lt;/th&gt;
          &lt;th&gt;WorstFit&lt;/th&gt;
          &lt;th&gt;NextFit&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;12KB&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;20KB&lt;/td&gt;
          &lt;td&gt;12KB&lt;/td&gt;
          &lt;td&gt;20KB&lt;/td&gt;
          &lt;td&gt;20KB&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;10KB&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;10KB&lt;/td&gt;
          &lt;td&gt;10KB&lt;/td&gt;
          &lt;td&gt;18KB&lt;/td&gt;
          &lt;td&gt;18KB&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;9KB&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;18KB&lt;/td&gt;
          &lt;td&gt;9KB&lt;/td&gt;
          &lt;td&gt;15KB&lt;/td&gt;
          &lt;td&gt;9KB&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;h1 id=&#34;3-解释逻辑地址物理地址地址映射并举例说明&#34;&gt;3. 解释逻辑地址、物理地址、地址映射，并举例说明。&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;逻辑地址（Logical Address）：
逻辑地址是程序运行时由 CPU 生成的地址，也称为虚拟地址。用户进程只能访问逻辑地址，不能直接访问物理内存。&lt;br&gt;
例如某程序访问地址 &lt;code&gt;0x1234&lt;/code&gt;，但该地址只是进程的逻辑地址空间中的一部分。&lt;/p&gt;</description>
      <content:encoded><![CDATA[<p><strong><a href="%e4%bd%9c%e4%b8%9a2.pdf" target="_blank">点此查看作业源文件</a>
</strong></p>
<h1 id="1-动态内存分配需要对内存分区进行管理一般使用位图和空闲链表两种方法128mb的内存以n字节为单元分配对于链表假设内存中数据段和空闲区交替排列长度均为64kb并假设链表中的每个节点需要记录32位的内存地址信息16位长度信息和16位下一节点域信息这两种方法分别需要多少字节的存储空间哪种方法更好">1. 动态内存分配需要对内存分区进行管理，一般使用位图和空闲链表两种方法。128MB的内存以n字节为单元分配，对于链表，假设内存中数据段和空闲区交替排列，长度均为64KB。并假设链表中的每个节点需要记录32位的内存地址信息、16位长度信息和16位下一节点域信息。这两种方法分别需要多少字节的存储空间？哪种方法更好？</h1>
<ul>
<li>若使用位图方法：</li>
</ul>
$$单元数 = \frac{128MB}{nB} = \frac{2^{27}}{n}块$$$$所需存储空间 = \frac{2^{27}}{n}b = \frac{16}{n}MB$$<ul>
<li>若使用空闲链表方法：</li>
</ul>
$$段数=\frac{128MB}{64KB+64KB} = 2^{10}段$$$$所需存储空间 = 2^{10} \times (32 + 16 + 16)b = 8KB$$<ul>
<li>哪种方法更好：
<ul>
<li>当n&lt;2048时，空闲链表所需存储空间更小，空闲链表方法更好；</li>
<li>当n&gt;2048时，位图所需存储空间更小，位图方法更好。</li>
</ul>
</li>
</ul>
<h1 id="2-在一个交换系统中按内存地址排列的空闲区大小是-10kb4kb20kb18kb7kb9kb12kb和15kb对于连续的段请求12kb10kb9kb使用firstfitbestfitworstfit和nextfit将找出哪些空闲区">2. 在一个交换系统中，按内存地址排列的空闲区大小是: 10KB、4KB、20KB、18KB、7KB、9KB、12KB和15KB。对于连续的段请求：12KB、10KB、9KB。使用FirstFit、BestFit、WorstFit和NextFit将找出哪些空闲区？</h1>
<table>
  <thead>
      <tr>
          <th>段请求</th>
          <th>FirstFit</th>
          <th>BestFit</th>
          <th>WorstFit</th>
          <th>NextFit</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>12KB</strong></td>
          <td>20KB</td>
          <td>12KB</td>
          <td>20KB</td>
          <td>20KB</td>
      </tr>
      <tr>
          <td><strong>10KB</strong></td>
          <td>10KB</td>
          <td>10KB</td>
          <td>18KB</td>
          <td>18KB</td>
      </tr>
      <tr>
          <td><strong>9KB</strong></td>
          <td>18KB</td>
          <td>9KB</td>
          <td>15KB</td>
          <td>9KB</td>
      </tr>
  </tbody>
</table>
<h1 id="3-解释逻辑地址物理地址地址映射并举例说明">3. 解释逻辑地址、物理地址、地址映射，并举例说明。</h1>
<ol>
<li>
<p>逻辑地址（Logical Address）：
逻辑地址是程序运行时由 CPU 生成的地址，也称为虚拟地址。用户进程只能访问逻辑地址，不能直接访问物理内存。<br>
例如某程序访问地址 <code>0x1234</code>，但该地址只是进程的逻辑地址空间中的一部分。</p>
</li>
<li>
<p>物理地址（Physical Address）：<br>
物理地址是实际存在于内存（RAM）中的地址，由操作系统和硬件管理。<br>
例子： 逻辑地址 <code>0x1234</code> 可能被映射到物理内存的 <code>0xABCD1234</code>。</p>
</li>
<li>
<p>地址映射（Address Mapping）：<br>
地址映射是逻辑地址到物理地址的转换过程，通常由MMU通过分页、分段、段页结合等方式完成。
例子： 在分页系统中，逻辑地址 <code>0x1234</code> 可能属于页号2，页内偏移 <code>0x034</code>，MMU 通过页表找到物理页框5，映射后的物理地址为 <code>0x5034</code>。</p>
</li>
</ol>
<h1 id="4-解释页式段式存储管理中为什么要设置页段表和快表简述页式段式地址转换过程">4. 解释页式（段式）存储管理中为什么要设置页（段）表和快表，简述页式（段式）地址转换过程。</h1>
<ol>
<li>
<p>为什么要设置页（段）表和快表</p>
<ul>
<li>页表（段表）：用于记录逻辑地址到物理地址的映射关系，存储完整的映射信息，保证进程可以正确访问物理内存。</li>
<li>快表：是一种高速缓存，用于存储最近访问的页（段）表项，加速地址转换，提高地址转换效率，减少访问内存的开销。</li>
</ul>
</li>
<li>
<p>页式存储管理的地址转换过程</p>
<ol>
<li>CPU 生成逻辑地址，包含页号和页内偏移。</li>
<li>查询 TLB，如果页号在 TLB 中，则直接获取对应的物理页框号，得到物理地址。</li>
<li>若TLB 未命中（缺页表项），需要访问页表，通过页号查找对应的物理页框号。</li>
<li>组合物理页框号和页内偏移，形成物理地址，访问数据。</li>
<li>更新 TLB（如果 TLB 未命中，则将新查找的页表项加入 TLB）。</li>
</ol>
</li>
<li>
<p>段式存储管理的地址转换过程</p>
<ol>
<li>CPU 生成逻辑地址，包含段号和段内偏移。</li>
<li>查询 TLB，如果段号在 TLB 中，则直接获取段的基址，计算物理地址。</li>
<li>若TLB 未命中，访问段表，查找段号对应的段基址和段界限。</li>
<li>检查越界，如果段内偏移&gt;段界限，发生段越界异常，否则继续计算。</li>
<li>物理地址 = 段基址 + 段内偏移，然后访问数据。</li>
<li>更新 TLB（如果 TLB 未命中，则将新的段表项加入 TLB）。</li>
</ol>
</li>
</ol>
<h1 id="5-叙述缺页中断的处理流程">5. 叙述缺页中断的处理流程。</h1>
<p>缺页中断发生在进程访问的页面不在内存时，系统需要从外存加载该页面到内存。处理流程如下：</p>
<ol>
<li>
<p>产生缺页中断</p>
<ul>
<li>进程访问某个逻辑地址，CPU 通过页表查找对应的物理页框。</li>
<li>如果该页表项无效（页不在内存），则触发缺页中断。</li>
</ul>
</li>
<li>
<p>保存进程状态</p>
<ul>
<li>CPU 保存当前进程的上下文，包括程序计数器（PC）和寄存器等，确保中断后能恢复执行。</li>
</ul>
</li>
<li>
<p>操作系统处理缺页</p>
<ul>
<li>查找页表：操作系统检查该页是否有效。
<ul>
<li>有效但不在内存 → 继续处理。</li>
<li>非法访问 → 触发异常（如段错误），终止进程。</li>
</ul>
</li>
<li>选择物理页框：
<ul>
<li>若有空闲页框，直接使用。</li>
<li>若内存已满，使用页面置换算法（如 FIFO、LRU）淘汰一个旧页面。</li>
</ul>
</li>
</ul>
</li>
<li>
<p>读取页面到内存</p>
<ul>
<li>从外存（如磁盘）读取所需页面，拷贝到选定的物理页框。</li>
</ul>
</li>
<li>
<p>更新页表和 TLB</p>
<ul>
<li>修改页表项，标记该页已在内存，并更新页框号。</li>
<li>若该页表项在 TLB（快表）中，需更新或清除 TLB 旧项，保证地址转换正确。</li>
</ul>
</li>
<li>
<p>恢复进程执行</p>
<ul>
<li>恢复进程上下文，重新执行触发缺页的指令。</li>
<li>由于该页已加载到内存，不会再次触发缺页中断。</li>
</ul>
</li>
</ol>
<h1 id="6-假设一个机器有38位的虚拟地址和32位的物理地址">6. 假设一个机器有38位的虚拟地址和32位的物理地址。</h1>
<h2 id="1-与一级页表相比多级页表的主要优点是什么">(1) 与一级页表相比，多级页表的主要优点是什么？</h2>
<ul>
<li>空间利用率高。多级页表只在需要时分配低层页表，从而避免为整个虚拟地址空间都预留大量连续的页表空间，节省内存空间。</li>
</ul>
<h2 id="2如果使用二级页表页面大小为16kb每个页表项有4个字节应该为虚拟地址中的第一级和第二级页表域各分配多少位">(2) 如果使用二级页表，页面大小为16KB，每个页表项有4个字节。应该为虚拟地址中的第一级和第二级页表域各分配多少位？</h2>
<p>页面大小为 16KB，即</p>
$$16\,\text{KB} = 16 \times 1024 = 2^{14}\,\text{字节}$$<p>因此页内偏移需要 14 位，虚拟地址结构如下：</p>
$$\underbrace{\text{第一级页表域}}_{x\,\text{位}}\,\,\underbrace{\text{第二级页表域}}_{y\,\text{位}}\,\,\underbrace{\text{页内偏移}}_{14\,\text{位}}$$<p>虚拟地址为38位，因此$x + y + 14 = 38位$，所以$x + y = 24,\text{位}$。</p>
<p>每个页表项为4B，页表页的大小与页面大小相同，即16KB。一个页表页能容纳的页表项个数为</p>
$$\frac{16\,\text{KB}}{4\,\text{B}} = 4096 = 2^{12}\,\text{项}$$<p>因此第二级页表的索引域需要12位，即$y=12$。</p>
<p>由$x+y=24$可得$x=12$。即：</p>
$$\underbrace{\text{第一级页表域}}_{12\,\text{位}}\,\,\underbrace{\text{第二级页表域}}_{12\,\text{位}}\,\,\underbrace{\text{页内偏移}}_{14\,\text{位}}$$<h1 id="7-假设页面的访问存在一定的周期性循环但周期之间会随机出现一些页面的访问例如012511431012511332012511等请思考">7. 假设页面的访问存在一定的周期性循环，但周期之间会随机出现一些页面的访问。例如：0,1,2…,511,431,0,1,2…511,332,0,1,2,…,511等。请思考：</h1>
<h2 id="1lrufifo和clock算法的效果如何">(1) LRU、FIFO和Clock算法的效果如何？</h2>
<p>如果物理页框数不足512个，三种算法会发生相同的几乎全部缺页问题。</p>
<h2 id="2如果有500个页框能否设计一个优于lrufifo和clock的算法">(2) 如果有500个页框，能否设计一个优于LRU、FIFO和Clock的算法？</h2>
<p>其中499个页框对应存储0-498页，第500个页框用于置换。</p>
<h1 id="8-一个交换系统通过紧缩技术来清理碎片如果内存碎片和数据区域是随机分配的而且假设读写32位内存字需要10nsec-那么如果紧缩128mb的内存需要多久简单起见假设第0个字是碎片的一部分而最高位的字包含了有效的数据">8. 一个交换系统通过紧缩技术来清理碎片。如果内存碎片和数据区域是随机分配的。而且假设读写32位内存字需要10nsec. 那么如果紧缩128MB的内存需要多久？简单起见，假设第0个字是碎片的一部分而最高位的字包含了有效的数据。</h1>
$$128MB=\frac{128\times 2^{23}b}{32b/word} = 2^{25}words$$$$T=2^{25}words \times (10ns/word + 10ns/word) = 6.711\times 10^8ns = 0.6711s$$<p>需要约$0.6711s$。</p>
]]></content:encoded>
    </item>
    <item>
      <title>[BUAA-OS] Lab 1 实验报告</title>
      <link>https://oNya685.github.io/posts/buaa/os/lab-1-report/</link>
      <pubDate>Fri, 28 Mar 2025 10:06:33 +0800</pubDate>
      <guid>https://oNya685.github.io/posts/buaa/os/lab-1-report/</guid>
      <description>&lt;h1 id=&#34;一思考题&#34;&gt;一、思考题&lt;/h1&gt;
&lt;h2 id=&#34;thinking-11&#34;&gt;Thinking 1.1&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;在阅读附录中的编译链接详解以及本章内容后，尝试分别使用实验环境中的原生x86工具链（gcc、ld、readelf、objdump等）和MIPS交叉编译工具链（带有mips-linux-gnu-前缀，如mips-linux-gnu-gcc、mips-linux-gnu-ld），重复其中的编译和解析过程，观察相应的结果，并解释其中向objdump传入的参数的含义。&lt;/p&gt;</description>
      <content:encoded><![CDATA[<h1 id="一思考题">一、思考题</h1>
<h2 id="thinking-11">Thinking 1.1</h2>
<blockquote>
<p>在阅读附录中的编译链接详解以及本章内容后，尝试分别使用实验环境中的原生x86工具链（gcc、ld、readelf、objdump等）和MIPS交叉编译工具链（带有mips-linux-gnu-前缀，如mips-linux-gnu-gcc、mips-linux-gnu-ld），重复其中的编译和解析过程，观察相应的结果，并解释其中向objdump传入的参数的含义。</p></blockquote>
<hr>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>git@23373270:~/test $  gcc -E hello.c &gt; gcc-E.out
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># gcc-E.out:</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>...<span style="color:#f92672">(</span>&lt;stdio.h&gt;的内容<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 2 &#34;hello.c&#34; 2</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 3 &#34;hello.c&#34;</span>
</span></span><span style="display:flex;"><span>int main<span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    printf<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;Hello World!\n&#34;</span><span style="color:#f92672">)</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> 0;
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>git@23373270:~/test $  mips-linux-gnu-gcc -E hello.c &gt; mips-gcc-E.out
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># mips-gcc-E.out:</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>...<span style="color:#f92672">(</span>&lt;stdio.h&gt;的内容<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 2 &#34;hello.c&#34; 2</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 3 &#34;hello.c&#34;</span>
</span></span><span style="display:flex;"><span>int main<span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    printf<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;Hello World!\n&#34;</span><span style="color:#f92672">)</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> 0;
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><p>进行预处理的情况下，两者几乎没有区别。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>git@23373270:~/test $  gcc -c hello.c
</span></span><span style="display:flex;"><span>git@23373270:~/test $  objdump -DS hello.o &gt; objdump-DS.out
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># objdump-DS.out:</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>hello.o：     文件格式 elf64-x86-64
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Disassembly of section .text:
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">0000000000000000</span> &lt;main&gt;:
</span></span><span style="display:flex;"><span>   0:   f3 0f 1e fa             endbr64
</span></span><span style="display:flex;"><span>   4:   <span style="color:#ae81ff">55</span>                      push   %rbp
</span></span><span style="display:flex;"><span>   5:   <span style="color:#ae81ff">48</span> <span style="color:#ae81ff">89</span> e5                mov    %rsp,%rbp
</span></span><span style="display:flex;"><span>   8:   <span style="color:#ae81ff">48</span> 8d <span style="color:#ae81ff">05</span> <span style="color:#ae81ff">00</span> <span style="color:#ae81ff">00</span> <span style="color:#ae81ff">00</span> <span style="color:#ae81ff">00</span>    lea    0x0<span style="color:#f92672">(</span>%rip<span style="color:#f92672">)</span>,%rax        <span style="color:#75715e"># f &lt;main+0xf&gt;</span>
</span></span><span style="display:flex;"><span>   f:   <span style="color:#ae81ff">48</span> <span style="color:#ae81ff">89</span> c7                mov    %rax,%rdi
</span></span><span style="display:flex;"><span>  12:   e8 <span style="color:#ae81ff">00</span> <span style="color:#ae81ff">00</span> <span style="color:#ae81ff">00</span> <span style="color:#ae81ff">00</span>          call   <span style="color:#ae81ff">17</span> &lt;main+0x17&gt;
</span></span><span style="display:flex;"><span>  17:   b8 <span style="color:#ae81ff">00</span> <span style="color:#ae81ff">00</span> <span style="color:#ae81ff">00</span> <span style="color:#ae81ff">00</span>          mov    $0x0,%eax
</span></span><span style="display:flex;"><span>  1c:   5d                      pop    %rbp
</span></span><span style="display:flex;"><span>  1d:   c3                      ret
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Disassembly of section .rodata:
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">0000000000000000</span> &lt;.rodata&gt;:
</span></span><span style="display:flex;"><span>...
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Disassembly of section .comment:
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">0000000000000000</span> &lt;.comment&gt;:
</span></span><span style="display:flex;"><span>...
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Disassembly of section .note.gnu.property:
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">0000000000000000</span> &lt;.note.gnu.property&gt;:
</span></span><span style="display:flex;"><span>...
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Disassembly of section .eh_frame:
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">0000000000000000</span> &lt;.eh_frame&gt;:
</span></span><span style="display:flex;"><span>...
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>git@23373270:~/test $  mips-linux-gnu-gcc -c hello.c
</span></span><span style="display:flex;"><span>git@23373270:~/test $  mips-linux-gnu-objdump -DS hello.o &gt; mips-objdump-DS.out
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># mips-objdump-DS.out:</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>hello.o：     文件格式 elf32-tradbigmips
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Disassembly of section .text:
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">00000000</span> &lt;main&gt;:
</span></span><span style="display:flex;"><span>   0:   27bdffe0        addiu   sp,sp,-32
</span></span><span style="display:flex;"><span>   4:   afbf001c        sw      ra,28<span style="color:#f92672">(</span>sp<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>   8:   afbe0018        sw      s8,24<span style="color:#f92672">(</span>sp<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>   c:   03a0f025        move    s8,sp
</span></span><span style="display:flex;"><span>  10:   3c1c0000        lui     gp,0x0
</span></span><span style="display:flex;"><span>  14:   279c0000        addiu   gp,gp,0
</span></span><span style="display:flex;"><span>  18:   afbc0010        sw      gp,16<span style="color:#f92672">(</span>sp<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>  1c:   3c020000        lui     v0,0x0
</span></span><span style="display:flex;"><span>  20:   <span style="color:#ae81ff">24440000</span>        addiu   a0,v0,0
</span></span><span style="display:flex;"><span>  24:   8f820000        lw      v0,0<span style="color:#f92672">(</span>gp<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>  28:   0040c825        move    t9,v0
</span></span><span style="display:flex;"><span>  2c:   0320f809        jalr    t9
</span></span><span style="display:flex;"><span>  30:   <span style="color:#ae81ff">00000000</span>        nop
</span></span><span style="display:flex;"><span>  34:   8fdc0010        lw      gp,16<span style="color:#f92672">(</span>s8<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>  38:   <span style="color:#ae81ff">00001025</span>        move    v0,zero
</span></span><span style="display:flex;"><span>  3c:   03c0e825        move    sp,s8
</span></span><span style="display:flex;"><span>  40:   8fbf001c        lw      ra,28<span style="color:#f92672">(</span>sp<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>  44:   8fbe0018        lw      s8,24<span style="color:#f92672">(</span>sp<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>  48:   27bd0020        addiu   sp,sp,32
</span></span><span style="display:flex;"><span>  4c:   03e00008        jr      ra
</span></span><span style="display:flex;"><span>  50:   <span style="color:#ae81ff">00000000</span>        nop
</span></span><span style="display:flex;"><span>        ...
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Disassembly of section .reginfo:
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">00000000</span> &lt;.reginfo&gt;:
</span></span><span style="display:flex;"><span>...
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Disassembly of section .MIPS.abiflags:
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">00000000</span> &lt;.MIPS.abiflags&gt;:
</span></span><span style="display:flex;"><span>...
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Disassembly of section .pdr:
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">00000000</span> &lt;.pdr&gt;:
</span></span><span style="display:flex;"><span>...
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Disassembly of section .rodata:
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">00000000</span> &lt;.rodata&gt;:
</span></span><span style="display:flex;"><span>...
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Disassembly of section .comment:
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">00000000</span> &lt;.comment&gt;:
</span></span><span style="display:flex;"><span>...
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Disassembly of section .gnu.attributes:
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">00000000</span> &lt;.gnu.attributes&gt;:
</span></span><span style="display:flex;"><span>...
</span></span></code></pre></div><p>只编译不链接，生成目标文件，发现被编译为不同的汇编语言，且分别为64位和32位。</p>
<p>其中向<code>objdump</code>传入参数<code>-D</code>和<code>-S</code>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>git@23373270:~/test $  objdump --help
</span></span><span style="display:flex;"><span>    -D, --disassemble-all    Display assembler contents of all sections
</span></span><span style="display:flex;"><span>    -S, --source             Intermix source code with disassembly
</span></span></code></pre></div><p><code>-D</code>：显示所有段的汇编内容
<code>-S</code>：将源代码与反汇编代码混合显示</p>
<h2 id="thinking-12">Thinking 1.2</h2>
<blockquote>
<p>思考下述问题：</p>
<ul>
<li>尝试使用我们编写的readelf程序，解析之前在target目录下生成的内核ELF文件。</li>
<li>也许你会发现我们编写的readelf程序是不能解析readelf文件本身的，而我们刚才介绍的系统工具readelf则可以解析，这是为什么呢？（提示：尝试使用readelf -h，并阅读tools/readelf目录下的Makefile，观察readelf与hello的不同）</li>
</ul></blockquote>
<hr>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>git@23373270:~/23373270 <span style="color:#f92672">(</span>lab1<span style="color:#f92672">)</span>$  tools/readelf/readelf target/mos
</span></span><span style="display:flex;"><span>0:0x0
</span></span><span style="display:flex;"><span>1:0x80020000
</span></span><span style="display:flex;"><span>2:0x80021930
</span></span><span style="display:flex;"><span>3:0x80021948
</span></span><span style="display:flex;"><span>4:0x80021960
</span></span><span style="display:flex;"><span>5:0x0
</span></span><span style="display:flex;"><span>6:0x0
</span></span><span style="display:flex;"><span>7:0x0
</span></span><span style="display:flex;"><span>8:0x0
</span></span><span style="display:flex;"><span>9:0x0
</span></span><span style="display:flex;"><span>10:0x0
</span></span><span style="display:flex;"><span>11:0x0
</span></span><span style="display:flex;"><span>12:0x0
</span></span><span style="display:flex;"><span>13:0x0
</span></span><span style="display:flex;"><span>14:0x0
</span></span><span style="display:flex;"><span>15:0x0
</span></span><span style="display:flex;"><span>16:0x0
</span></span><span style="display:flex;"><span>17:0x0
</span></span><span style="display:flex;"><span>18:0x0
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>git@23373270:~/23373270/tools/readelf <span style="color:#f92672">(</span>lab1<span style="color:#f92672">)</span>$  readelf -h readelf
</span></span><span style="display:flex;"><span>ELF 头：
</span></span><span style="display:flex;"><span>  Magic：   7f <span style="color:#ae81ff">45</span> 4c <span style="color:#ae81ff">46</span> <span style="color:#ae81ff">02</span> <span style="color:#ae81ff">01</span> <span style="color:#ae81ff">01</span> <span style="color:#ae81ff">00</span> <span style="color:#ae81ff">00</span> <span style="color:#ae81ff">00</span> <span style="color:#ae81ff">00</span> <span style="color:#ae81ff">00</span> <span style="color:#ae81ff">00</span> <span style="color:#ae81ff">00</span> <span style="color:#ae81ff">00</span> <span style="color:#ae81ff">00</span>
</span></span><span style="display:flex;"><span>  类别:                              ELF64
</span></span><span style="display:flex;"><span>  数据:                              <span style="color:#ae81ff">2</span> 补码，小端序 <span style="color:#f92672">(</span>little endian<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>  Version:                           <span style="color:#ae81ff">1</span> <span style="color:#f92672">(</span>current<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>  OS/ABI:                            UNIX - System V
</span></span><span style="display:flex;"><span>  ABI 版本:                          <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>  类型:                              DYN <span style="color:#f92672">(</span>Position-Independent Executable file<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>  系统架构:                          Advanced Micro Devices X86-64
</span></span><span style="display:flex;"><span>  版本:                              0x1
</span></span><span style="display:flex;"><span>  入口点地址：               0x1180
</span></span><span style="display:flex;"><span>  程序头起点：          <span style="color:#ae81ff">64</span> <span style="color:#f92672">(</span>bytes into file<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>  Start of section headers:          <span style="color:#ae81ff">14488</span> <span style="color:#f92672">(</span>bytes into file<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>  标志：             0x0
</span></span><span style="display:flex;"><span>  Size of this header:               <span style="color:#ae81ff">64</span> <span style="color:#f92672">(</span>bytes<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>  Size of program headers:           <span style="color:#ae81ff">56</span> <span style="color:#f92672">(</span>bytes<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>  Number of program headers:         <span style="color:#ae81ff">13</span>
</span></span><span style="display:flex;"><span>  Size of section headers:           <span style="color:#ae81ff">64</span> <span style="color:#f92672">(</span>bytes<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>  Number of section headers:         <span style="color:#ae81ff">31</span>
</span></span><span style="display:flex;"><span>  Section header string table index: <span style="color:#ae81ff">30</span>
</span></span></code></pre></div><p>观察<code>tools/readelf/Makefile</code>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>readelf: main.o readelf.o
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">$(</span>CC<span style="color:#66d9ef">)</span> $^ -o $@
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>hello: hello.c
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">$(</span>CC<span style="color:#66d9ef">)</span> $^ -o $@ -m32 -static -g
</span></span></code></pre></div><p>区别在于<code>hello</code>为32位程序，<code>readelf</code>是64位程序，且<code>hello</code>的编译有<code>-static</code>修饰，是静态链接的。</p>
<h2 id="thinking-13">Thinking 1.3</h2>
<blockquote>
<p>在理论课上我们了解到，MIPS体系结构上电时，启动入口地址为0xBFC00000（其实启动入口地址是根据具体型号而定的，由硬件逻辑确定，也有可能不是这个地址，但一定是一个确定的地址），但实验操作系统的内核入口并没有放在上电启动地址，而是按照内存布局图放置。思考为什么这样放置内核还能保证内核入口被正确跳转到？
（提示：思考实验中启动过程的两阶段分别由谁执行。）</p></blockquote>
<hr>
<p>系统能够正确跳转到内核入口在于两阶段启动过程和链接脚本控制：</p>
<ol>
<li>
<p>启动阶段划分</p>
<ul>
<li>阶段一：硬件上电后执行固化在 ROM 中的代码（地址 0xBFC00000）</li>
<li>阶段二：Bootloader 加载操作系统内核到指定内存地址</li>
</ul>
</li>
<li>
<p>链接脚本控制（kernel.lds）</p>
</li>
</ol>
<pre tabindex="0"><code class="language-ld" data-lang="ld">/*
 * Set the ENTRY point of the program to _start.
 */
ENTRY(_start)

SECTIONS {
    . = 0x80020000;
    .text : { *(.text) }
	...
}
</code></pre><ol start="3">
<li>入口地址设置（start.S）</li>
</ol>
<pre tabindex="0"><code class="language-mips" data-lang="mips">#include &lt;asm/asm.h&gt;
#include &lt;mmu.h&gt;

.text
EXPORT(_start)
.set at
.set reorder
/* Lab 1 Key Code &#34;enter-kernel&#34; */
    /* clear .bss segment */
    la      v0, bss_start
    la      v1, bss_end
    ...
    j       mips_init
</code></pre><p>实现原理：</p>
<ol>
<li>Bootloader 将内核镜像加载到链接脚本指定的内存地址（0x80020000）</li>
<li>通过<code>ENTRY(_start)</code>指定内核入口符号</li>
<li>汇编代码中 <code>_start</code> 符号通过绝对跳转指令（<code>j mips_init</code>）转移到内核主函数</li>
</ol>
<h1 id="二难点分析与实验体会">二、难点分析与实验体会</h1>
<h2 id="1-elf文件">1. ELF文件</h2>
<p><div class="post-img-view">
    <a data-fancybox="gallery"
         href="Pasted%20image%2020250328172841.png">
        <img loading="lazy" src="/posts/buaa/os/lab-1-report/Pasted%20image%2020250328172841_hu_42ee11080f61b4c9.webp">
    </a>
</div></p>
<p>对ELF文件的概念缺少理解，写完<code>readelf</code>实际使用后才理解其含义。</p>
<h1 id="三原创说明">三、原创说明</h1>
<p>本以为是<code>readelf</code>在运行时无法读取自己，是因为自己正在运行导致的无法读取。在与赵德祥同学讨论后才注意到<code>readelf</code>与<code>hello</code>在64位和32位上的区别，在此致谢。</p>
]]></content:encoded>
    </item>
    <item>
      <title>[BUAA-OS] Lab 0 实验报告</title>
      <link>https://oNya685.github.io/posts/buaa/os/lab-0-report/</link>
      <pubDate>Sun, 16 Mar 2025 11:27:33 +0800</pubDate>
      <guid>https://oNya685.github.io/posts/buaa/os/lab-0-report/</guid>
      <description>&lt;h1 id=&#34;一思考题&#34;&gt;一、思考题&lt;/h1&gt;
&lt;h2 id=&#34;thinking-01&#34;&gt;Thinking 0.1&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;思考下列有关Git的问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在前述已初始化的~/learnGit 目录下，创建一个名为README.txt的文件。执行命令git status &amp;gt; Untracked.txt（其中的 &amp;gt; 为输出重定向，我们将在0.6.3中详细介绍）。&lt;/li&gt;
&lt;li&gt;在README.txt 文件中添加任意文件内容，然后使用add命令，再执行命令git status &amp;gt; Stage.txt。&lt;/li&gt;
&lt;li&gt;提交README.txt，并在提交说明里写入自己的学号。&lt;/li&gt;
&lt;li&gt;执行命令cat Untracked.txt 和cat Stage.txt，对比两次运行的结果，体会README.txt两次所处位置的不同。&lt;/li&gt;
&lt;li&gt;修改README.txt 文件，再执行命令git status &amp;gt; Modified.txt。&lt;/li&gt;
&lt;li&gt;执行命令cat Modified.txt，观察其结果和第一次执行add命令之前的status是否一样，并思考原因。&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h3 id=&#34;1-untrackedtxt&#34;&gt;1. Untracked.txt&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$  cat Untracked.txt
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;位于分支 master
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;未跟踪的文件:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  （使用 &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;git add &amp;lt;文件&amp;gt;...&amp;#34;&lt;/span&gt; 以包含要提交的内容）
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        README.txt
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        Untracked.txt
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;提交为空，但是存在尚未跟踪的文件（使用 &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;git add&amp;#34;&lt;/span&gt; 建立跟踪）
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;新建了&lt;code&gt;README.txt&lt;/code&gt;文件，处于Untracked状态。&lt;/p&gt;</description>
      <content:encoded><![CDATA[<h1 id="一思考题">一、思考题</h1>
<h2 id="thinking-01">Thinking 0.1</h2>
<blockquote>
<p>思考下列有关Git的问题：</p>
<ul>
<li>在前述已初始化的~/learnGit 目录下，创建一个名为README.txt的文件。执行命令git status &gt; Untracked.txt（其中的 &gt; 为输出重定向，我们将在0.6.3中详细介绍）。</li>
<li>在README.txt 文件中添加任意文件内容，然后使用add命令，再执行命令git status &gt; Stage.txt。</li>
<li>提交README.txt，并在提交说明里写入自己的学号。</li>
<li>执行命令cat Untracked.txt 和cat Stage.txt，对比两次运行的结果，体会README.txt两次所处位置的不同。</li>
<li>修改README.txt 文件，再执行命令git status &gt; Modified.txt。</li>
<li>执行命令cat Modified.txt，观察其结果和第一次执行add命令之前的status是否一样，并思考原因。</li>
</ul></blockquote>
<hr>
<h3 id="1-untrackedtxt">1. Untracked.txt</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>$  cat Untracked.txt
</span></span><span style="display:flex;"><span>位于分支 master
</span></span><span style="display:flex;"><span>未跟踪的文件:
</span></span><span style="display:flex;"><span>  （使用 <span style="color:#e6db74">&#34;git add &lt;文件&gt;...&#34;</span> 以包含要提交的内容）
</span></span><span style="display:flex;"><span>        README.txt
</span></span><span style="display:flex;"><span>        Untracked.txt
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>提交为空，但是存在尚未跟踪的文件（使用 <span style="color:#e6db74">&#34;git add&#34;</span> 建立跟踪）
</span></span></code></pre></div><p>新建了<code>README.txt</code>文件，处于Untracked状态。</p>
<h3 id="2-stagedtxt">2. Staged.txt</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>$  cat Staged.txt
</span></span><span style="display:flex;"><span>位于分支 master
</span></span><span style="display:flex;"><span>要提交的变更：
</span></span><span style="display:flex;"><span>  （使用 <span style="color:#e6db74">&#34;git restore --staged &lt;文件&gt;...&#34;</span> 以取消暂存）
</span></span><span style="display:flex;"><span>        新文件：   README.txt
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>未跟踪的文件:
</span></span><span style="display:flex;"><span>  （使用 <span style="color:#e6db74">&#34;git add &lt;文件&gt;...&#34;</span> 以包含要提交的内容）
</span></span><span style="display:flex;"><span>        Staged.txt
</span></span><span style="display:flex;"><span>        Untracked.txt
</span></span></code></pre></div><p>修改了<code>README.txt</code>的文件内容，并跟踪和暂存该文件，处于Staged状态。</p>
<h3 id="3-modifiedtxt">3. Modified.txt</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>$  cat Modified.txt
</span></span><span style="display:flex;"><span>位于分支 master
</span></span><span style="display:flex;"><span>尚未暂存以备提交的变更：
</span></span><span style="display:flex;"><span>  （使用 <span style="color:#e6db74">&#34;git add &lt;文件&gt;...&#34;</span> 更新要提交的内容）
</span></span><span style="display:flex;"><span>  （使用 <span style="color:#e6db74">&#34;git restore &lt;文件&gt;...&#34;</span> 丢弃工作区的改动）
</span></span><span style="display:flex;"><span>        修改：     README.txt
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>未跟踪的文件:
</span></span><span style="display:flex;"><span>  （使用 <span style="color:#e6db74">&#34;git add &lt;文件&gt;...&#34;</span> 以包含要提交的内容）
</span></span><span style="display:flex;"><span>        Modified.txt
</span></span><span style="display:flex;"><span>        Staged.txt
</span></span><span style="display:flex;"><span>        Untracked.txt
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>修改尚未加入提交（使用 <span style="color:#e6db74">&#34;git add&#34;</span> 和/或 <span style="color:#e6db74">&#34;git commit -a&#34;</span>）
</span></span></code></pre></div><p><code>README.txt</code>经暂存和提交后处于Unmodified状态，修改文件内容使其进入Modified状态等待暂存。</p>
<h2 id="thinking-02">Thinking 0.2</h2>
<blockquote>
<p>仔细看看<a href="%e5%9b%be%200.10%20-%20Git%20%e4%b8%ad%e7%9a%84%e5%9b%9b%e7%a7%8d%e7%8a%b6%e6%80%81%e8%bd%ac%e6%8d%a2%e5%85%b3%e7%b3%bb.png" target="_blank">0.10</a>
，思考一下箭头中的add the file、stage the file和commit分别对应的是Git里的哪些命令呢？</p>
<p><div class="post-img-view">
    <a data-fancybox="gallery"
         href="%E5%9B%BE%200.10%20-%20Git%20%E4%B8%AD%E7%9A%84%E5%9B%9B%E7%A7%8D%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2%E5%85%B3%E7%B3%BB.png">
        <img alt="图 0.10 - Git 中的四种状态转换关系" loading="lazy" src="/posts/buaa/os/lab-0-report/%E5%9B%BE%200.10%20-%20Git%20%E4%B8%AD%E7%9A%84%E5%9B%9B%E7%A7%8D%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2%E5%85%B3%E7%B3%BB_hu_85b07da4fcfbe74e.webp">
    </a>
</div></p></blockquote>
<hr>
<h3 id="1-add-the-file">1. add the file</h3>
<p>add the file 对应的是<code>git add</code>。</p>
<h3 id="2-stage-the-file">2. stage the file</h3>
<p>stage the file 对应的是<code>git add</code>。</p>
<h3 id="3-commit">3. commit</h3>
<p>commit 对应的是<code>git commit</code>。</p>
<h2 id="thinking-03">Thinking 0.3</h2>
<blockquote>
<p>思考下列问题：</p>
<ol>
<li>代码文件print.c被错误删除时，应当使用什么命令将其恢复？</li>
<li>代码文件print.c被错误删除后，执行了git rm print.c命令，此时应当使用什么命令将其恢复？</li>
<li>无关文件hello.txt已经被添加到暂存区时，如何在不删除此文件的前提下将其移出暂存区？</li>
</ol></blockquote>
<h3 id="1-代码文件-printc-被错误删除时应当使用什么命令将其恢复">1. 代码文件 print.c 被错误删除时，应当使用什么命令将其恢复？</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>git restore print.c
</span></span></code></pre></div><p>print.c 尚未执行<code>git add</code>，故可以从暂存区将print.c恢复到工作区中。</p>
<h3 id="2-代码文件-printc-被错误删除后执行了-git-rm-printc-命令此时应当使用什么命令将其恢复">2. 代码文件 print.c 被错误删除后，执行了 git rm print.c 命令，此时应当使用什么命令将其恢复？</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>git reset HEAD print.c
</span></span><span style="display:flex;"><span>git restore print.c
</span></span></code></pre></div><p>首先撤销暂存区的修改（删除了print.c），然后将print.c从暂存区恢复到工作区。</p>
<h3 id="3-无关文件-hellotxt-已经被添加到暂存区时如何在不删除此文件的前提下将其移出暂存区">3. 无关文件 hello.txt 已经被添加到暂存区时，如何在不删除此文件的前提下将其移出暂存区？</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>git reset HEAD hello.txt
</span></span></code></pre></div><p>撤销暂存区的修改，把暂存区恢复到执行<code>git add</code>之前的状态。</p>
<h2 id="thinking-04">Thinking 0.4</h2>
<blockquote>
<p>思考下列有关 Git 的问题：</p>
<ul>
<li>找到在 /home/22xxxxxx/learnGit 下刚刚创建的 README.txt 文件，若不存在则新建该文件。</li>
<li>在文件里加入 Testing 1，git add，git commit，提交说明记为 1。</li>
<li>模仿上述做法，把 1 分别改为 2 和 3，再提交两次。</li>
<li>使用 git log 命令查看提交日志，看是否已经有三次提交，记下提交说明为 3 的哈希值<sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup>。</li>
<li>进行版本回退。执行命令 git reset &ndash;hard HEAD^ 后，再执行 git log，观察其变化。</li>
<li>找到提交说明为 1 的哈希值，执行命令 git reset &ndash;hard &lt;hash&gt; 后，再执行 git log，观察其变化。</li>
<li>现在已经回到了旧版本，为了再次回到新版本，执行 git reset &ndash;hard &lt;hash&gt;，再执行 git log，观察其变化。</li>
</ul></blockquote>
<hr>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>$  git log
</span></span><span style="display:flex;"><span>commit a6ebe244272dd6bcb1f57ba9af3c957f3e7235b3 <span style="color:#f92672">(</span>HEAD -&gt; master<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>Author: 姜宇墨 &lt;YumoJiang@buaa.edu.cn&gt;
</span></span><span style="display:flex;"><span>Date:   Tue Mar <span style="color:#ae81ff">11</span> 19:08:41 <span style="color:#ae81ff">2025</span> +0800
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#ae81ff">3</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>commit 1d11df1461528ce8e2b67151384d4b24bdfec571
</span></span><span style="display:flex;"><span>Author: 姜宇墨 &lt;YumoJiang@buaa.edu.cn&gt;
</span></span><span style="display:flex;"><span>Date:   Tue Mar <span style="color:#ae81ff">11</span> 19:08:33 <span style="color:#ae81ff">2025</span> +0800
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#ae81ff">2</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>commit 3f8eb4043efae29bbb9eb626444f955a825f3535
</span></span><span style="display:flex;"><span>Author: 姜宇墨 &lt;YumoJiang@buaa.edu.cn&gt;
</span></span><span style="display:flex;"><span>Date:   Tue Mar <span style="color:#ae81ff">11</span> 19:08:12 <span style="color:#ae81ff">2025</span> +0800
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#ae81ff">1</span>
</span></span></code></pre></div><p>提交说明为<code>3</code>的哈希值为<code>a6ebe244272dd6bcb1f57ba9af3c957f3e7235b3</code>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>$  git reset --hard HEAD^
</span></span><span style="display:flex;"><span>HEAD 现在位于 1d11df1 <span style="color:#ae81ff">2</span>
</span></span><span style="display:flex;"><span>$  git log
</span></span><span style="display:flex;"><span>commit 1d11df1461528ce8e2b67151384d4b24bdfec571 <span style="color:#f92672">(</span>HEAD -&gt; master<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>Author: 姜宇墨 &lt;YumoJiang@buaa.edu.cn&gt;
</span></span><span style="display:flex;"><span>Date:   Tue Mar <span style="color:#ae81ff">11</span> 19:08:33 <span style="color:#ae81ff">2025</span> +0800
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#ae81ff">2</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>commit 3f8eb4043efae29bbb9eb626444f955a825f3535
</span></span><span style="display:flex;"><span>Author: 姜宇墨 &lt;YumoJiang@buaa.edu.cn&gt;
</span></span><span style="display:flex;"><span>Date:   Tue Mar <span style="color:#ae81ff">11</span> 19:08:12 <span style="color:#ae81ff">2025</span> +0800
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#ae81ff">1</span>
</span></span></code></pre></div><p>变化：当前Git仓库的状态回到了<code>2</code>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>$  git reset --hard 3f8eb4043efae29bbb9eb626444f955a825f3535
</span></span><span style="display:flex;"><span>HEAD 现在位于 3f8eb40 <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>$  git log
</span></span><span style="display:flex;"><span>commit 3f8eb4043efae29bbb9eb626444f955a825f3535 <span style="color:#f92672">(</span>HEAD -&gt; master<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>Author: 姜宇墨 &lt;YumoJiang@buaa.edu.cn&gt;
</span></span><span style="display:flex;"><span>Date:   Tue Mar <span style="color:#ae81ff">11</span> 19:08:12 <span style="color:#ae81ff">2025</span> +0800
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#ae81ff">1</span>
</span></span></code></pre></div><p>变化：当前Git仓库的状态回到了<code>1</code>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>$  git reset --hard a6ebe244272dd6bcb1f57ba9af3c957f3e7235b3
</span></span><span style="display:flex;"><span>HEAD 现在位于 a6ebe24 <span style="color:#ae81ff">3</span>
</span></span><span style="display:flex;"><span>$  git log
</span></span><span style="display:flex;"><span>commit a6ebe244272dd6bcb1f57ba9af3c957f3e7235b3 <span style="color:#f92672">(</span>HEAD -&gt; master<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>Author: 姜宇墨 &lt;YumoJiang@buaa.edu.cn&gt;
</span></span><span style="display:flex;"><span>Date:   Tue Mar <span style="color:#ae81ff">11</span> 19:08:41 <span style="color:#ae81ff">2025</span> +0800
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#ae81ff">3</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>commit 1d11df1461528ce8e2b67151384d4b24bdfec571
</span></span><span style="display:flex;"><span>Author: 姜宇墨 &lt;YumoJiang@buaa.edu.cn&gt;
</span></span><span style="display:flex;"><span>Date:   Tue Mar <span style="color:#ae81ff">11</span> 19:08:33 <span style="color:#ae81ff">2025</span> +0800
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#ae81ff">2</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>commit 3f8eb4043efae29bbb9eb626444f955a825f3535
</span></span><span style="display:flex;"><span>Author: 姜宇墨 &lt;YumoJiang@buaa.edu.cn&gt;
</span></span><span style="display:flex;"><span>Date:   Tue Mar <span style="color:#ae81ff">11</span> 19:08:12 <span style="color:#ae81ff">2025</span> +0800
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#ae81ff">1</span>
</span></span></code></pre></div><p>变化：当前Git仓库的状态回到了<code>3</code>。</p>
<h2 id="thinking-05">Thinking 0.5</h2>
<blockquote>
<p>执行如下命令, 并查看结果</p>
<ul>
<li>echo first</li>
<li>echo second &gt; output.txt</li>
<li>echo third &gt; output.txt</li>
<li>echo forth &raquo; output.txt</li>
</ul></blockquote>
<hr>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>$  echo first
</span></span><span style="display:flex;"><span>first
</span></span><span style="display:flex;"><span>$  echo second &gt; output.txt <span style="color:#f92672">&amp;&amp;</span> cat output.txt
</span></span><span style="display:flex;"><span>second
</span></span><span style="display:flex;"><span>$  echo third &gt; output.txt <span style="color:#f92672">&amp;&amp;</span> cat output.txt
</span></span><span style="display:flex;"><span>third
</span></span><span style="display:flex;"><span>$  echo forth &gt;&gt; output.txt <span style="color:#f92672">&amp;&amp;</span> cat output.txt
</span></span><span style="display:flex;"><span>third
</span></span><span style="display:flex;"><span>forth
</span></span></code></pre></div><h2 id="thinking-06">Thinking 0.6</h2>
<blockquote>
<p>使用你知道的方法（包括重定向）创建下图内容的文件（文件命名为 test），将创建该文件的命令序列保存在command文件中，并将test文件作为批处理文件运行，将运行结果输出至result文件中。给出command文件和result文件的内容，并对最后的结果进行解释说明（可以从test文件的内容入手）。具体实现的过程中思考下列问题: echo echo Shell Start 与 echo `echo Shell Start` 效果是否有区别; echo echo $c&gt;file1 与 echo `echo $c&gt;file1` 效果是否有区别.</p></blockquote>
<hr>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#75715e"># command</span>
</span></span><span style="display:flex;"><span>echo <span style="color:#e6db74">&#39;echo Shell Start...&#39;</span> &gt; test
</span></span><span style="display:flex;"><span>echo <span style="color:#e6db74">&#39;echo set a = 1&#39;</span> &gt;&gt; test
</span></span><span style="display:flex;"><span>echo <span style="color:#e6db74">&#39;a=1&#39;</span> &gt;&gt; test
</span></span><span style="display:flex;"><span>echo <span style="color:#e6db74">&#39;echo set b = 2&#39;</span> &gt;&gt; test
</span></span><span style="display:flex;"><span>echo <span style="color:#e6db74">&#39;b=2&#39;</span> &gt;&gt; test
</span></span><span style="display:flex;"><span>echo <span style="color:#e6db74">&#39;echo set c = a+b&#39;</span> &gt;&gt; test
</span></span><span style="display:flex;"><span>echo <span style="color:#e6db74">&#39;c=$[$a+$b]&#39;</span> &gt;&gt; test
</span></span><span style="display:flex;"><span>echo <span style="color:#e6db74">&#39;echo c = $c&#39;</span> &gt;&gt; test
</span></span><span style="display:flex;"><span>echo <span style="color:#e6db74">&#39;echo save c to ./file1&#39;</span> &gt;&gt; test
</span></span><span style="display:flex;"><span>echo <span style="color:#e6db74">&#39;echo $c&gt;file1&#39;</span> &gt;&gt; test
</span></span><span style="display:flex;"><span>echo <span style="color:#e6db74">&#39;echo save b to ./file2&#39;</span> &gt;&gt; test
</span></span><span style="display:flex;"><span>echo <span style="color:#e6db74">&#39;echo $b&gt;file2&#39;</span> &gt;&gt; test
</span></span><span style="display:flex;"><span>echo <span style="color:#e6db74">&#39;echo save a to ./file3&#39;</span> &gt;&gt; test
</span></span><span style="display:flex;"><span>echo <span style="color:#e6db74">&#39;echo $a&gt;file3&#39;</span> &gt;&gt; test
</span></span><span style="display:flex;"><span>echo <span style="color:#e6db74">&#39;echo save file1 file2 file3 to file4&#39;</span> &gt;&gt; test
</span></span><span style="display:flex;"><span>echo <span style="color:#e6db74">&#39;cat file1&gt;file4&#39;</span> &gt;&gt; test
</span></span><span style="display:flex;"><span>echo <span style="color:#e6db74">&#39;cat file2&gt;&gt;file4&#39;</span> &gt;&gt; test
</span></span><span style="display:flex;"><span>echo <span style="color:#e6db74">&#39;cat file3&gt;&gt;file4&#39;</span> &gt;&gt; test
</span></span><span style="display:flex;"><span>echo <span style="color:#e6db74">&#39;echo save file4 to ./result&#39;</span> &gt;&gt; test
</span></span><span style="display:flex;"><span>echo <span style="color:#e6db74">&#39;cat file4&gt;&gt;result&#39;</span> &gt;&gt; test
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#75715e"># test</span>
</span></span><span style="display:flex;"><span>echo Shell Start...        <span style="color:#75715e"># 输出初始化提示</span>
</span></span><span style="display:flex;"><span>echo set a <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>a<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>                        <span style="color:#75715e"># 设置变量a=1</span>
</span></span><span style="display:flex;"><span>echo set b <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>
</span></span><span style="display:flex;"><span>b<span style="color:#f92672">=</span><span style="color:#ae81ff">2</span>                        <span style="color:#75715e"># 设置变量b=2</span>
</span></span><span style="display:flex;"><span>echo set c <span style="color:#f92672">=</span> a+b
</span></span><span style="display:flex;"><span>c<span style="color:#f92672">=</span>$<span style="color:#f92672">[</span>$a+$b<span style="color:#f92672">]</span>                 <span style="color:#75715e"># 执行算术运算c=a+b=1+2=3</span>
</span></span><span style="display:flex;"><span>echo c <span style="color:#f92672">=</span> $c                <span style="color:#75715e"># 输出计算结果</span>
</span></span><span style="display:flex;"><span>echo save c to ./file1
</span></span><span style="display:flex;"><span>echo $c&gt;file1              <span style="color:#75715e"># 将c的值写入file1</span>
</span></span><span style="display:flex;"><span>echo save b to ./file2
</span></span><span style="display:flex;"><span>echo $b&gt;file2              <span style="color:#75715e"># 将b的值写入file2</span>
</span></span><span style="display:flex;"><span>echo save a to ./file3
</span></span><span style="display:flex;"><span>echo $a&gt;file3              <span style="color:#75715e"># 将a的值写入file3</span>
</span></span><span style="display:flex;"><span>echo save file1 file2 file3 to file4
</span></span><span style="display:flex;"><span>cat file1&gt;file4            <span style="color:#75715e"># 创建file4并写入file1内容</span>
</span></span><span style="display:flex;"><span>cat file2&gt;&gt;file4           <span style="color:#75715e"># 追加file2内容</span>
</span></span><span style="display:flex;"><span>cat file3&gt;&gt;file4           <span style="color:#75715e"># 追加file3内容</span>
</span></span><span style="display:flex;"><span>echo save file4 to ./result
</span></span><span style="display:flex;"><span>cat file4&gt;&gt;result          <span style="color:#75715e"># 最终结果是c,b,a的值</span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>$  ./test
</span></span><span style="display:flex;"><span>Shell Start...
</span></span><span style="display:flex;"><span>set a <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>set b <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>
</span></span><span style="display:flex;"><span>set c <span style="color:#f92672">=</span> a+b
</span></span><span style="display:flex;"><span>c <span style="color:#f92672">=</span> <span style="color:#ae81ff">3</span>
</span></span><span style="display:flex;"><span>save c to ./file1
</span></span><span style="display:flex;"><span>save b to ./file2
</span></span><span style="display:flex;"><span>save a to ./file3
</span></span><span style="display:flex;"><span>save file1 file2 file3 to file4
</span></span><span style="display:flex;"><span>save file4 to ./result
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>$  cat result
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">3</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">2</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">1</span>
</span></span></code></pre></div><p>反引号会先执行命令替换，改变重定向行为。</p>
<table>
  <thead>
      <tr>
          <th>echo echo Shell Start</th>
          <th>echo `echo Shell Start`</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>输出字符串<code>echo Shell Start</code></td>
          <td>先执行命令<code>echo Shell Start</code>再输出该命令的执行结果<code>Shell Start</code></td>
      </tr>
  </tbody>
</table>
<table>
  <thead>
      <tr>
          <th>echo echo $c&gt;file1</th>
          <th>echo `echo $c&gt;file1`</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>将字符串<code>echo 3</code>写入file1</td>
          <td>先将<code>3</code>写入file1，再输出写入的执行结果（为空），即终端无输出</td>
      </tr>
  </tbody>
</table>
<h1 id="二难点分析与实验体会">二、难点分析与实验体会</h1>
<p>本次实验的主要难点在于<strong>工具链的命令行参数</strong>和<strong>shell编程</strong>掌握不够熟练。</p>
<h3 id="难点1sed的用法">难点1：<code>sed</code>的用法</h3>
<p>为实现在 hello_os.sh 所处的目录新建一个名为BBB的文件，其内容为 AAA文件的第8、32、128、512、1024行的内容提取，构造<code>sed</code>命令</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sed -n <span style="color:#e6db74">&#39;8p;32p;128p;512p;1024p&#39;</span> <span style="color:#e6db74">&#34;</span>$1<span style="color:#e6db74">&#34;</span> &gt; <span style="color:#e6db74">&#34;</span>$2<span style="color:#e6db74">&#34;</span>
</span></span></code></pre></div><h3 id="难点2awk行号提取">难点2：<code>awk</code>行号提取</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>grep -n <span style="color:#e6db74">&#34;</span>$2<span style="color:#e6db74">&#34;</span> ./<span style="color:#e6db74">&#34;</span>$1<span style="color:#e6db74">&#34;</span> | awk -F <span style="color:#e6db74">&#39;:&#39;</span> <span style="color:#e6db74">&#39;{print $1}&#39;</span> &gt; ./<span style="color:#e6db74">&#34;</span>$3<span style="color:#e6db74">&#34;</span>
</span></span></code></pre></div><h3 id="难点3gcc与make的特殊用法">难点3：GCC与Make的特殊用法</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#75715e"># 多目录编译示例</span>
</span></span><span style="display:flex;"><span>gcc -I ../include -c fibo.c -o fibo.o
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 调用子目录make命令示例</span>
</span></span><span style="display:flex;"><span>make -C code fibo.o
</span></span></code></pre></div><hr>
<h1 id="三原创说明">三、原创说明</h1>
<p>在本次实验中，对工具链的使用参考了官方manual和<code>--help</code>参数。</p>
<p>在Neovim和LazyVim的安装与配置中，参考了<a href="https://blog.csdn.net/m0_60670525/article/details/136329707" target="_blank">如何在Ubuntu上安装最新版本的Neovim并快速配置_ubuntu安装neovim-CSDN博客</a>
</p>
<div class="footnotes" role="doc-endnotes">
<hr>
<ol>
<li id="fn:1">
<p>使用 git log 命令时，在 commit 标识符后的一长串数字和字母组成的字符串&#160;<a href="#fnref:1" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
</ol>
</div>
]]></content:encoded>
    </item>
    <item>
      <title>[BUAA-OS] 理论作业 1</title>
      <link>https://oNya685.github.io/posts/buaa/os/homework-1/</link>
      <pubDate>Sun, 16 Mar 2025 11:19:17 +0800</pubDate>
      <guid>https://oNya685.github.io/posts/buaa/os/homework-1/</guid>
      <description>&lt;p&gt;&lt;strong&gt;&lt;a href=&#34;%e4%bd%9c%e4%b8%9a1.pdf&#34; target=&#34;_blank&#34;&gt;点此查看作业源文件&lt;/a&gt;
&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&#34;1什么是多道程序设计多道程序设计与分时系统的区别是什么&#34;&gt;1.什么是多道程序设计？多道程序设计与分时系统的区别是什么？&lt;/h1&gt;
&lt;p&gt;多道程序设计技术，是指允许多个程序同时进⼊内存并运⾏。即同时把多个程序放⼊内存中，并允许它们交替在CPU中运⾏，共享系统中的各种硬、软件资源，当⼀道程序因I/O请求⽽暂停运⾏时，CPU便⽴即转去运⾏另⼀道程序。多道程序设计技术提⾼了CPU、I/O设备和内存的利⽤率，从⽽提⾼了整个系统的资源利⽤率和系统吞吐量，最终提⾼了整个系统的效率。&lt;/p&gt;</description>
      <content:encoded><![CDATA[<p><strong><a href="%e4%bd%9c%e4%b8%9a1.pdf" target="_blank">点此查看作业源文件</a>
</strong></p>
<h1 id="1什么是多道程序设计多道程序设计与分时系统的区别是什么">1.什么是多道程序设计？多道程序设计与分时系统的区别是什么？</h1>
<p>多道程序设计技术，是指允许多个程序同时进⼊内存并运⾏。即同时把多个程序放⼊内存中，并允许它们交替在CPU中运⾏，共享系统中的各种硬、软件资源，当⼀道程序因I/O请求⽽暂停运⾏时，CPU便⽴即转去运⾏另⼀道程序。多道程序设计技术提⾼了CPU、I/O设备和内存的利⽤率，从⽽提⾼了整个系统的资源利⽤率和系统吞吐量，最终提⾼了整个系统的效率。</p>
<p>多道程序设计与分时系统的区别在于：多道程序设计主要关注的是如何让多个程序在内存中同时存在并交替执⾏，以提⾼资源利⽤率。分时系统则是在多道程序设计的基础上进⼀步发展，它不仅允许多个程序并发执⾏，还通过时间⽚轮转的⽅式为每个⽤户分配CPU时间，使得多个⽤户可以⼏乎同时使⽤计算机，提供交互式服务。</p>
<h1 id="2什么原因推动了操作系统从批处理发展到多道程序进而发展到分时系统">2.什么原因推动了操作系统从批处理发展到多道程序，进而发展到分时系统？</h1>
<p>批处理系统的运⾏效率被低速I/O设备限制，CPU空闲时间多，利⽤率低，因此发展出多道程序系统；</p>
<p>多道程序系统平均周转时间⻓，不能提供交互作⽤能⼒，因此发展出允许多个⽤户共享计算机，多个程序分时共享硬、软件资源的分时系统。</p>
<h1 id="3什么是陷阱与中断的区别是什么什么是系统调用">3.什么是陷阱？与中断的区别是什么？什么是系统调用？</h1>
<p>陷阱是⼀种同步异常，是程序内部有意设置的某⼀特定指令执⾏的结果，例如系统调⽤。陷阱是程序执⾏过程中预期的⾏为，可以复现，⽤于请求操作系统提供服务等。</p>
<p>中断是⼀种异步异常，通常由外部事件（I/O设备、处理器时钟或定时器）触发，与处理器正在执⾏的内容⽆关。中断是不可预测的，⽤于处理外部事件。</p>
<p>系统调⽤是⽤户程序与操作系统内核之间的接⼝，允许⽤户程序请求操作系统提供的服务。系统调⽤本质上是⼀种同步异常，或陷阱，⽤于安全地进⼊内核模式并执⾏特权操作。</p>
<h1 id="4判断可移植的操作系统可以从一个系统架构移植到另外一个系统架构而无需修改">4.判断：可移植的操作系统可以从一个系统架构移植到另外一个系统架构而无需修改。</h1>
<p>错误。不同系统架构之间存在指令集差异、内存管理方式不同、硬件寄存器配置不一致等根本性区别，操作系统必须针对这些硬件特性进行调整。</p>
<h2 id="1请解释为什么构建完全可移植的os是不可能的">(1)请解释为什么构建完全可移植的OS是不可能的？</h2>
<p>不同硬件架构的指令集、总线设计和CPU字长等存在差异，操作系统必须依赖硬件相关代码，⽆法完全通⽤。</p>
<h2 id="2如果需要你设计一个高度可移植的os那么请描述你需要设计的两个层次">(2)如果需要你设计一个高度可移植的OS，那么请描述你需要设计的两个层次？</h2>
<p>高度可移植的操作系统由机器相关层和机器无关层组成。机器无关层只需实现一次即可。</p>
<p>机器相关层处理硬件的具体特性，必须针对每个架构单独实现。该层为机器无关层提供统一的接口。为实现高度可移植性，机器相关层的规模应尽可能最小化。</p>
<h1 id="5在设计操作系统时一些设计指标是相互矛盾的例如资源利用率吞吐量处理时间健壮性等请给出一对相互矛盾的设计实例">5.在设计操作系统时，一些设计指标是相互矛盾的，例如资源利用率、吞吐量、处理时间、健壮性等。请给出一对相互矛盾的设计实例。</h1>
<p>资源利⽤率与响应时间。</p>
<p>资源利⽤率⾼意味着尽可能多地利⽤系统资源，但可能导致频繁的切换和复杂的调度策略，从⽽增加响应时间。响应时间短要求操作系统能够快速响应⽤户请求，可能保留更多的资源⽤于即时响应，导致资源利⽤率下降。</p>
<h1 id="6一个计算机系统有输入机一台打印机两台现有二道程序同时投入运行且程序a先开始运行程序b后运行程序a的运行轨迹为计算50ms打印信息100ms再计算50ms打印信息100ms结束程序b运行的轨迹为计算50ms输入数据80ms再计算100ms结束要求">6.一个计算机系统有输入机一台、打印机两台，现有二道程序同时投入运行，且程序A先开始运行，程序B后运行。程序A的运行轨迹为：计算50ms，打印信息100ms，再计算50ms，打印信息100ms，结束。程序B运行的轨迹为：计算50ms，输入数据80ms，再计算100ms，结束。要求：</h1>
<h2 id="1用图画出这二道程序并发执行时的工作情况">(1)用图画出这二道程序并发执行时的工作情况。</h2>
<p><div class="post-img-view">
    <a data-fancybox="gallery"
         href="Pasted%20image%2020250316112252.png">
        <img loading="lazy" src="/posts/buaa/os/homework-1/Pasted%20image%2020250316112252_hu_714830f66a53f33c.webp">
    </a>
</div></p>
<h2 id="2说明在二道程序运行时cpu有无空闲等待若有在哪段时间内等待为什么会空闲等待">(2)说明在二道程序运行时，CPU有无空闲等待？若有，在哪段时间内等待？为什么会空闲等待？</h2>
<p>有。在100ms~150ms，程序A在打印信息，程序B在输入数据，故CPU处于空闲等待。</p>
<h2 id="3程序ab运行时有无等待现象在什么时候会发生等待现象">(3)程序A、B运行时有无等待现象？在什么时候会发生等待现象？</h2>
<p>程序A没有，程序B有。</p>
<p>在180ms~200ms，程序B完成了输入数据，在等待CPU空闲，而程序A占用了处理器，正在进行计算，故程序B等待了20ms。</p>
]]></content:encoded>
    </item>
  </channel>
</rss>
